{"file":"/home/wetooa/Documents/code/projects/mentara/mentara-api/src/messaging/services/websocket-auth.service.ts","mappings":";;;;;;;;;;AAAA,2CAAoD;AACpD,4CAA6C;AAStC,IAAM,oBAAoB,4BAA1B,MAAM,oBAAoB;IACd,MAAM,GAAG,IAAI,eAAM,CAAC,sBAAoB,CAAC,IAAI,CAAC,CAAC;IAEhE,KAAK,CAAC,kBAAkB,CAAC,MAAc;QACrC,IAAI,CAAC;YACH,qCAAqC;YACrC,MAAM,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;YAExC,IAAI,CAAC,KAAK,EAAE,CAAC;gBACX,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,MAAM,CAAC,EAAE,gCAAgC,CAAC,CAAC;gBACtE,OAAO,IAAI,CAAC;YACd,CAAC;YAED,0BAA0B;YAC1B,MAAM,aAAa,GAAG,MAAM,IAAA,qBAAW,EAAC,KAAK,EAAE;gBAC7C,SAAS,EAAE,OAAO,CAAC,GAAG,CAAC,gBAAgB,IAAI,EAAE;aAC9C,CAAC,CAAC;YAEH,IAAI,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC;gBACvB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,MAAM,CAAC,EAAE,4BAA4B,CAAC,CAAC;gBAClE,OAAO,IAAI,CAAC;YACd,CAAC;YAED,IAAI,CAAC,MAAM,CAAC,GAAG,CACb,UAAU,MAAM,CAAC,EAAE,0BAA0B,aAAa,CAAC,GAAG,EAAE,CACjE,CAAC;YAEF,OAAO;gBACL,MAAM,EAAE,aAAa,CAAC,GAAG;gBACzB,IAAI,EAAE,aAAa,CAAC,IAA0B;aAC/C,CAAC;QACJ,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CACf,UAAU,MAAM,CAAC,EAAE,yBAAyB,EAC5C,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,CAC/C,CAAC;YACF,OAAO,IAAI,CAAC;QACd,CAAC;IACH,CAAC;IAEO,YAAY,CAAC,MAAc;QACjC,qDAAqD;QAErD,yCAAyC;QACzC,MAAM,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC,OAAO,CAAC,aAAa,CAAC;QAC1D,IACE,UAAU;YACV,OAAO,UAAU,KAAK,QAAQ;YAC9B,UAAU,CAAC,UAAU,CAAC,SAAS,CAAC,EAChC,CAAC;YACD,MAAM,KAAK,GAAG,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;YAC7C,OAAO,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;QACzC,CAAC;QAED,8BAA8B;QAC9B,MAAM,SAAS,GAAG,MAAM,CAAC,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC;QAC/C,IAAI,SAAS,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE,CAAC;YAC/C,OAAO,SAAS,CAAC;QACnB,CAAC;QAED,qBAAqB;QACrB,MAAM,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,CAAC;QACjD,IAAI,UAAU,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE,CAAC;YACjD,OAAO,UAAU,CAAC;QACpB,CAAC;QAED,sCAAsC;QACtC,MAAM,OAAO,GAAG,MAAM,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC;QAChD,IAAI,OAAO,EAAE,CAAC;YACZ,MAAM,aAAa,GAAG,IAAI,CAAC,kBAAkB,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;YACpE,IAAI,aAAa,EAAE,CAAC;gBAClB,OAAO,aAAa,CAAC;YACvB,CAAC;QACH,CAAC;QAED,OAAO,IAAI,CAAC;IACd,CAAC;IAEO,kBAAkB,CAAC,OAAe,EAAE,IAAY;QACtD,IAAI,CAAC;YACH,iDAAiD;YACjD,MAAM,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,qBAAqB,EAAE,MAAM,CAAC,CAAC;YAChE,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,MAAM,CAAC,QAAQ,WAAW,UAAU,CAAC,CAAC,CAAC;YACvE,IAAI,KAAK,IAAI,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;gBACtB,OAAO,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACtC,CAAC;YACD,OAAO,IAAI,CAAC;QACd,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,sCAAsC,IAAI,GAAG,EAAE,KAAK,CAAC,CAAC;YACvE,OAAO,IAAI,CAAC;QACd,CAAC;IACH,CAAC;IAED,KAAK,CAAC,oBAAoB,CAAC,KAAa;QACtC,IAAI,CAAC;YACH,0DAA0D;YAC1D,MAAM,IAAA,qBAAW,EAAC,KAAK,EAAE;gBACvB,SAAS,EAAE,OAAO,CAAC,GAAG,CAAC,gBAAgB,IAAI,EAAE;aAC9C,CAAC,CAAC;YAEH,kCAAkC;YAClC,OAAO,KAAK,CAAC;QACf,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,uBAAuB,EAAE,KAAK,CAAC,CAAC;YACjD,OAAO,IAAI,CAAC;QACd,CAAC;IACH,CAAC;CACF,CAAA;AA3GY,oDAAoB;+BAApB,oBAAoB;IADhC,IAAA,mBAAU,GAAE;GACA,oBAAoB,CA2GhC","names":[],"sources":["/home/wetooa/Documents/code/projects/mentara/mentara-api/src/messaging/services/websocket-auth.service.ts"],"sourcesContent":["import { Injectable, Logger } from '@nestjs/common';\nimport { verifyToken } from '@clerk/backend';\nimport { Socket } from 'socket.io';\n\nexport interface AuthenticatedUser {\n  userId: string;\n  role?: string;\n}\n\n@Injectable()\nexport class WebSocketAuthService {\n  private readonly logger = new Logger(WebSocketAuthService.name);\n\n  async authenticateSocket(socket: Socket): Promise<AuthenticatedUser | null> {\n    try {\n      // Extract token from various sources\n      const token = this.extractToken(socket);\n\n      if (!token) {\n        this.logger.warn(`Socket ${socket.id} connected without valid token`);\n        return null;\n      }\n\n      // Verify token with Clerk\n      const verifiedToken = await verifyToken(token, {\n        secretKey: process.env.CLERK_SECRET_KEY ?? '',\n      });\n\n      if (!verifiedToken.sub) {\n        this.logger.warn(`Socket ${socket.id} has invalid token payload`);\n        return null;\n      }\n\n      this.logger.log(\n        `Socket ${socket.id} authenticated as user ${verifiedToken.sub}`,\n      );\n\n      return {\n        userId: verifiedToken.sub,\n        role: verifiedToken.role as string | undefined,\n      };\n    } catch (error) {\n      this.logger.error(\n        `Socket ${socket.id} authentication failed:`,\n        error instanceof Error ? error.message : error,\n      );\n      return null;\n    }\n  }\n\n  private extractToken(socket: Socket): string | null {\n    // Try different token sources in order of preference\n\n    // 1. Authorization header (Bearer token)\n    const authHeader = socket.handshake.headers.authorization;\n    if (\n      authHeader &&\n      typeof authHeader === 'string' &&\n      authHeader.startsWith('Bearer ')\n    ) {\n      const token = authHeader.substring(7).trim();\n      return token.length > 0 ? token : null;\n    }\n\n    // 2. Auth object in handshake\n    const authToken = socket.handshake.auth?.token;\n    if (authToken && typeof authToken === 'string') {\n      return authToken;\n    }\n\n    // 3. Query parameter\n    const queryToken = socket.handshake.query?.token;\n    if (queryToken && typeof queryToken === 'string') {\n      return queryToken;\n    }\n\n    // 4. Cookie (for browser connections)\n    const cookies = socket.handshake.headers.cookie;\n    if (cookies) {\n      const sessionCookie = this.extractCookieValue(cookies, '__session');\n      if (sessionCookie) {\n        return sessionCookie;\n      }\n    }\n\n    return null;\n  }\n\n  private extractCookieValue(cookies: string, name: string): string | null {\n    try {\n      // Escape special regex characters in cookie name\n      const escapedName = name.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n      const match = cookies.match(new RegExp(`(^| )${escapedName}=([^;]+)`));\n      if (match && match[2]) {\n        return decodeURIComponent(match[2]);\n      }\n      return null;\n    } catch (error) {\n      this.logger.warn(`Failed to extract cookie value for ${name}:`, error);\n      return null;\n    }\n  }\n\n  async refreshTokenIfNeeded(token: string): Promise<string | null> {\n    try {\n      // Check if token is close to expiry and refresh if needed\n      await verifyToken(token, {\n        secretKey: process.env.CLERK_SECRET_KEY ?? '',\n      });\n\n      // If token is valid, return as is\n      return token;\n    } catch (error) {\n      this.logger.warn('Token refresh failed:', error);\n      return null;\n    }\n  }\n}\n"],"version":3}