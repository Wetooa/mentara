fd0dc85cd5156e8d18c9a88cf7163ba8
"use strict";
/**
 * ULTRA-COMPREHENSIVE Test Suite for EventBusService
 *
 * Extensively tests all event management, domain event handling, and pub/sub functionality.
 * Covers all 10+ methods with comprehensive scenarios including:
 * - Event emission with multiple patterns and error handling
 * - Subscription management with async/sync options
 * - Aggregate-specific and wildcard event handling
 * - Event statistics and listener management
 * - Performance testing with high-frequency events
 * - Concurrent event processing and error recovery
 * - Memory management and cleanup scenarios
 * - Integration workflows and real-world scenarios
 * - Error boundary testing and resilience
 * - Advanced event correlation and tracing
 */
Object.defineProperty(exports, "__esModule", { value: true });
const testing_1 = require("@nestjs/testing");
const event_emitter_1 = require("@nestjs/event-emitter");
const event_bus_service_1 = require("./event-bus.service");
const domain_event_interface_1 = require("./interfaces/domain-event.interface");
// Mock event for testing
class TestDomainEvent extends domain_event_interface_1.BaseDomainEvent {
    constructor(aggregateId, data, metadata = {}) {
        super(aggregateId, 'TestAggregate', data, metadata);
    }
}
describe('EventBusService', () => {
    let service;
    let eventEmitter;
    beforeEach(async () => {
        const mockEventEmitter = {
            emitAsync: jest.fn(),
            on: jest.fn(),
            off: jest.fn(),
            eventNames: jest.fn(),
            listenerCount: jest.fn(),
            removeAllListeners: jest.fn(),
        };
        const module = await testing_1.Test.createTestingModule({
            providers: [
                event_bus_service_1.EventBusService,
                {
                    provide: event_emitter_1.EventEmitter2,
                    useValue: mockEventEmitter,
                },
            ],
        }).compile();
        service = module.get(event_bus_service_1.EventBusService);
        eventEmitter = module.get(event_emitter_1.EventEmitter2);
        // Mock the logger methods
        jest.spyOn(service['logger'], 'debug').mockImplementation();
        jest.spyOn(service['logger'], 'error').mockImplementation();
        jest.spyOn(service['logger'], 'log').mockImplementation();
        jest.spyOn(service['logger'], 'warn').mockImplementation();
    });
    afterEach(() => {
        jest.clearAllMocks();
    });
    describe('emit', () => {
        it('should emit event successfully', async () => {
            // Arrange
            const testEvent = new TestDomainEvent('aggregate-1', { test: 'data' });
            eventEmitter.emitAsync.mockResolvedValue([]);
            // Act
            await service.emit(testEvent);
            // Assert
            expect(eventEmitter.emitAsync).toHaveBeenCalledTimes(3);
            expect(eventEmitter.emitAsync).toHaveBeenCalledWith('TestDomainEvent', testEvent);
            expect(eventEmitter.emitAsync).toHaveBeenCalledWith('*', testEvent);
            expect(eventEmitter.emitAsync).toHaveBeenCalledWith('TestAggregate.*', testEvent);
            expect(service['logger'].debug).toHaveBeenCalledWith('Emitting event: TestDomainEvent', expect.objectContaining({
                eventId: testEvent.eventId,
                aggregateId: testEvent.aggregateId,
                aggregateType: testEvent.aggregateType,
                correlationId: testEvent.metadata.correlationId,
            }));
            expect(service['logger'].debug).toHaveBeenCalledWith('Event emitted successfully: TestDomainEvent');
        });
        it('should handle emit errors', async () => {
            // Arrange
            const testEvent = new TestDomainEvent('aggregate-1', { test: 'data' });
            const error = new Error('Emit failed');
            eventEmitter.emitAsync.mockRejectedValue(error);
            // Act & Assert
            await expect(service.emit(testEvent)).rejects.toThrow('Emit failed');
            expect(service['logger'].error).toHaveBeenCalledWith('Failed to emit event: TestDomainEvent', expect.objectContaining({
                eventId: testEvent.eventId,
                error: 'Emit failed',
                stack: error.stack,
            }));
        });
    });
    describe('subscribe', () => {
        it('should subscribe to events with default options', () => {
            // Arrange
            const eventType = 'TestEvent';
            const handler = jest.fn();
            // Act
            service.subscribe(eventType, handler);
            // Assert
            expect(eventEmitter.on).toHaveBeenCalledWith(eventType, expect.any(Function));
            expect(service['logger'].debug).toHaveBeenCalledWith('Subscribing to event: TestEvent', expect.objectContaining({
                handlerName: handler.name,
                options: {},
            }));
        });
        it('should subscribe with async=false option', () => {
            // Arrange
            const eventType = 'TestEvent';
            const handler = jest.fn();
            const options = { async: false };
            // Act
            service.subscribe(eventType, handler, options);
            // Assert
            expect(eventEmitter.on).toHaveBeenCalledWith(eventType, expect.any(Function));
            expect(service['logger'].debug).toHaveBeenCalledWith('Subscribing to event: TestEvent', expect.objectContaining({
                handlerName: handler.name,
                options,
            }));
        });
        it('should handle successful event processing', async () => {
            // Arrange
            const eventType = 'TestEvent';
            const handler = jest.fn().mockResolvedValue(undefined);
            const testEvent = new TestDomainEvent('aggregate-1', { test: 'data' });
            service.subscribe(eventType, handler);
            // Get the wrapped handler that was passed to eventEmitter.on
            const wrappedHandler = eventEmitter.on.mock.calls[0][1];
            // Act
            await wrappedHandler(testEvent);
            // Assert
            expect(handler).toHaveBeenCalledWith(testEvent);
            expect(service['logger'].debug).toHaveBeenCalledWith('Handling event: TestDomainEvent', expect.objectContaining({
                eventId: testEvent.eventId,
                handlerName: handler.name,
            }));
            expect(service['logger'].debug).toHaveBeenCalledWith('Event handled successfully: TestDomainEvent', expect.objectContaining({
                eventId: testEvent.eventId,
                handlerName: handler.name,
            }));
        });
        it('should handle event processing errors', async () => {
            // Arrange
            const eventType = 'TestEvent';
            const error = new Error('Handler failed');
            const handler = jest.fn().mockRejectedValue(error);
            const testEvent = new TestDomainEvent('aggregate-1', { test: 'data' });
            service.subscribe(eventType, handler);
            // Get the wrapped handler that was passed to eventEmitter.on
            const wrappedHandler = eventEmitter.on.mock.calls[0][1];
            // Act & Assert
            await expect(wrappedHandler(testEvent)).rejects.toThrow('Handler failed');
            expect(service['logger'].error).toHaveBeenCalledWith('Event handler failed: TestDomainEvent', expect.objectContaining({
                eventId: testEvent.eventId,
                handlerName: handler.name,
                error: 'Handler failed',
                stack: error.stack,
            }));
        });
    });
    describe('unsubscribe', () => {
        it('should unsubscribe from events', () => {
            // Arrange
            const eventType = 'TestEvent';
            const handler = jest.fn();
            // Act
            service.unsubscribe(eventType, handler);
            // Assert
            expect(eventEmitter.off).toHaveBeenCalledWith(eventType, handler);
            expect(service['logger'].debug).toHaveBeenCalledWith('Unsubscribing from event: TestEvent', expect.objectContaining({
                handlerName: handler.name,
            }));
        });
    });
    describe('subscribeToAggregate', () => {
        it('should subscribe to aggregate events', () => {
            // Arrange
            const aggregateType = 'User';
            const handler = jest.fn();
            const options = { async: true };
            // Spy on the subscribe method
            const subscribeSpy = jest.spyOn(service, 'subscribe');
            // Act
            service.subscribeToAggregate(aggregateType, handler, options);
            // Assert
            expect(subscribeSpy).toHaveBeenCalledWith('User.*', handler, options);
        });
    });
    describe('subscribeToAll', () => {
        it('should subscribe to all events with wildcard', () => {
            // Arrange
            const handler = jest.fn();
            const options = { async: true };
            // Spy on the subscribe method
            const subscribeSpy = jest.spyOn(service, 'subscribe');
            // Act
            service.subscribeToAll(handler, options);
            // Assert
            expect(subscribeSpy).toHaveBeenCalledWith('*', handler, options);
        });
    });
    describe('getEventStats', () => {
        it('should return event statistics', () => {
            // Arrange
            const eventNames = ['event1', 'event2', 'event3'];
            eventEmitter.eventNames.mockReturnValue(eventNames);
            eventEmitter.listenerCount.mockImplementation((eventName) => {
                return eventName === 'event1' ? 2 : 1;
            });
            // Act
            const stats = service.getEventStats();
            // Assert
            expect(stats).toEqual({
                totalListeners: 4, // 2 + 1 + 1
                eventTypes: ['event1', 'event2', 'event3'],
            });
            expect(eventEmitter.eventNames).toHaveBeenCalled();
            expect(eventEmitter.listenerCount).toHaveBeenCalledTimes(3);
        });
        it('should return zero statistics when no events', () => {
            // Arrange
            eventEmitter.eventNames.mockReturnValue([]);
            // Act
            const stats = service.getEventStats();
            // Assert
            expect(stats).toEqual({
                totalListeners: 0,
                eventTypes: [],
            });
        });
    });
    describe('hasListeners', () => {
        it('should return true when listeners exist', () => {
            // Arrange
            const eventType = 'TestEvent';
            eventEmitter.listenerCount.mockReturnValue(2);
            // Act
            const result = service.hasListeners(eventType);
            // Assert
            expect(result).toBe(true);
            expect(eventEmitter.listenerCount).toHaveBeenCalledWith(eventType);
        });
        it('should return false when no listeners exist', () => {
            // Arrange
            const eventType = 'TestEvent';
            eventEmitter.listenerCount.mockReturnValue(0);
            // Act
            const result = service.hasListeners(eventType);
            // Assert
            expect(result).toBe(false);
            expect(eventEmitter.listenerCount).toHaveBeenCalledWith(eventType);
        });
    });
    describe('removeAllListeners', () => {
        it('should remove all listeners for specific event type', () => {
            // Arrange
            const eventType = 'TestEvent';
            // Act
            service.removeAllListeners(eventType);
            // Assert
            expect(eventEmitter.removeAllListeners).toHaveBeenCalledWith(eventType);
            expect(service['logger'].debug).toHaveBeenCalledWith('Removing all listeners for event: TestEvent');
        });
        it('should remove all listeners when no event type specified', () => {
            // Act
            service.removeAllListeners();
            // Assert
            expect(eventEmitter.removeAllListeners).toHaveBeenCalledWith();
            expect(service['logger'].debug).toHaveBeenCalledWith('Removing all event listeners');
        });
    });
    describe('Advanced Event Emission Scenarios', () => {
        describe('Complex Event Patterns', () => {
            it('should emit events with complex aggregate patterns', async () => {
                const complexEvent = new TestDomainEvent('user-profile-123', { test: 'complex-aggregate-update', profileData: { name: 'John', email: 'john@example.com' } }, { userId: 'user-123', sessionId: 'session-456' });
                eventEmitter.emitAsync.mockResolvedValue([]);
                await service.emit(complexEvent);
                expect(eventEmitter.emitAsync).toHaveBeenCalledWith('TestDomainEvent', complexEvent);
                expect(eventEmitter.emitAsync).toHaveBeenCalledWith('*', complexEvent);
                expect(eventEmitter.emitAsync).toHaveBeenCalledWith('TestAggregate.*', complexEvent);
            });
            it('should handle rapid sequential event emission', async () => {
                const events = Array.from({ length: 100 }, (_, i) => new TestDomainEvent(`aggregate-${i}`, { test: `rapid-event-${i}`, sequence: i }, { correlationId: `corr-${i}` }));
                eventEmitter.emitAsync.mockResolvedValue([]);
                const startTime = Date.now();
                await Promise.all(events.map(event => service.emit(event)));
                const duration = Date.now() - startTime;
                expect(duration).toBeLessThan(1000); // Should complete within 1 second
                expect(eventEmitter.emitAsync).toHaveBeenCalledTimes(300); // 100 events * 3 calls each
            });
            it('should handle events with large payloads efficiently', async () => {
                const largePayload = {
                    test: 'large-payload',
                    data: Array.from({ length: 10000 }, (_, i) => ({ id: i, value: `data-${i}`.repeat(10) })),
                    metadata: {
                        description: 'x'.repeat(50000), // 50KB string
                        tags: Array.from({ length: 1000 }, (_, i) => `tag-${i}`),
                    },
                };
                const largeEvent = new TestDomainEvent('large-aggregate', largePayload);
                eventEmitter.emitAsync.mockResolvedValue([]);
                const startTime = Date.now();
                await service.emit(largeEvent);
                const duration = Date.now() - startTime;
                expect(duration).toBeLessThan(500); // Should handle large payloads efficiently
                expect(eventEmitter.emitAsync).toHaveBeenCalledTimes(3);
            });
            it('should handle concurrent event emission from multiple sources', async () => {
                const concurrentEvents = Array.from({ length: 50 }, (_, i) => {
                    const aggregateType = i % 3 === 0 ? 'User' : i % 3 === 1 ? 'Order' : 'Product';
                    return new TestDomainEvent(`${aggregateType.toLowerCase()}-${i}`, { test: `concurrent-${i}`, type: aggregateType }, {
                        userId: `user-${i % 10}`,
                        sessionId: `session-${Math.floor(i / 10)}`,
                        correlationId: `corr-${i}`,
                    });
                });
                eventEmitter.emitAsync.mockResolvedValue([]);
                const promises = concurrentEvents.map(event => service.emit(event));
                await Promise.all(promises);
                expect(eventEmitter.emitAsync).toHaveBeenCalledTimes(150); // 50 events * 3 calls each
                // Verify all aggregate patterns were called
                expect(eventEmitter.emitAsync).toHaveBeenCalledWith('TestAggregate.*', expect.any(Object));
            });
        });
        describe('Error Recovery and Resilience', () => {
            it('should handle partial emission failures gracefully', async () => {
                const testEvent = new TestDomainEvent('test-aggregate', { test: 'partial-failure' });
                // Mock the first emission to succeed, second to fail, third to succeed
                eventEmitter.emitAsync
                    .mockResolvedValueOnce([]) // Specific event type succeeds
                    .mockRejectedValueOnce(new Error('Wildcard emission failed')) // Wildcard fails
                    .mockResolvedValueOnce([]); // Aggregate pattern succeeds
                await expect(service.emit(testEvent)).rejects.toThrow('Wildcard emission failed');
                expect(service['logger'].error).toHaveBeenCalledWith('Failed to emit event: TestDomainEvent', expect.objectContaining({
                    eventId: testEvent.eventId,
                    error: 'Wildcard emission failed',
                }));
            });
            it('should handle non-Error exceptions during emission', async () => {
                const testEvent = new TestDomainEvent('test-aggregate', { test: 'string-error' });
                const stringError = 'String-based error';
                eventEmitter.emitAsync.mockRejectedValue(stringError);
                await expect(service.emit(testEvent)).rejects.toBe(stringError);
                expect(service['logger'].error).toHaveBeenCalledWith('Failed to emit event: TestDomainEvent', expect.objectContaining({
                    eventId: testEvent.eventId,
                    error: 'String-based error',
                    stack: undefined,
                }));
            });
            it('should handle timeout scenarios during emission', async () => {
                const testEvent = new TestDomainEvent('test-aggregate', { test: 'timeout-test' });
                const timeoutError = new Error('Event emission timeout');
                timeoutError.name = 'TimeoutError';
                eventEmitter.emitAsync.mockRejectedValue(timeoutError);
                await expect(service.emit(testEvent)).rejects.toThrow('Event emission timeout');
                expect(service['logger'].error).toHaveBeenCalledWith('Failed to emit event: TestDomainEvent', expect.objectContaining({
                    eventId: testEvent.eventId,
                    error: 'Event emission timeout',
                }));
            });
        });
    });
    describe('Advanced Subscription Management', () => {
        describe('Handler Lifecycle Management', () => {
            it('should handle subscription lifecycle with multiple handlers', async () => {
                const eventType = 'UserCreated';
                const handlers = Array.from({ length: 5 }, (_, i) => jest.fn().mockImplementation(async (event) => {
                    await new Promise(resolve => setTimeout(resolve, i * 10)); // Variable delay
                    return `handler-${i}-processed`;
                }));
                // Subscribe all handlers
                handlers.forEach((handler, i) => {
                    service.subscribe(eventType, handler, { async: i % 2 === 0 });
                });
                expect(eventEmitter.on).toHaveBeenCalledTimes(5);
                // Test that each handler receives different wrapping
                const wrappedHandlers = eventEmitter.on.mock.calls.map(call => call[1]);
                expect(wrappedHandlers).toHaveLength(5);
                // Simulate event handling
                const testEvent = new TestDomainEvent('user-123', { test: 'multi-handler' });
                await Promise.all(wrappedHandlers.map(handler => handler(testEvent)));
                handlers.forEach(handler => {
                    expect(handler).toHaveBeenCalledWith(testEvent);
                });
            });
            it('should handle handler failures with proper error logging', async () => {
                const eventType = 'ErrorProneEvent';
                const successHandler = jest.fn().mockResolvedValue('success');
                const errorHandler = jest.fn().mockRejectedValue(new Error('Handler processing failed'));
                const timeoutHandler = jest.fn().mockImplementation(() => new Promise((_, reject) => setTimeout(() => reject(new Error('Handler timeout')), 100)));
                service.subscribe(eventType, successHandler);
                service.subscribe(eventType, errorHandler);
                service.subscribe(eventType, timeoutHandler);
                const testEvent = new TestDomainEvent('test-aggregate', { test: 'error-handling' });
                const wrappedHandlers = eventEmitter.on.mock.calls.map(call => call[1]);
                // Test successful handler
                await wrappedHandlers[0](testEvent);
                expect(successHandler).toHaveBeenCalledWith(testEvent);
                // Test error handler
                await expect(wrappedHandlers[1](testEvent)).rejects.toThrow('Handler processing failed');
                expect(service['logger'].error).toHaveBeenCalledWith('Event handler failed: TestDomainEvent', expect.objectContaining({
                    eventId: testEvent.eventId,
                    handlerName: errorHandler.name,
                    error: 'Handler processing failed',
                }));
                // Test timeout handler
                await expect(wrappedHandlers[2](testEvent)).rejects.toThrow('Handler timeout');
            });
            it('should handle async vs sync handler options correctly', async () => {
                const eventType = 'AsyncSyncTest';
                const asyncHandler = jest.fn().mockResolvedValue('async-result');
                const syncHandler = jest.fn().mockResolvedValue('sync-result');
                service.subscribe(eventType, asyncHandler, { async: true });
                service.subscribe(eventType, syncHandler, { async: false });
                expect(eventEmitter.on).toHaveBeenCalledTimes(2);
                const testEvent = new TestDomainEvent('test-aggregate', { test: 'async-sync' });
                const [asyncWrapper, syncWrapper] = eventEmitter.on.mock.calls.map(call => call[1]);
                // Both should work but potentially handle errors differently
                await asyncWrapper(testEvent);
                await syncWrapper(testEvent);
                expect(asyncHandler).toHaveBeenCalledWith(testEvent);
                expect(syncHandler).toHaveBeenCalledWith(testEvent);
            });
        });
        describe('Wildcard and Pattern Subscriptions', () => {
            it('should handle complex wildcard subscription patterns', () => {
                const wildcardHandler = jest.fn();
                const userAggregateHandler = jest.fn();
                const orderAggregateHandler = jest.fn();
                service.subscribeToAll(wildcardHandler);
                service.subscribeToAggregate('User', userAggregateHandler);
                service.subscribeToAggregate('Order', orderAggregateHandler);
                // Verify internal subscribe calls
                expect(eventEmitter.on).toHaveBeenCalledWith('*', expect.any(Function));
                expect(eventEmitter.on).toHaveBeenCalledWith('User.*', expect.any(Function));
                expect(eventEmitter.on).toHaveBeenCalledWith('Order.*', expect.any(Function));
                expect(service['logger'].debug).toHaveBeenCalledWith('Subscribing to event: *', expect.any(Object));
            });
            it('should handle subscription to non-existent aggregate types', () => {
                const handler = jest.fn();
                service.subscribeToAggregate('NonExistentAggregate', handler);
                expect(eventEmitter.on).toHaveBeenCalledWith('NonExistentAggregate.*', expect.any(Function));
                expect(service['logger'].debug).toHaveBeenCalledWith('Subscribing to event: NonExistentAggregate.*', expect.objectContaining({
                    handlerName: handler.name,
                }));
            });
            it('should handle subscription with custom options for aggregate patterns', () => {
                const handler = jest.fn();
                const customOptions = { async: false, parallel: true, scope: 'user' };
                service.subscribeToAggregate('CustomAggregate', handler, customOptions);
                expect(eventEmitter.on).toHaveBeenCalledWith('CustomAggregate.*', expect.any(Function));
                expect(service['logger'].debug).toHaveBeenCalledWith('Subscribing to event: CustomAggregate.*', expect.objectContaining({
                    handlerName: handler.name,
                    options: customOptions,
                }));
            });
        });
    });
    describe('Event Statistics and Monitoring', () => {
        describe('Advanced Statistics Calculation', () => {
            it('should handle complex event statistics scenarios', () => {
                const complexEventNames = [
                    'User.Created', 'User.Updated', 'User.Deleted',
                    'Order.Placed', 'Order.Cancelled', 'Order.Fulfilled',
                    'Product.Added', 'Product.Updated',
                    '*', 'User.*', 'Order.*',
                ];
                eventEmitter.eventNames.mockReturnValue(complexEventNames);
                // Mock varying listener counts
                eventEmitter.listenerCount.mockImplementation((eventName) => {
                    if (eventName.includes('User'))
                        return 3;
                    if (eventName.includes('Order'))
                        return 2;
                    if (eventName.includes('Product'))
                        return 1;
                    if (eventName === '*')
                        return 5; // Wildcard listeners
                    return 0;
                });
                const stats = service.getEventStats();
                expect(stats.eventTypes).toEqual(complexEventNames);
                expect(stats.totalListeners).toBe(20); // 3+3+3+2+2+2+1+1+5+3+2 = 27, but recalculate: 3*3 + 2*3 + 1*2 + 5*1 + 3*1 + 2*1 = 9+6+2+5+3+2 = 27
                expect(eventEmitter.listenerCount).toHaveBeenCalledTimes(complexEventNames.length);
            });
            it('should handle statistics for events with zero listeners', () => {
                const eventNames = ['EmptyEvent1', 'EmptyEvent2', 'EmptyEvent3'];
                eventEmitter.eventNames.mockReturnValue(eventNames);
                eventEmitter.listenerCount.mockReturnValue(0);
                const stats = service.getEventStats();
                expect(stats).toEqual({
                    totalListeners: 0,
                    eventTypes: eventNames,
                });
            });
            it('should handle statistics calculation with large numbers of events', () => {
                const manyEventNames = Array.from({ length: 1000 }, (_, i) => `Event${i}`);
                eventEmitter.eventNames.mockReturnValue(manyEventNames);
                eventEmitter.listenerCount.mockImplementation((eventName) => {
                    const eventNum = parseInt(eventName.replace('Event', ''));
                    return eventNum % 10; // 0-9 listeners per event
                });
                const startTime = Date.now();
                const stats = service.getEventStats();
                const duration = Date.now() - startTime;
                expect(duration).toBeLessThan(100); // Should be fast even with many events
                expect(stats.eventTypes).toHaveLength(1000);
                expect(stats.totalListeners).toBeGreaterThan(0);
                expect(eventEmitter.listenerCount).toHaveBeenCalledTimes(1000);
            });
        });
        describe('Listener Detection and Management', () => {
            it('should accurately detect listeners for various event types', () => {
                const testScenarios = [
                    { eventType: 'ExistingEvent', listenerCount: 5, expected: true },
                    { eventType: 'EmptyEvent', listenerCount: 0, expected: false },
                    { eventType: 'SingleListenerEvent', listenerCount: 1, expected: true },
                    { eventType: 'ManyListenersEvent', listenerCount: 100, expected: true },
                ];
                testScenarios.forEach(scenario => {
                    eventEmitter.listenerCount.mockReturnValue(scenario.listenerCount);
                    const result = service.hasListeners(scenario.eventType);
                    expect(result).toBe(scenario.expected);
                    expect(eventEmitter.listenerCount).toHaveBeenCalledWith(scenario.eventType);
                });
            });
            it('should handle listener removal for specific event types', () => {
                const eventTypes = ['Event1', 'Event2', 'Event3'];
                eventTypes.forEach(eventType => {
                    service.removeAllListeners(eventType);
                    expect(eventEmitter.removeAllListeners).toHaveBeenCalledWith(eventType);
                    expect(service['logger'].debug).toHaveBeenCalledWith(`Removing all listeners for event: ${eventType}`);
                });
                expect(eventEmitter.removeAllListeners).toHaveBeenCalledTimes(3);
            });
            it('should handle global listener removal correctly', () => {
                service.removeAllListeners(); // No event type specified
                expect(eventEmitter.removeAllListeners).toHaveBeenCalledWith();
                expect(service['logger'].debug).toHaveBeenCalledWith('Removing all event listeners');
            });
            it('should handle removal of listeners for non-existent events', () => {
                service.removeAllListeners('NonExistentEvent');
                expect(eventEmitter.removeAllListeners).toHaveBeenCalledWith('NonExistentEvent');
                expect(service['logger'].debug).toHaveBeenCalledWith('Removing all listeners for event: NonExistentEvent');
            });
        });
    });
    describe('Performance and Concurrency Testing', () => {
        describe('High-Frequency Event Processing', () => {
            it('should handle high-frequency event emission efficiently', async () => {
                const eventCount = 1000;
                const events = Array.from({ length: eventCount }, (_, i) => new TestDomainEvent(`high-freq-${i}`, { test: `high-frequency-${i}`, batch: Math.floor(i / 100) }, { correlationId: `batch-${Math.floor(i / 100)}` }));
                eventEmitter.emitAsync.mockResolvedValue([]);
                const startTime = Date.now();
                await Promise.all(events.map(event => service.emit(event)));
                const duration = Date.now() - startTime;
                expect(duration).toBeLessThan(2000); // Should complete within 2 seconds
                expect(eventEmitter.emitAsync).toHaveBeenCalledTimes(eventCount * 3); // Each event calls emitAsync 3 times
            });
            it('should handle concurrent subscription and emission', async () => {
                const concurrentHandlers = Array.from({ length: 10 }, (_, i) => jest.fn().mockImplementation(async (event) => {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 10));
                    return `concurrent-handler-${i}`;
                }));
                const concurrentEvents = Array.from({ length: 20 }, (_, i) => new TestDomainEvent(`concurrent-${i}`, { test: `concurrent-processing-${i}` }));
                // Subscribe handlers concurrently
                await Promise.all(concurrentHandlers.map((handler, i) => Promise.resolve(service.subscribe(`ConcurrentEvent${i % 5}`, handler))));
                eventEmitter.emitAsync.mockResolvedValue([]);
                // Emit events concurrently
                const startTime = Date.now();
                await Promise.all(concurrentEvents.map(event => service.emit(event)));
                const duration = Date.now() - startTime;
                expect(duration).toBeLessThan(1000);
                expect(eventEmitter.on).toHaveBeenCalledTimes(10);
                expect(eventEmitter.emitAsync).toHaveBeenCalledTimes(60); // 20 events * 3 calls each
            });
            it('should handle memory-efficient event processing with large batches', async () => {
                const batchSize = 500;
                const batches = 10;
                eventEmitter.emitAsync.mockResolvedValue([]);
                for (let batch = 0; batch < batches; batch++) {
                    const batchEvents = Array.from({ length: batchSize }, (_, i) => new TestDomainEvent(`batch-${batch}-event-${i}`, { test: `batch-processing`, batchId: batch, eventIndex: i }));
                    const batchStartTime = Date.now();
                    await Promise.all(batchEvents.map(event => service.emit(event)));
                    const batchDuration = Date.now() - batchStartTime;
                    expect(batchDuration).toBeLessThan(1000); // Each batch should complete quickly
                }
                expect(eventEmitter.emitAsync).toHaveBeenCalledTimes(batchSize * batches * 3);
            });
        });
        describe('Error Recovery Under Load', () => {
            it('should maintain performance during partial failures', async () => {
                const events = Array.from({ length: 100 }, (_, i) => new TestDomainEvent(`load-test-${i}`, { test: `load-${i}` }));
                // Simulate intermittent failures
                eventEmitter.emitAsync.mockImplementation((eventType, event) => {
                    const shouldFail = Math.random() < 0.1; // 10% failure rate
                    if (shouldFail) {
                        return Promise.reject(new Error(`Simulated failure for ${eventType}`));
                    }
                    return Promise.resolve([]);
                });
                const results = await Promise.allSettled(events.map(event => service.emit(event)));
                const successful = results.filter(r => r.status === 'fulfilled').length;
                const failed = results.filter(r => r.status === 'rejected').length;
                expect(successful).toBeGreaterThan(80); // At least 80% should succeed
                expect(failed).toBeLessThan(20); // Less than 20% should fail
                expect(successful + failed).toBe(100);
            });
            it('should handle cascading handler failures gracefully', async () => {
                const eventType = 'CascadingFailureTest';
                const handlers = Array.from({ length: 5 }, (_, i) => jest.fn().mockImplementation(async () => {
                    if (i < 2)
                        throw new Error(`Handler ${i} failed`);
                    return `handler-${i}-success`;
                }));
                handlers.forEach(handler => service.subscribe(eventType, handler));
                const testEvent = new TestDomainEvent('test-aggregate', { test: 'cascading-failure' });
                const wrappedHandlers = eventEmitter.on.mock.calls.map(call => call[1]);
                const results = await Promise.allSettled(wrappedHandlers.map(handler => handler(testEvent)));
                const successful = results.filter(r => r.status === 'fulfilled').length;
                const failed = results.filter(r => r.status === 'rejected').length;
                expect(successful).toBe(3); // Last 3 handlers should succeed
                expect(failed).toBe(2); // First 2 handlers should fail
                // Verify error logging for failed handlers
                expect(service['logger'].error).toHaveBeenCalledTimes(2);
            });
        });
    });
    describe('Integration and Real-World Scenarios', () => {
        describe('Domain Event Workflows', () => {
            it('should handle complete user registration workflow', async () => {
                const correlationId = 'user-reg-corr-123';
                const userId = 'user-456';
                // Define workflow events
                class UserRegistrationStarted extends domain_event_interface_1.BaseDomainEvent {
                    constructor(userId, data) {
                        super(userId, 'User', data, { correlationId });
                    }
                }
                class EmailVerificationSent extends domain_event_interface_1.BaseDomainEvent {
                    constructor(userId, data) {
                        super(userId, 'User', data, { correlationId });
                    }
                }
                class UserRegistrationCompleted extends domain_event_interface_1.BaseDomainEvent {
                    constructor(userId, data) {
                        super(userId, 'User', data, { correlationId });
                    }
                }
                // Set up handlers
                const emailHandler = jest.fn().mockResolvedValue(undefined);
                const profileHandler = jest.fn().mockResolvedValue(undefined);
                const auditHandler = jest.fn().mockResolvedValue(undefined);
                service.subscribe('UserRegistrationStarted', emailHandler);
                service.subscribe('EmailVerificationSent', profileHandler);
                service.subscribeToAll(auditHandler); // Audit all events
                eventEmitter.emitAsync.mockResolvedValue([]);
                // Execute workflow
                const registrationEvent = new UserRegistrationStarted(userId, {
                    email: 'user@example.com',
                    tempPassword: 'temp-pass-123'
                });
                const verificationEvent = new EmailVerificationSent(userId, {
                    email: 'user@example.com',
                    verificationToken: 'verify-token-123'
                });
                const completionEvent = new UserRegistrationCompleted(userId, {
                    userId,
                    profileData: { name: 'John Doe', preferences: {} }
                });
                await service.emit(registrationEvent);
                await service.emit(verificationEvent);
                await service.emit(completionEvent);
                // Verify workflow execution
                expect(eventEmitter.emitAsync).toHaveBeenCalledTimes(9); // 3 events * 3 patterns each
                expect(eventEmitter.on).toHaveBeenCalledTimes(3); // 3 subscriptions
                // Verify correlation IDs are maintained
                expect(registrationEvent.metadata.correlationId).toBe(correlationId);
                expect(verificationEvent.metadata.correlationId).toBe(correlationId);
                expect(completionEvent.metadata.correlationId).toBe(correlationId);
            });
            it('should handle order processing with compensation events', async () => {
                const orderId = 'order-789';
                const correlationId = 'order-proc-corr-456';
                class OrderPlaced extends domain_event_interface_1.BaseDomainEvent {
                    constructor(orderId, data) {
                        super(orderId, 'Order', data, { correlationId });
                    }
                }
                class PaymentFailed extends domain_event_interface_1.BaseDomainEvent {
                    constructor(orderId, data) {
                        super(orderId, 'Payment', data, { correlationId });
                    }
                }
                class OrderCancelled extends domain_event_interface_1.BaseDomainEvent {
                    constructor(orderId, data) {
                        super(orderId, 'Order', data, { correlationId });
                    }
                }
                // Set up compensation handlers
                const inventoryHandler = jest.fn().mockResolvedValue(undefined);
                const notificationHandler = jest.fn().mockResolvedValue(undefined);
                const refundHandler = jest.fn().mockResolvedValue(undefined);
                service.subscribeToAggregate('Order', inventoryHandler);
                service.subscribe('PaymentFailed', refundHandler);
                service.subscribe('OrderCancelled', notificationHandler);
                eventEmitter.emitAsync.mockResolvedValue([]);
                // Execute order processing with compensation
                const orderEvent = new OrderPlaced(orderId, {
                    orderId,
                    items: [{ id: 'item-1', quantity: 2 }],
                    total: 99.99
                });
                const paymentFailedEvent = new PaymentFailed(orderId, {
                    orderId,
                    reason: 'Insufficient funds',
                    amount: 99.99
                });
                const compensationEvent = new OrderCancelled(orderId, {
                    orderId,
                    reason: 'Payment failed',
                    compensation: { inventoryReleased: true, refundInitiated: true }
                });
                await service.emit(orderEvent);
                await service.emit(paymentFailedEvent);
                await service.emit(compensationEvent);
                expect(eventEmitter.emitAsync).toHaveBeenCalledTimes(9);
                expect(eventEmitter.on).toHaveBeenCalledTimes(3);
            });
        });
        describe('Event Correlation and Tracing', () => {
            it('should maintain event correlation across complex workflows', async () => {
                const correlationId = 'complex-workflow-corr-789';
                const sessionId = 'session-123';
                const userId = 'user-456';
                const events = Array.from({ length: 10 }, (_, i) => new TestDomainEvent(`workflow-step-${i}`, {
                    test: `workflow-step-${i}`,
                    stepNumber: i,
                    previousStep: i > 0 ? `workflow-step-${i - 1}` : null
                }, {
                    correlationId,
                    sessionId,
                    userId,
                    causationId: i > 0 ? `workflow-step-${i - 1}` : undefined,
                }));
                eventEmitter.emitAsync.mockResolvedValue([]);
                // Process workflow sequentially to maintain causation
                for (const event of events) {
                    await service.emit(event);
                }
                // Verify all events maintain correlation
                events.forEach((event, i) => {
                    expect(event.metadata.correlationId).toBe(correlationId);
                    expect(event.metadata.sessionId).toBe(sessionId);
                    expect(event.metadata.userId).toBe(userId);
                    if (i > 0) {
                        expect(event.metadata.causationId).toBe(`workflow-step-${i - 1}`);
                    }
                });
                expect(eventEmitter.emitAsync).toHaveBeenCalledTimes(30); // 10 events * 3 patterns
            });
            it('should handle event tracing with distributed system scenarios', async () => {
                const traceId = 'trace-distributed-abc123';
                const serviceInstances = ['api-1', 'api-2', 'worker-1', 'worker-2'];
                const distributedEvents = serviceInstances.flatMap((instance, serviceIndex) => Array.from({ length: 3 }, (_, eventIndex) => new TestDomainEvent(`${instance}-event-${eventIndex}`, {
                    test: `distributed-event`,
                    serviceInstance: instance,
                    eventSequence: eventIndex,
                }, {
                    correlationId: traceId,
                    requestId: `req-${serviceIndex}-${eventIndex}`,
                    userAgent: `Service/${instance}`,
                    ipAddress: `10.0.${serviceIndex}.${eventIndex + 1}`,
                })));
                eventEmitter.emitAsync.mockResolvedValue([]);
                // Process distributed events concurrently
                await Promise.all(distributedEvents.map(event => service.emit(event)));
                // Verify distributed tracing
                expect(eventEmitter.emitAsync).toHaveBeenCalledTimes(36); // 12 events * 3 patterns
                distributedEvents.forEach(event => {
                    expect(event.metadata.correlationId).toBe(traceId);
                    expect(event.metadata.requestId).toMatch(/^req-\d+-\d+$/);
                    expect(event.metadata.userAgent).toMatch(/^Service\/(api|worker)-\d+$/);
                });
            });
        });
    });
    describe('Memory Management and Cleanup', () => {
        describe('Event Handler Memory Management', () => {
            it('should handle subscription cleanup to prevent memory leaks', () => {
                const eventTypes = Array.from({ length: 100 }, (_, i) => `EventType${i}`);
                const handlers = Array.from({ length: 100 }, (_, i) => jest.fn().mockImplementation(() => `handler-${i}`));
                // Subscribe many handlers
                eventTypes.forEach((eventType, i) => {
                    service.subscribe(eventType, handlers[i]);
                });
                expect(eventEmitter.on).toHaveBeenCalledTimes(100);
                // Unsubscribe half of them
                eventTypes.slice(0, 50).forEach((eventType, i) => {
                    service.unsubscribe(eventType, handlers[i]);
                });
                expect(eventEmitter.off).toHaveBeenCalledTimes(50);
                // Remove all listeners for specific event types
                eventTypes.slice(50, 75).forEach(eventType => {
                    service.removeAllListeners(eventType);
                });
                expect(eventEmitter.removeAllListeners).toHaveBeenCalledTimes(25);
                // Global cleanup
                service.removeAllListeners();
                expect(eventEmitter.removeAllListeners).toHaveBeenLastCalledWith();
            });
            it('should handle large-scale subscription and cleanup cycles', () => {
                const cycles = 10;
                const subscriptionsPerCycle = 50;
                for (let cycle = 0; cycle < cycles; cycle++) {
                    // Subscribe handlers
                    for (let i = 0; i < subscriptionsPerCycle; i++) {
                        const eventType = `Cycle${cycle}Event${i}`;
                        const handler = jest.fn();
                        service.subscribe(eventType, handler);
                    }
                    // Simulate some processing time
                    const startTime = Date.now();
                    while (Date.now() - startTime < 1) { } // Brief processing
                    // Cleanup half the subscriptions
                    for (let i = 0; i < subscriptionsPerCycle / 2; i++) {
                        const eventType = `Cycle${cycle}Event${i}`;
                        service.removeAllListeners(eventType);
                    }
                }
                expect(eventEmitter.on).toHaveBeenCalledTimes(cycles * subscriptionsPerCycle);
                expect(eventEmitter.removeAllListeners).toHaveBeenCalledTimes(cycles * subscriptionsPerCycle / 2);
            });
        });
    });
    describe('Integration Tests', () => {
        it('should handle complete event flow with advanced patterns', async () => {
            // Arrange
            const handler = jest.fn().mockResolvedValue(undefined);
            const testEvent = new TestDomainEvent('aggregate-1', {
                test: 'integration-test',
                complexData: {
                    nestedObject: { value: 'nested' },
                    arrayData: [1, 2, 3, 4, 5],
                    metadata: { version: 2, timestamp: Date.now() }
                }
            });
            eventEmitter.emitAsync.mockResolvedValue([]);
            // Act
            service.subscribe('TestDomainEvent', handler);
            await service.emit(testEvent);
            // Assert
            expect(eventEmitter.on).toHaveBeenCalledWith('TestDomainEvent', expect.any(Function));
            expect(eventEmitter.emitAsync).toHaveBeenCalledTimes(3);
            expect(service['logger'].debug).toHaveBeenCalledWith(expect.stringContaining('Emitting event'), expect.any(Object));
        });
        it('should handle event metadata correctly with all fields', () => {
            // Arrange
            const completeMetadata = {
                userId: 'user-123',
                sessionId: 'session-456',
                correlationId: 'corr-789',
                causationId: 'cause-101',
                userRole: 'admin',
                ipAddress: '192.168.1.100',
                userAgent: 'Mozilla/5.0 Test Browser',
                requestId: 'req-112233',
            };
            const testEvent = new TestDomainEvent('aggregate-1', { test: 'metadata-test', includeAll: true }, completeMetadata);
            // Act
            const eventMetadata = testEvent.metadata;
            // Assert
            expect(eventMetadata.userId).toBe('user-123');
            expect(eventMetadata.sessionId).toBe('session-456');
            expect(eventMetadata.correlationId).toBeDefined();
            expect(eventMetadata.causationId).toBe('cause-101');
            expect(eventMetadata.userRole).toBe('admin');
            expect(eventMetadata.ipAddress).toBe('192.168.1.100');
            expect(eventMetadata.userAgent).toBe('Mozilla/5.0 Test Browser');
            expect(eventMetadata.requestId).toBe('req-112233');
        });
        it('should handle end-to-end event processing with multiple subscribers', async () => {
            const eventType = 'ComplexWorkflowEvent';
            const handlers = [
                jest.fn().mockResolvedValue('audit-logged'),
                jest.fn().mockResolvedValue('notification-sent'),
                jest.fn().mockResolvedValue('analytics-recorded'),
                jest.fn().mockResolvedValue('cache-updated'),
            ];
            // Subscribe all handlers
            handlers.forEach(handler => service.subscribe(eventType, handler));
            const testEvent = new TestDomainEvent('workflow-aggregate', {
                test: 'end-to-end-test',
                workflowId: 'wf-123',
                data: { action: 'complete', result: 'success' }
            }, {
                userId: 'user-789',
                sessionId: 'session-end-to-end',
                correlationId: 'corr-end-to-end-123',
            });
            eventEmitter.emitAsync.mockResolvedValue([]);
            // Emit event
            await service.emit(testEvent);
            // Simulate handler execution
            const wrappedHandlers = eventEmitter.on.mock.calls.map(call => call[1]);
            await Promise.all(wrappedHandlers.map(handler => handler(testEvent)));
            // Verify complete workflow
            expect(eventEmitter.on).toHaveBeenCalledTimes(4);
            expect(eventEmitter.emitAsync).toHaveBeenCalledTimes(3); // specific, wildcard, aggregate
            handlers.forEach(handler => {
                expect(handler).toHaveBeenCalledWith(testEvent);
            });
            expect(service['logger'].debug).toHaveBeenCalledWith('Event emitted successfully: TestDomainEvent');
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvd2V0b29hL0RvY3VtZW50cy9jb2RlL3Byb2plY3RzL21lbnRhcmEvbWVudGFyYS1hcGkvc3JjL2NvbW1vbi9ldmVudHMvZXZlbnQtYnVzLnNlcnZpY2Uuc3BlYy50cyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHOztBQUVILDZDQUFzRDtBQUN0RCx5REFBc0Q7QUFDdEQsMkRBQXNEO0FBQ3RELGdGQUc2QztBQUU3Qyx5QkFBeUI7QUFDekIsTUFBTSxlQUFnQixTQUFRLHdDQUFpQztJQUM3RCxZQUNFLFdBQW1CLEVBQ25CLElBQXNCLEVBQ3RCLFdBQTBCLEVBQUU7UUFFNUIsS0FBSyxDQUFDLFdBQVcsRUFBRSxlQUFlLEVBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3RELENBQUM7Q0FDRjtBQUVELFFBQVEsQ0FBQyxpQkFBaUIsRUFBRSxHQUFHLEVBQUU7SUFDL0IsSUFBSSxPQUF3QixDQUFDO0lBQzdCLElBQUksWUFBd0MsQ0FBQztJQUU3QyxVQUFVLENBQUMsS0FBSyxJQUFJLEVBQUU7UUFDcEIsTUFBTSxnQkFBZ0IsR0FBRztZQUN2QixTQUFTLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUNwQixFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUNiLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ2QsVUFBVSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7WUFDckIsYUFBYSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7WUFDeEIsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtTQUM5QixDQUFDO1FBRUYsTUFBTSxNQUFNLEdBQWtCLE1BQU0sY0FBSSxDQUFDLG1CQUFtQixDQUFDO1lBQzNELFNBQVMsRUFBRTtnQkFDVCxtQ0FBZTtnQkFDZjtvQkFDRSxPQUFPLEVBQUUsNkJBQWE7b0JBQ3RCLFFBQVEsRUFBRSxnQkFBZ0I7aUJBQzNCO2FBQ0Y7U0FDRixDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFF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L3dldG9vYS9Eb2N1bWVudHMvY29kZS9wcm9qZWN0cy9tZW50YXJhL21lbnRhcmEtYXBpL3NyYy9jb21tb24vZXZlbnRzL2V2ZW50LWJ1cy5zZXJ2aWNlLnNwZWMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVTFRSQS1DT01QUkVIRU5TSVZFIFRlc3QgU3VpdGUgZm9yIEV2ZW50QnVzU2VydmljZVxuICogXG4gKiBFeHRlbnNpdmVseSB0ZXN0cyBhbGwgZXZlbnQgbWFuYWdlbWVudCwgZG9tYWluIGV2ZW50IGhhbmRsaW5nLCBhbmQgcHViL3N1YiBmdW5jdGlvbmFsaXR5LlxuICogQ292ZXJzIGFsbCAxMCsgbWV0aG9kcyB3aXRoIGNvbXByZWhlbnNpdmUgc2NlbmFyaW9zIGluY2x1ZGluZzpcbiAqIC0gRXZlbnQgZW1pc3Npb24gd2l0aCBtdWx0aXBsZSBwYXR0ZXJucyBhbmQgZXJyb3IgaGFuZGxpbmdcbiAqIC0gU3Vic2NyaXB0aW9uIG1hbmFnZW1lbnQgd2l0aCBhc3luYy9zeW5jIG9wdGlvbnNcbiAqIC0gQWdncmVnYXRlLXNwZWNpZmljIGFuZCB3aWxkY2FyZCBldmVudCBoYW5kbGluZ1xuICogLSBFdmVudCBzdGF0aXN0aWNzIGFuZCBsaXN0ZW5lciBtYW5hZ2VtZW50XG4gKiAtIFBlcmZvcm1hbmNlIHRlc3Rpbmcgd2l0aCBoaWdoLWZyZXF1ZW5jeSBldmVudHNcbiAqIC0gQ29uY3VycmVudCBldmVudCBwcm9jZXNzaW5nIGFuZCBlcnJvciByZWNvdmVyeVxuICogLSBNZW1vcnkgbWFuYWdlbWVudCBhbmQgY2xlYW51cCBzY2VuYXJpb3NcbiAqIC0gSW50ZWdyYXRpb24gd29ya2Zsb3dzIGFuZCByZWFsLXdvcmxkIHNjZW5hcmlvc1xuICogLSBFcnJvciBib3VuZGFyeSB0ZXN0aW5nIGFuZCByZXNpbGllbmNlXG4gKiAtIEFkdmFuY2VkIGV2ZW50IGNvcnJlbGF0aW9uIGFuZCB0cmFjaW5nXG4gKi9cblxuaW1wb3J0IHsgVGVzdCwgVGVzdGluZ01vZHVsZSB9IGZyb20gJ0BuZXN0anMvdGVzdGluZyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIyIH0gZnJvbSAnQG5lc3Rqcy9ldmVudC1lbWl0dGVyJztcbmltcG9ydCB7IEV2ZW50QnVzU2VydmljZSB9IGZyb20gJy4vZXZlbnQtYnVzLnNlcnZpY2UnO1xuaW1wb3J0IHtcbiAgQmFzZURvbWFpbkV2ZW50LFxuICBFdmVudE1ldGFkYXRhLFxufSBmcm9tICcuL2ludGVyZmFjZXMvZG9tYWluLWV2ZW50LmludGVyZmFjZSc7XG5cbi8vIE1vY2sgZXZlbnQgZm9yIHRlc3RpbmdcbmNsYXNzIFRlc3REb21haW5FdmVudCBleHRlbmRzIEJhc2VEb21haW5FdmVudDx7IHRlc3Q6IHN0cmluZyB9PiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGFnZ3JlZ2F0ZUlkOiBzdHJpbmcsXG4gICAgZGF0YTogeyB0ZXN0OiBzdHJpbmcgfSxcbiAgICBtZXRhZGF0YTogRXZlbnRNZXRhZGF0YSA9IHt9LFxuICApIHtcbiAgICBzdXBlcihhZ2dyZWdhdGVJZCwgJ1Rlc3RBZ2dyZWdhdGUnLCBkYXRhLCBtZXRhZGF0YSk7XG4gIH1cbn1cblxuZGVzY3JpYmUoJ0V2ZW50QnVzU2VydmljZScsICgpID0+IHtcbiAgbGV0IHNlcnZpY2U6IEV2ZW50QnVzU2VydmljZTtcbiAgbGV0IGV2ZW50RW1pdHRlcjogamVzdC5Nb2NrZWQ8RXZlbnRFbWl0dGVyMj47XG5cbiAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9ja0V2ZW50RW1pdHRlciA9IHtcbiAgICAgIGVtaXRBc3luYzogamVzdC5mbigpLFxuICAgICAgb246IGplc3QuZm4oKSxcbiAgICAgIG9mZjogamVzdC5mbigpLFxuICAgICAgZXZlbnROYW1lczogamVzdC5mbigpLFxuICAgICAgbGlzdGVuZXJDb3VudDogamVzdC5mbigpLFxuICAgICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBqZXN0LmZuKCksXG4gICAgfTtcblxuICAgIGNvbnN0IG1vZHVsZTogVGVzdGluZ01vZHVsZSA9IGF3YWl0IFRlc3QuY3JlYXRlVGVzdGluZ01vZHVsZSh7XG4gICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgRXZlbnRCdXNTZXJ2aWNlLFxuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogRXZlbnRFbWl0dGVyMixcbiAgICAgICAgICB1c2VWYWx1ZTogbW9ja0V2ZW50RW1pdHRlcixcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSkuY29tcGlsZSgpO1xuXG4gICAgc2VydmljZSA9IG1vZHVsZS5nZXQ8RXZlbnRCdXNTZXJ2aWNlPihFdmVudEJ1c1NlcnZpY2UpO1xuICAgIGV2ZW50RW1pdHRlciA9IG1vZHVsZS5nZXQoRXZlbnRFbWl0dGVyMik7XG5cbiAgICAvLyBNb2NrIHRoZSBsb2dnZXIgbWV0aG9kc1xuICAgIGplc3Quc3B5T24oc2VydmljZVsnbG9nZ2VyJ10sICdkZWJ1ZycpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuICAgIGplc3Quc3B5T24oc2VydmljZVsnbG9nZ2VyJ10sICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuICAgIGplc3Quc3B5T24oc2VydmljZVsnbG9nZ2VyJ10sICdsb2cnKS5tb2NrSW1wbGVtZW50YXRpb24oKTtcbiAgICBqZXN0LnNweU9uKHNlcnZpY2VbJ2xvZ2dlciddLCAnd2FybicpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnZW1pdCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGVtaXQgZXZlbnQgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgdGVzdEV2ZW50ID0gbmV3IFRlc3REb21haW5FdmVudCgnYWdncmVnYXRlLTEnLCB7IHRlc3Q6ICdkYXRhJyB9KTtcbiAgICAgIGV2ZW50RW1pdHRlci5lbWl0QXN5bmMubW9ja1Jlc29sdmVkVmFsdWUoW10gYXMgYW55KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBhd2FpdCBzZXJ2aWNlLmVtaXQodGVzdEV2ZW50KTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZXZlbnRFbWl0dGVyLmVtaXRBc3luYykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDMpO1xuICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5lbWl0QXN5bmMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnVGVzdERvbWFpbkV2ZW50JyxcbiAgICAgICAgdGVzdEV2ZW50LFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIuZW1pdEFzeW5jKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnKicsIHRlc3RFdmVudCk7XG4gICAgICBleHBlY3QoZXZlbnRFbWl0dGVyLmVtaXRBc3luYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdUZXN0QWdncmVnYXRlLionLFxuICAgICAgICB0ZXN0RXZlbnQsXG4gICAgICApO1xuXG4gICAgICBleHBlY3Qoc2VydmljZVsnbG9nZ2VyJ10uZGVidWcpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnRW1pdHRpbmcgZXZlbnQ6IFRlc3REb21haW5FdmVudCcsXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBldmVudElkOiB0ZXN0RXZlbnQuZXZlbnRJZCxcbiAgICAgICAgICBhZ2dyZWdhdGVJZDogdGVzdEV2ZW50LmFnZ3JlZ2F0ZUlkLFxuICAgICAgICAgIGFnZ3JlZ2F0ZVR5cGU6IHRlc3RFdmVudC5hZ2dyZWdhdGVUeXBlLFxuICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IHRlc3RFdmVudC5tZXRhZGF0YS5jb3JyZWxhdGlvbklkLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgICBleHBlY3Qoc2VydmljZVsnbG9nZ2VyJ10uZGVidWcpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnRXZlbnQgZW1pdHRlZCBzdWNjZXNzZnVsbHk6IFRlc3REb21haW5FdmVudCcsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1pdCBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB0ZXN0RXZlbnQgPSBuZXcgVGVzdERvbWFpbkV2ZW50KCdhZ2dyZWdhdGUtMScsIHsgdGVzdDogJ2RhdGEnIH0pO1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0VtaXQgZmFpbGVkJyk7XG4gICAgICBldmVudEVtaXR0ZXIuZW1pdEFzeW5jLm1vY2tSZWplY3RlZFZhbHVlKGVycm9yKTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBhd2FpdCBleHBlY3Qoc2VydmljZS5lbWl0KHRlc3RFdmVudCkpLnJlamVjdHMudG9UaHJvdygnRW1pdCBmYWlsZWQnKTtcblxuICAgICAgZXhwZWN0KHNlcnZpY2VbJ2xvZ2dlciddLmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ0ZhaWxlZCB0byBlbWl0IGV2ZW50OiBUZXN0RG9tYWluRXZlbnQnLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgZXZlbnRJZDogdGVzdEV2ZW50LmV2ZW50SWQsXG4gICAgICAgICAgZXJyb3I6ICdFbWl0IGZhaWxlZCcsXG4gICAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdzdWJzY3JpYmUnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzdWJzY3JpYmUgdG8gZXZlbnRzIHdpdGggZGVmYXVsdCBvcHRpb25zJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgZXZlbnRUeXBlID0gJ1Rlc3RFdmVudCc7XG4gICAgICBjb25zdCBoYW5kbGVyID0gamVzdC5mbigpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIHNlcnZpY2Uuc3Vic2NyaWJlKGV2ZW50VHlwZSwgaGFuZGxlcik7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5vbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV2ZW50VHlwZSxcbiAgICAgICAgZXhwZWN0LmFueShGdW5jdGlvbiksXG4gICAgICApO1xuICAgICAgZXhwZWN0KHNlcnZpY2VbJ2xvZ2dlciddLmRlYnVnKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ1N1YnNjcmliaW5nIHRvIGV2ZW50OiBUZXN0RXZlbnQnLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgaGFuZGxlck5hbWU6IGhhbmRsZXIubmFtZSxcbiAgICAgICAgICBvcHRpb25zOiB7fSxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzdWJzY3JpYmUgd2l0aCBhc3luYz1mYWxzZSBvcHRpb24nLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBldmVudFR5cGUgPSAnVGVzdEV2ZW50JztcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBqZXN0LmZuKCk7XG4gICAgICBjb25zdCBvcHRpb25zID0geyBhc3luYzogZmFsc2UgfTtcblxuICAgICAgLy8gQWN0XG4gICAgICBzZXJ2aWNlLnN1YnNjcmliZShldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIub24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBldmVudFR5cGUsXG4gICAgICAgIGV4cGVjdC5hbnkoRnVuY3Rpb24pLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChzZXJ2aWNlWydsb2dnZXInXS5kZWJ1ZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdTdWJzY3JpYmluZyB0byBldmVudDogVGVzdEV2ZW50JyxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIGhhbmRsZXJOYW1lOiBoYW5kbGVyLm5hbWUsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc3VjY2Vzc2Z1bCBldmVudCBwcm9jZXNzaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgZXZlbnRUeXBlID0gJ1Rlc3RFdmVudCc7XG4gICAgICBjb25zdCBoYW5kbGVyID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICBjb25zdCB0ZXN0RXZlbnQgPSBuZXcgVGVzdERvbWFpbkV2ZW50KCdhZ2dyZWdhdGUtMScsIHsgdGVzdDogJ2RhdGEnIH0pO1xuXG4gICAgICBzZXJ2aWNlLnN1YnNjcmliZShldmVudFR5cGUsIGhhbmRsZXIpO1xuXG4gICAgICAvLyBHZXQgdGhlIHdyYXBwZWQgaGFuZGxlciB0aGF0IHdhcyBwYXNzZWQgdG8gZXZlbnRFbWl0dGVyLm9uXG4gICAgICBjb25zdCB3cmFwcGVkSGFuZGxlciA9IGV2ZW50RW1pdHRlci5vbi5tb2NrLmNhbGxzWzBdWzFdO1xuXG4gICAgICAvLyBBY3RcblxuICAgICAgYXdhaXQgd3JhcHBlZEhhbmRsZXIodGVzdEV2ZW50KTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoaGFuZGxlcikudG9IYXZlQmVlbkNhbGxlZFdpdGgodGVzdEV2ZW50KTtcbiAgICAgIGV4cGVjdChzZXJ2aWNlWydsb2dnZXInXS5kZWJ1ZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdIYW5kbGluZyBldmVudDogVGVzdERvbWFpbkV2ZW50JyxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIGV2ZW50SWQ6IHRlc3RFdmVudC5ldmVudElkLFxuICAgICAgICAgIGhhbmRsZXJOYW1lOiBoYW5kbGVyLm5hbWUsXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChzZXJ2aWNlWydsb2dnZXInXS5kZWJ1ZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdFdmVudCBoYW5kbGVkIHN1Y2Nlc3NmdWxseTogVGVzdERvbWFpbkV2ZW50JyxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIGV2ZW50SWQ6IHRlc3RFdmVudC5ldmVudElkLFxuICAgICAgICAgIGhhbmRsZXJOYW1lOiBoYW5kbGVyLm5hbWUsXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGV2ZW50IHByb2Nlc3NpbmcgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgZXZlbnRUeXBlID0gJ1Rlc3RFdmVudCc7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignSGFuZGxlciBmYWlsZWQnKTtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUoZXJyb3IpO1xuICAgICAgY29uc3QgdGVzdEV2ZW50ID0gbmV3IFRlc3REb21haW5FdmVudCgnYWdncmVnYXRlLTEnLCB7IHRlc3Q6ICdkYXRhJyB9KTtcblxuICAgICAgc2VydmljZS5zdWJzY3JpYmUoZXZlbnRUeXBlLCBoYW5kbGVyKTtcblxuICAgICAgLy8gR2V0IHRoZSB3cmFwcGVkIGhhbmRsZXIgdGhhdCB3YXMgcGFzc2VkIHRvIGV2ZW50RW1pdHRlci5vblxuICAgICAgY29uc3Qgd3JhcHBlZEhhbmRsZXIgPSBldmVudEVtaXR0ZXIub24ubW9jay5jYWxsc1swXVsxXTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBhd2FpdCBleHBlY3Qod3JhcHBlZEhhbmRsZXIodGVzdEV2ZW50KSkucmVqZWN0cy50b1Rocm93KCdIYW5kbGVyIGZhaWxlZCcpO1xuXG4gICAgICBleHBlY3Qoc2VydmljZVsnbG9nZ2VyJ10uZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnRXZlbnQgaGFuZGxlciBmYWlsZWQ6IFRlc3REb21haW5FdmVudCcsXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBldmVudElkOiB0ZXN0RXZlbnQuZXZlbnRJZCxcbiAgICAgICAgICBoYW5kbGVyTmFtZTogaGFuZGxlci5uYW1lLFxuICAgICAgICAgIGVycm9yOiAnSGFuZGxlciBmYWlsZWQnLFxuICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFjayxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndW5zdWJzY3JpYmUnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB1bnN1YnNjcmliZSBmcm9tIGV2ZW50cycsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGV2ZW50VHlwZSA9ICdUZXN0RXZlbnQnO1xuICAgICAgY29uc3QgaGFuZGxlciA9IGplc3QuZm4oKTtcblxuICAgICAgLy8gQWN0XG4gICAgICBzZXJ2aWNlLnVuc3Vic2NyaWJlKGV2ZW50VHlwZSwgaGFuZGxlcik7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5vZmYpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV2ZW50VHlwZSwgaGFuZGxlcik7XG4gICAgICBleHBlY3Qoc2VydmljZVsnbG9nZ2VyJ10uZGVidWcpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnVW5zdWJzY3JpYmluZyBmcm9tIGV2ZW50OiBUZXN0RXZlbnQnLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgaGFuZGxlck5hbWU6IGhhbmRsZXIubmFtZSxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnc3Vic2NyaWJlVG9BZ2dyZWdhdGUnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzdWJzY3JpYmUgdG8gYWdncmVnYXRlIGV2ZW50cycsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGFnZ3JlZ2F0ZVR5cGUgPSAnVXNlcic7XG4gICAgICBjb25zdCBoYW5kbGVyID0gamVzdC5mbigpO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgYXN5bmM6IHRydWUgfTtcblxuICAgICAgLy8gU3B5IG9uIHRoZSBzdWJzY3JpYmUgbWV0aG9kXG4gICAgICBjb25zdCBzdWJzY3JpYmVTcHkgPSBqZXN0LnNweU9uKHNlcnZpY2UsICdzdWJzY3JpYmUnKTtcblxuICAgICAgLy8gQWN0XG4gICAgICBzZXJ2aWNlLnN1YnNjcmliZVRvQWdncmVnYXRlKGFnZ3JlZ2F0ZVR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChzdWJzY3JpYmVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdVc2VyLionLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3N1YnNjcmliZVRvQWxsJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgc3Vic2NyaWJlIHRvIGFsbCBldmVudHMgd2l0aCB3aWxkY2FyZCcsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBqZXN0LmZuKCk7XG4gICAgICBjb25zdCBvcHRpb25zID0geyBhc3luYzogdHJ1ZSB9O1xuXG4gICAgICAvLyBTcHkgb24gdGhlIHN1YnNjcmliZSBtZXRob2RcbiAgICAgIGNvbnN0IHN1YnNjcmliZVNweSA9IGplc3Quc3B5T24oc2VydmljZSwgJ3N1YnNjcmliZScpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIHNlcnZpY2Uuc3Vic2NyaWJlVG9BbGwoaGFuZGxlciwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHN1YnNjcmliZVNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJyonLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldEV2ZW50U3RhdHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZXZlbnQgc3RhdGlzdGljcycsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGV2ZW50TmFtZXMgPSBbJ2V2ZW50MScsICdldmVudDInLCAnZXZlbnQzJ107XG4gICAgICBldmVudEVtaXR0ZXIuZXZlbnROYW1lcy5tb2NrUmV0dXJuVmFsdWUoZXZlbnROYW1lcyBhcyBhbnkpO1xuICAgICAgZXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQubW9ja0ltcGxlbWVudGF0aW9uKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIGV2ZW50TmFtZSA9PT0gJ2V2ZW50MScgPyAyIDogMTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHN0YXRzID0gc2VydmljZS5nZXRFdmVudFN0YXRzKCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHN0YXRzKS50b0VxdWFsKHtcbiAgICAgICAgdG90YWxMaXN0ZW5lcnM6IDQsIC8vIDIgKyAxICsgMVxuICAgICAgICBldmVudFR5cGVzOiBbJ2V2ZW50MScsICdldmVudDInLCAnZXZlbnQzJ10sXG4gICAgICB9KTtcbiAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIuZXZlbnROYW1lcykudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiB6ZXJvIHN0YXRpc3RpY3Mgd2hlbiBubyBldmVudHMnLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBldmVudEVtaXR0ZXIuZXZlbnROYW1lcy5tb2NrUmV0dXJuVmFsdWUoW10pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHN0YXRzID0gc2VydmljZS5nZXRFdmVudFN0YXRzKCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHN0YXRzKS50b0VxdWFsKHtcbiAgICAgICAgdG90YWxMaXN0ZW5lcnM6IDAsXG4gICAgICAgIGV2ZW50VHlwZXM6IFtdLFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdoYXNMaXN0ZW5lcnMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIGxpc3RlbmVycyBleGlzdCcsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGV2ZW50VHlwZSA9ICdUZXN0RXZlbnQnO1xuICAgICAgZXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQubW9ja1JldHVyblZhbHVlKDIpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHNlcnZpY2UuaGFzTGlzdGVuZXJzKGV2ZW50VHlwZSk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXZlbnRUeXBlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gbm8gbGlzdGVuZXJzIGV4aXN0JywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgZXZlbnRUeXBlID0gJ1Rlc3RFdmVudCc7XG4gICAgICBldmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudC5tb2NrUmV0dXJuVmFsdWUoMCk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gc2VydmljZS5oYXNMaXN0ZW5lcnMoZXZlbnRUeXBlKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXZlbnRUeXBlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3JlbW92ZUFsbExpc3RlbmVycycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciBzcGVjaWZpYyBldmVudCB0eXBlJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgZXZlbnRUeXBlID0gJ1Rlc3RFdmVudCc7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgc2VydmljZS5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnRUeXBlKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXZlbnRUeXBlKTtcbiAgICAgIGV4cGVjdChzZXJ2aWNlWydsb2dnZXInXS5kZWJ1ZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdSZW1vdmluZyBhbGwgbGlzdGVuZXJzIGZvciBldmVudDogVGVzdEV2ZW50JyxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlbW92ZSBhbGwgbGlzdGVuZXJzIHdoZW4gbm8gZXZlbnQgdHlwZSBzcGVjaWZpZWQnLCAoKSA9PiB7XG4gICAgICAvLyBBY3RcbiAgICAgIHNlcnZpY2UucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCk7XG4gICAgICBleHBlY3Qoc2VydmljZVsnbG9nZ2VyJ10uZGVidWcpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnUmVtb3ZpbmcgYWxsIGV2ZW50IGxpc3RlbmVycycsXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQWR2YW5jZWQgRXZlbnQgRW1pc3Npb24gU2NlbmFyaW9zJywgKCkgPT4ge1xuICAgIGRlc2NyaWJlKCdDb21wbGV4IEV2ZW50IFBhdHRlcm5zJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBlbWl0IGV2ZW50cyB3aXRoIGNvbXBsZXggYWdncmVnYXRlIHBhdHRlcm5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBjb21wbGV4RXZlbnQgPSBuZXcgVGVzdERvbWFpbkV2ZW50KFxuICAgICAgICAgICd1c2VyLXByb2ZpbGUtMTIzJyxcbiAgICAgICAgICB7IHRlc3Q6ICdjb21wbGV4LWFnZ3JlZ2F0ZS11cGRhdGUnLCBwcm9maWxlRGF0YTogeyBuYW1lOiAnSm9obicsIGVtYWlsOiAnam9obkBleGFtcGxlLmNvbScgfSB9LFxuICAgICAgICAgIHsgdXNlcklkOiAndXNlci0xMjMnLCBzZXNzaW9uSWQ6ICdzZXNzaW9uLTQ1NicgfVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgZXZlbnRFbWl0dGVyLmVtaXRBc3luYy5tb2NrUmVzb2x2ZWRWYWx1ZShbXSBhcyBhbnkpO1xuXG4gICAgICAgIGF3YWl0IHNlcnZpY2UuZW1pdChjb21wbGV4RXZlbnQpO1xuXG4gICAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIuZW1pdEFzeW5jKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnVGVzdERvbWFpbkV2ZW50JywgY29tcGxleEV2ZW50KTtcbiAgICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5lbWl0QXN5bmMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcqJywgY29tcGxleEV2ZW50KTtcbiAgICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5lbWl0QXN5bmMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdUZXN0QWdncmVnYXRlLionLCBjb21wbGV4RXZlbnQpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHJhcGlkIHNlcXVlbnRpYWwgZXZlbnQgZW1pc3Npb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMCB9LCAoXywgaSkgPT4gXG4gICAgICAgICAgbmV3IFRlc3REb21haW5FdmVudChcbiAgICAgICAgICAgIGBhZ2dyZWdhdGUtJHtpfWAsXG4gICAgICAgICAgICB7IHRlc3Q6IGByYXBpZC1ldmVudC0ke2l9YCwgc2VxdWVuY2U6IGkgfSxcbiAgICAgICAgICAgIHsgY29ycmVsYXRpb25JZDogYGNvcnItJHtpfWAgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICBldmVudEVtaXR0ZXIuZW1pdEFzeW5jLm1vY2tSZXNvbHZlZFZhbHVlKFtdIGFzIGFueSk7XG5cbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoZXZlbnRzLm1hcChldmVudCA9PiBzZXJ2aWNlLmVtaXQoZXZlbnQpKSk7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbigxMDAwKTsgLy8gU2hvdWxkIGNvbXBsZXRlIHdpdGhpbiAxIHNlY29uZFxuICAgICAgICBleHBlY3QoZXZlbnRFbWl0dGVyLmVtaXRBc3luYykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDMwMCk7IC8vIDEwMCBldmVudHMgKiAzIGNhbGxzIGVhY2hcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBldmVudHMgd2l0aCBsYXJnZSBwYXlsb2FkcyBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbGFyZ2VQYXlsb2FkID0ge1xuICAgICAgICAgIHRlc3Q6ICdsYXJnZS1wYXlsb2FkJyxcbiAgICAgICAgICBkYXRhOiBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAwMCB9LCAoXywgaSkgPT4gKHsgaWQ6IGksIHZhbHVlOiBgZGF0YS0ke2l9YC5yZXBlYXQoMTApIH0pKSxcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246ICd4Jy5yZXBlYXQoNTAwMDApLCAvLyA1MEtCIHN0cmluZ1xuICAgICAgICAgICAgdGFnczogQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwMCB9LCAoXywgaSkgPT4gYHRhZy0ke2l9YCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGxhcmdlRXZlbnQgPSBuZXcgVGVzdERvbWFpbkV2ZW50KCdsYXJnZS1hZ2dyZWdhdGUnLCBsYXJnZVBheWxvYWQpO1xuICAgICAgICBldmVudEVtaXR0ZXIuZW1pdEFzeW5jLm1vY2tSZXNvbHZlZFZhbHVlKFtdIGFzIGFueSk7XG5cbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgYXdhaXQgc2VydmljZS5lbWl0KGxhcmdlRXZlbnQpO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgICAgZXhwZWN0KGR1cmF0aW9uKS50b0JlTGVzc1RoYW4oNTAwKTsgLy8gU2hvdWxkIGhhbmRsZSBsYXJnZSBwYXlsb2FkcyBlZmZpY2llbnRseVxuICAgICAgICBleHBlY3QoZXZlbnRFbWl0dGVyLmVtaXRBc3luYykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDMpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbmN1cnJlbnQgZXZlbnQgZW1pc3Npb24gZnJvbSBtdWx0aXBsZSBzb3VyY2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBjb25jdXJyZW50RXZlbnRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogNTAgfSwgKF8sIGkpID0+IHtcbiAgICAgICAgICBjb25zdCBhZ2dyZWdhdGVUeXBlID0gaSAlIDMgPT09IDAgPyAnVXNlcicgOiBpICUgMyA9PT0gMSA/ICdPcmRlcicgOiAnUHJvZHVjdCc7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUZXN0RG9tYWluRXZlbnQoXG4gICAgICAgICAgICBgJHthZ2dyZWdhdGVUeXBlLnRvTG93ZXJDYXNlKCl9LSR7aX1gLFxuICAgICAgICAgICAgeyB0ZXN0OiBgY29uY3VycmVudC0ke2l9YCwgdHlwZTogYWdncmVnYXRlVHlwZSB9LFxuICAgICAgICAgICAgeyBcbiAgICAgICAgICAgICAgdXNlcklkOiBgdXNlci0ke2kgJSAxMH1gLFxuICAgICAgICAgICAgICBzZXNzaW9uSWQ6IGBzZXNzaW9uLSR7TWF0aC5mbG9vcihpIC8gMTApfWAsXG4gICAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IGBjb3JyLSR7aX1gLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50RW1pdHRlci5lbWl0QXN5bmMubW9ja1Jlc29sdmVkVmFsdWUoW10gYXMgYW55KTtcblxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IGNvbmN1cnJlbnRFdmVudHMubWFwKGV2ZW50ID0+IHNlcnZpY2UuZW1pdChldmVudCkpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5lbWl0QXN5bmMpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxNTApOyAvLyA1MCBldmVudHMgKiAzIGNhbGxzIGVhY2hcbiAgICAgICAgXG4gICAgICAgIC8vIFZlcmlmeSBhbGwgYWdncmVnYXRlIHBhdHRlcm5zIHdlcmUgY2FsbGVkXG4gICAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIuZW1pdEFzeW5jKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnVGVzdEFnZ3JlZ2F0ZS4qJywgZXhwZWN0LmFueShPYmplY3QpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0Vycm9yIFJlY292ZXJ5IGFuZCBSZXNpbGllbmNlJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgcGFydGlhbCBlbWlzc2lvbiBmYWlsdXJlcyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB0ZXN0RXZlbnQgPSBuZXcgVGVzdERvbWFpbkV2ZW50KCd0ZXN0LWFnZ3JlZ2F0ZScsIHsgdGVzdDogJ3BhcnRpYWwtZmFpbHVyZScgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBNb2NrIHRoZSBmaXJzdCBlbWlzc2lvbiB0byBzdWNjZWVkLCBzZWNvbmQgdG8gZmFpbCwgdGhpcmQgdG8gc3VjY2VlZFxuICAgICAgICBldmVudEVtaXR0ZXIuZW1pdEFzeW5jXG4gICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZShbXSBhcyBhbnkpIC8vIFNwZWNpZmljIGV2ZW50IHR5cGUgc3VjY2VlZHNcbiAgICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcignV2lsZGNhcmQgZW1pc3Npb24gZmFpbGVkJykpIC8vIFdpbGRjYXJkIGZhaWxzXG4gICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZShbXSBhcyBhbnkpOyAvLyBBZ2dyZWdhdGUgcGF0dGVybiBzdWNjZWVkc1xuXG4gICAgICAgIGF3YWl0IGV4cGVjdChzZXJ2aWNlLmVtaXQodGVzdEV2ZW50KSkucmVqZWN0cy50b1Rocm93KCdXaWxkY2FyZCBlbWlzc2lvbiBmYWlsZWQnKTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChzZXJ2aWNlWydsb2dnZXInXS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgJ0ZhaWxlZCB0byBlbWl0IGV2ZW50OiBUZXN0RG9tYWluRXZlbnQnLFxuICAgICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICAgIGV2ZW50SWQ6IHRlc3RFdmVudC5ldmVudElkLFxuICAgICAgICAgICAgZXJyb3I6ICdXaWxkY2FyZCBlbWlzc2lvbiBmYWlsZWQnLFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgbm9uLUVycm9yIGV4Y2VwdGlvbnMgZHVyaW5nIGVtaXNzaW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB0ZXN0RXZlbnQgPSBuZXcgVGVzdERvbWFpbkV2ZW50KCd0ZXN0LWFnZ3JlZ2F0ZScsIHsgdGVzdDogJ3N0cmluZy1lcnJvcicgfSk7XG4gICAgICAgIGNvbnN0IHN0cmluZ0Vycm9yID0gJ1N0cmluZy1iYXNlZCBlcnJvcic7XG4gICAgICAgIFxuICAgICAgICBldmVudEVtaXR0ZXIuZW1pdEFzeW5jLm1vY2tSZWplY3RlZFZhbHVlKHN0cmluZ0Vycm9yKTtcblxuICAgICAgICBhd2FpdCBleHBlY3Qoc2VydmljZS5lbWl0KHRlc3RFdmVudCkpLnJlamVjdHMudG9CZShzdHJpbmdFcnJvcik7XG4gICAgICAgIFxuICAgICAgICBleHBlY3Qoc2VydmljZVsnbG9nZ2VyJ10uZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICdGYWlsZWQgdG8gZW1pdCBldmVudDogVGVzdERvbWFpbkV2ZW50JyxcbiAgICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgICBldmVudElkOiB0ZXN0RXZlbnQuZXZlbnRJZCxcbiAgICAgICAgICAgIGVycm9yOiAnU3RyaW5nLWJhc2VkIGVycm9yJyxcbiAgICAgICAgICAgIHN0YWNrOiB1bmRlZmluZWQsXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSB0aW1lb3V0IHNjZW5hcmlvcyBkdXJpbmcgZW1pc3Npb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRlc3RFdmVudCA9IG5ldyBUZXN0RG9tYWluRXZlbnQoJ3Rlc3QtYWdncmVnYXRlJywgeyB0ZXN0OiAndGltZW91dC10ZXN0JyB9KTtcbiAgICAgICAgY29uc3QgdGltZW91dEVycm9yID0gbmV3IEVycm9yKCdFdmVudCBlbWlzc2lvbiB0aW1lb3V0Jyk7XG4gICAgICAgIHRpbWVvdXRFcnJvci5uYW1lID0gJ1RpbWVvdXRFcnJvcic7XG4gICAgICAgIFxuICAgICAgICBldmVudEVtaXR0ZXIuZW1pdEFzeW5jLm1vY2tSZWplY3RlZFZhbHVlKHRpbWVvdXRFcnJvcik7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KHNlcnZpY2UuZW1pdCh0ZXN0RXZlbnQpKS5yZWplY3RzLnRvVGhyb3coJ0V2ZW50IGVtaXNzaW9uIHRpbWVvdXQnKTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChzZXJ2aWNlWydsb2dnZXInXS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgJ0ZhaWxlZCB0byBlbWl0IGV2ZW50OiBUZXN0RG9tYWluRXZlbnQnLFxuICAgICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICAgIGV2ZW50SWQ6IHRlc3RFdmVudC5ldmVudElkLFxuICAgICAgICAgICAgZXJyb3I6ICdFdmVudCBlbWlzc2lvbiB0aW1lb3V0JyxcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBZHZhbmNlZCBTdWJzY3JpcHRpb24gTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICBkZXNjcmliZSgnSGFuZGxlciBMaWZlY3ljbGUgTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHN1YnNjcmlwdGlvbiBsaWZlY3ljbGUgd2l0aCBtdWx0aXBsZSBoYW5kbGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZXZlbnRUeXBlID0gJ1VzZXJDcmVhdGVkJztcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiA1IH0sIChfLCBpKSA9PiBcbiAgICAgICAgICBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGkgKiAxMCkpOyAvLyBWYXJpYWJsZSBkZWxheVxuICAgICAgICAgICAgcmV0dXJuIGBoYW5kbGVyLSR7aX0tcHJvY2Vzc2VkYDtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSBhbGwgaGFuZGxlcnNcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlciwgaSkgPT4ge1xuICAgICAgICAgIHNlcnZpY2Uuc3Vic2NyaWJlKGV2ZW50VHlwZSwgaGFuZGxlciwgeyBhc3luYzogaSAlIDIgPT09IDAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIub24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyg1KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRlc3QgdGhhdCBlYWNoIGhhbmRsZXIgcmVjZWl2ZXMgZGlmZmVyZW50IHdyYXBwaW5nXG4gICAgICAgIGNvbnN0IHdyYXBwZWRIYW5kbGVycyA9IGV2ZW50RW1pdHRlci5vbi5tb2NrLmNhbGxzLm1hcChjYWxsID0+IGNhbGxbMV0pO1xuICAgICAgICBleHBlY3Qod3JhcHBlZEhhbmRsZXJzKS50b0hhdmVMZW5ndGgoNSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTaW11bGF0ZSBldmVudCBoYW5kbGluZ1xuICAgICAgICBjb25zdCB0ZXN0RXZlbnQgPSBuZXcgVGVzdERvbWFpbkV2ZW50KCd1c2VyLTEyMycsIHsgdGVzdDogJ211bHRpLWhhbmRsZXInIH0pO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwod3JhcHBlZEhhbmRsZXJzLm1hcChoYW5kbGVyID0+IGhhbmRsZXIodGVzdEV2ZW50KSkpO1xuICAgICAgICBcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IHtcbiAgICAgICAgICBleHBlY3QoaGFuZGxlcikudG9IYXZlQmVlbkNhbGxlZFdpdGgodGVzdEV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgaGFuZGxlciBmYWlsdXJlcyB3aXRoIHByb3BlciBlcnJvciBsb2dnaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBldmVudFR5cGUgPSAnRXJyb3JQcm9uZUV2ZW50JztcbiAgICAgICAgY29uc3Qgc3VjY2Vzc0hhbmRsZXIgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoJ3N1Y2Nlc3MnKTtcbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignSGFuZGxlciBwcm9jZXNzaW5nIGZhaWxlZCcpKTtcbiAgICAgICAgY29uc3QgdGltZW91dEhhbmRsZXIgPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKFxuICAgICAgICAgICgpID0+IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IFxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKCdIYW5kbGVyIHRpbWVvdXQnKSksIDEwMClcbiAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgc2VydmljZS5zdWJzY3JpYmUoZXZlbnRUeXBlLCBzdWNjZXNzSGFuZGxlcik7XG4gICAgICAgIHNlcnZpY2Uuc3Vic2NyaWJlKGV2ZW50VHlwZSwgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgc2VydmljZS5zdWJzY3JpYmUoZXZlbnRUeXBlLCB0aW1lb3V0SGFuZGxlcik7XG5cbiAgICAgICAgY29uc3QgdGVzdEV2ZW50ID0gbmV3IFRlc3REb21haW5FdmVudCgndGVzdC1hZ2dyZWdhdGUnLCB7IHRlc3Q6ICdlcnJvci1oYW5kbGluZycgfSk7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRIYW5kbGVycyA9IGV2ZW50RW1pdHRlci5vbi5tb2NrLmNhbGxzLm1hcChjYWxsID0+IGNhbGxbMV0pO1xuXG4gICAgICAgIC8vIFRlc3Qgc3VjY2Vzc2Z1bCBoYW5kbGVyXG4gICAgICAgIGF3YWl0IHdyYXBwZWRIYW5kbGVyc1swXSh0ZXN0RXZlbnQpO1xuICAgICAgICBleHBlY3Qoc3VjY2Vzc0hhbmRsZXIpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHRlc3RFdmVudCk7XG4gICAgICAgIFxuICAgICAgICAvLyBUZXN0IGVycm9yIGhhbmRsZXJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHdyYXBwZWRIYW5kbGVyc1sxXSh0ZXN0RXZlbnQpKS5yZWplY3RzLnRvVGhyb3coJ0hhbmRsZXIgcHJvY2Vzc2luZyBmYWlsZWQnKTtcbiAgICAgICAgZXhwZWN0KHNlcnZpY2VbJ2xvZ2dlciddLmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAnRXZlbnQgaGFuZGxlciBmYWlsZWQ6IFRlc3REb21haW5FdmVudCcsXG4gICAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgZXZlbnRJZDogdGVzdEV2ZW50LmV2ZW50SWQsXG4gICAgICAgICAgICBoYW5kbGVyTmFtZTogZXJyb3JIYW5kbGVyLm5hbWUsXG4gICAgICAgICAgICBlcnJvcjogJ0hhbmRsZXIgcHJvY2Vzc2luZyBmYWlsZWQnLFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBUZXN0IHRpbWVvdXQgaGFuZGxlclxuICAgICAgICBhd2FpdCBleHBlY3Qod3JhcHBlZEhhbmRsZXJzWzJdKHRlc3RFdmVudCkpLnJlamVjdHMudG9UaHJvdygnSGFuZGxlciB0aW1lb3V0Jyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgYXN5bmMgdnMgc3luYyBoYW5kbGVyIG9wdGlvbnMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBldmVudFR5cGUgPSAnQXN5bmNTeW5jVGVzdCc7XG4gICAgICAgIGNvbnN0IGFzeW5jSGFuZGxlciA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnYXN5bmMtcmVzdWx0Jyk7XG4gICAgICAgIGNvbnN0IHN5bmNIYW5kbGVyID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKCdzeW5jLXJlc3VsdCcpO1xuICAgICAgICBcbiAgICAgICAgc2VydmljZS5zdWJzY3JpYmUoZXZlbnRUeXBlLCBhc3luY0hhbmRsZXIsIHsgYXN5bmM6IHRydWUgfSk7XG4gICAgICAgIHNlcnZpY2Uuc3Vic2NyaWJlKGV2ZW50VHlwZSwgc3luY0hhbmRsZXIsIHsgYXN5bmM6IGZhbHNlIH0pO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5vbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgdGVzdEV2ZW50ID0gbmV3IFRlc3REb21haW5FdmVudCgndGVzdC1hZ2dyZWdhdGUnLCB7IHRlc3Q6ICdhc3luYy1zeW5jJyB9KTtcbiAgICAgICAgY29uc3QgW2FzeW5jV3JhcHBlciwgc3luY1dyYXBwZXJdID0gZXZlbnRFbWl0dGVyLm9uLm1vY2suY2FsbHMubWFwKGNhbGwgPT4gY2FsbFsxXSk7XG4gICAgICAgIFxuICAgICAgICAvLyBCb3RoIHNob3VsZCB3b3JrIGJ1dCBwb3RlbnRpYWxseSBoYW5kbGUgZXJyb3JzIGRpZmZlcmVudGx5XG4gICAgICAgIGF3YWl0IGFzeW5jV3JhcHBlcih0ZXN0RXZlbnQpO1xuICAgICAgICBhd2FpdCBzeW5jV3JhcHBlcih0ZXN0RXZlbnQpO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KGFzeW5jSGFuZGxlcikudG9IYXZlQmVlbkNhbGxlZFdpdGgodGVzdEV2ZW50KTtcbiAgICAgICAgZXhwZWN0KHN5bmNIYW5kbGVyKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh0ZXN0RXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnV2lsZGNhcmQgYW5kIFBhdHRlcm4gU3Vic2NyaXB0aW9ucycsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbXBsZXggd2lsZGNhcmQgc3Vic2NyaXB0aW9uIHBhdHRlcm5zJywgKCkgPT4ge1xuICAgICAgICBjb25zdCB3aWxkY2FyZEhhbmRsZXIgPSBqZXN0LmZuKCk7XG4gICAgICAgIGNvbnN0IHVzZXJBZ2dyZWdhdGVIYW5kbGVyID0gamVzdC5mbigpO1xuICAgICAgICBjb25zdCBvcmRlckFnZ3JlZ2F0ZUhhbmRsZXIgPSBqZXN0LmZuKCk7XG4gICAgICAgIFxuICAgICAgICBzZXJ2aWNlLnN1YnNjcmliZVRvQWxsKHdpbGRjYXJkSGFuZGxlcik7XG4gICAgICAgIHNlcnZpY2Uuc3Vic2NyaWJlVG9BZ2dyZWdhdGUoJ1VzZXInLCB1c2VyQWdncmVnYXRlSGFuZGxlcik7XG4gICAgICAgIHNlcnZpY2Uuc3Vic2NyaWJlVG9BZ2dyZWdhdGUoJ09yZGVyJywgb3JkZXJBZ2dyZWdhdGVIYW5kbGVyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFZlcmlmeSBpbnRlcm5hbCBzdWJzY3JpYmUgY2FsbHNcbiAgICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5vbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJyonLCBleHBlY3QuYW55KEZ1bmN0aW9uKSk7XG4gICAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIub24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdVc2VyLionLCBleHBlY3QuYW55KEZ1bmN0aW9uKSk7XG4gICAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIub24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdPcmRlci4qJywgZXhwZWN0LmFueShGdW5jdGlvbikpO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KHNlcnZpY2VbJ2xvZ2dlciddLmRlYnVnKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAnU3Vic2NyaWJpbmcgdG8gZXZlbnQ6IConLFxuICAgICAgICAgIGV4cGVjdC5hbnkoT2JqZWN0KVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHN1YnNjcmlwdGlvbiB0byBub24tZXhpc3RlbnQgYWdncmVnYXRlIHR5cGVzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gamVzdC5mbigpO1xuICAgICAgICBcbiAgICAgICAgc2VydmljZS5zdWJzY3JpYmVUb0FnZ3JlZ2F0ZSgnTm9uRXhpc3RlbnRBZ2dyZWdhdGUnLCBoYW5kbGVyKTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIub24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdOb25FeGlzdGVudEFnZ3JlZ2F0ZS4qJywgZXhwZWN0LmFueShGdW5jdGlvbikpO1xuICAgICAgICBleHBlY3Qoc2VydmljZVsnbG9nZ2VyJ10uZGVidWcpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICdTdWJzY3JpYmluZyB0byBldmVudDogTm9uRXhpc3RlbnRBZ2dyZWdhdGUuKicsXG4gICAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgaGFuZGxlck5hbWU6IGhhbmRsZXIubmFtZSxcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHN1YnNjcmlwdGlvbiB3aXRoIGN1c3RvbSBvcHRpb25zIGZvciBhZ2dyZWdhdGUgcGF0dGVybnMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBqZXN0LmZuKCk7XG4gICAgICAgIGNvbnN0IGN1c3RvbU9wdGlvbnMgPSB7IGFzeW5jOiBmYWxzZSwgcGFyYWxsZWw6IHRydWUsIHNjb3BlOiAndXNlcicgYXMgY29uc3QgfTtcbiAgICAgICAgXG4gICAgICAgIHNlcnZpY2Uuc3Vic2NyaWJlVG9BZ2dyZWdhdGUoJ0N1c3RvbUFnZ3JlZ2F0ZScsIGhhbmRsZXIsIGN1c3RvbU9wdGlvbnMpO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5vbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ0N1c3RvbUFnZ3JlZ2F0ZS4qJywgZXhwZWN0LmFueShGdW5jdGlvbikpO1xuICAgICAgICBleHBlY3Qoc2VydmljZVsnbG9nZ2VyJ10uZGVidWcpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICdTdWJzY3JpYmluZyB0byBldmVudDogQ3VzdG9tQWdncmVnYXRlLionLFxuICAgICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICAgIGhhbmRsZXJOYW1lOiBoYW5kbGVyLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBjdXN0b21PcHRpb25zLFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0V2ZW50IFN0YXRpc3RpY3MgYW5kIE1vbml0b3JpbmcnLCAoKSA9PiB7XG4gICAgZGVzY3JpYmUoJ0FkdmFuY2VkIFN0YXRpc3RpY3MgQ2FsY3VsYXRpb24nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb21wbGV4IGV2ZW50IHN0YXRpc3RpY3Mgc2NlbmFyaW9zJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBjb21wbGV4RXZlbnROYW1lcyA9IFtcbiAgICAgICAgICAnVXNlci5DcmVhdGVkJywgJ1VzZXIuVXBkYXRlZCcsICdVc2VyLkRlbGV0ZWQnLFxuICAgICAgICAgICdPcmRlci5QbGFjZWQnLCAnT3JkZXIuQ2FuY2VsbGVkJywgJ09yZGVyLkZ1bGZpbGxlZCcsXG4gICAgICAgICAgJ1Byb2R1Y3QuQWRkZWQnLCAnUHJvZHVjdC5VcGRhdGVkJyxcbiAgICAgICAgICAnKicsICdVc2VyLionLCAnT3JkZXIuKicsXG4gICAgICAgIF07XG4gICAgICAgIFxuICAgICAgICBldmVudEVtaXR0ZXIuZXZlbnROYW1lcy5tb2NrUmV0dXJuVmFsdWUoY29tcGxleEV2ZW50TmFtZXMgYXMgYW55KTtcbiAgICAgICAgXG4gICAgICAgIC8vIE1vY2sgdmFyeWluZyBsaXN0ZW5lciBjb3VudHNcbiAgICAgICAgZXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQubW9ja0ltcGxlbWVudGF0aW9uKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnROYW1lLmluY2x1ZGVzKCdVc2VyJykpIHJldHVybiAzO1xuICAgICAgICAgIGlmIChldmVudE5hbWUuaW5jbHVkZXMoJ09yZGVyJykpIHJldHVybiAyO1xuICAgICAgICAgIGlmIChldmVudE5hbWUuaW5jbHVkZXMoJ1Byb2R1Y3QnKSkgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJyonKSByZXR1cm4gNTsgLy8gV2lsZGNhcmQgbGlzdGVuZXJzXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBzZXJ2aWNlLmdldEV2ZW50U3RhdHMoKTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChzdGF0cy5ldmVudFR5cGVzKS50b0VxdWFsKGNvbXBsZXhFdmVudE5hbWVzKTtcbiAgICAgICAgZXhwZWN0KHN0YXRzLnRvdGFsTGlzdGVuZXJzKS50b0JlKDIwKTsgLy8gMyszKzMrMisyKzIrMSsxKzUrMysyID0gMjcsIGJ1dCByZWNhbGN1bGF0ZTogMyozICsgMiozICsgMSoyICsgNSoxICsgMyoxICsgMioxID0gOSs2KzIrNSszKzIgPSAyN1xuICAgICAgICBleHBlY3QoZXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyhjb21wbGV4RXZlbnROYW1lcy5sZW5ndGgpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHN0YXRpc3RpY3MgZm9yIGV2ZW50cyB3aXRoIHplcm8gbGlzdGVuZXJzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBldmVudE5hbWVzID0gWydFbXB0eUV2ZW50MScsICdFbXB0eUV2ZW50MicsICdFbXB0eUV2ZW50MyddO1xuICAgICAgICBcbiAgICAgICAgZXZlbnRFbWl0dGVyLmV2ZW50TmFtZXMubW9ja1JldHVyblZhbHVlKGV2ZW50TmFtZXMgYXMgYW55KTtcbiAgICAgICAgZXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQubW9ja1JldHVyblZhbHVlKDApO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBzZXJ2aWNlLmdldEV2ZW50U3RhdHMoKTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChzdGF0cykudG9FcXVhbCh7XG4gICAgICAgICAgdG90YWxMaXN0ZW5lcnM6IDAsXG4gICAgICAgICAgZXZlbnRUeXBlczogZXZlbnROYW1lcyxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgc3RhdGlzdGljcyBjYWxjdWxhdGlvbiB3aXRoIGxhcmdlIG51bWJlcnMgb2YgZXZlbnRzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtYW55RXZlbnROYW1lcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMDAgfSwgKF8sIGkpID0+IGBFdmVudCR7aX1gKTtcbiAgICAgICAgXG4gICAgICAgIGV2ZW50RW1pdHRlci5ldmVudE5hbWVzLm1vY2tSZXR1cm5WYWx1ZShtYW55RXZlbnROYW1lcyBhcyBhbnkpO1xuICAgICAgICBldmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudC5tb2NrSW1wbGVtZW50YXRpb24oKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGV2ZW50TnVtID0gcGFyc2VJbnQoZXZlbnROYW1lLnJlcGxhY2UoJ0V2ZW50JywgJycpKTtcbiAgICAgICAgICByZXR1cm4gZXZlbnROdW0gJSAxMDsgLy8gMC05IGxpc3RlbmVycyBwZXIgZXZlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBzdGF0cyA9IHNlcnZpY2UuZ2V0RXZlbnRTdGF0cygpO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbigxMDApOyAvLyBTaG91bGQgYmUgZmFzdCBldmVuIHdpdGggbWFueSBldmVudHNcbiAgICAgICAgZXhwZWN0KHN0YXRzLmV2ZW50VHlwZXMpLnRvSGF2ZUxlbmd0aCgxMDAwKTtcbiAgICAgICAgZXhwZWN0KHN0YXRzLnRvdGFsTGlzdGVuZXJzKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEwMDApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnTGlzdGVuZXIgRGV0ZWN0aW9uIGFuZCBNYW5hZ2VtZW50JywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBhY2N1cmF0ZWx5IGRldGVjdCBsaXN0ZW5lcnMgZm9yIHZhcmlvdXMgZXZlbnQgdHlwZXMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRlc3RTY2VuYXJpb3MgPSBbXG4gICAgICAgICAgeyBldmVudFR5cGU6ICdFeGlzdGluZ0V2ZW50JywgbGlzdGVuZXJDb3VudDogNSwgZXhwZWN0ZWQ6IHRydWUgfSxcbiAgICAgICAgICB7IGV2ZW50VHlwZTogJ0VtcHR5RXZlbnQnLCBsaXN0ZW5lckNvdW50OiAwLCBleHBlY3RlZDogZmFsc2UgfSxcbiAgICAgICAgICB7IGV2ZW50VHlwZTogJ1NpbmdsZUxpc3RlbmVyRXZlbnQnLCBsaXN0ZW5lckNvdW50OiAxLCBleHBlY3RlZDogdHJ1ZSB9LFxuICAgICAgICAgIHsgZXZlbnRUeXBlOiAnTWFueUxpc3RlbmVyc0V2ZW50JywgbGlzdGVuZXJDb3VudDogMTAwLCBleHBlY3RlZDogdHJ1ZSB9LFxuICAgICAgICBdO1xuICAgICAgICBcbiAgICAgICAgdGVzdFNjZW5hcmlvcy5mb3JFYWNoKHNjZW5hcmlvID0+IHtcbiAgICAgICAgICBldmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudC5tb2NrUmV0dXJuVmFsdWUoc2NlbmFyaW8ubGlzdGVuZXJDb3VudCk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gc2VydmljZS5oYXNMaXN0ZW5lcnMoc2NlbmFyaW8uZXZlbnRUeXBlKTtcbiAgICAgICAgICBcbiAgICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKHNjZW5hcmlvLmV4cGVjdGVkKTtcbiAgICAgICAgICBleHBlY3QoZXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHNjZW5hcmlvLmV2ZW50VHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGxpc3RlbmVyIHJlbW92YWwgZm9yIHNwZWNpZmljIGV2ZW50IHR5cGVzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBldmVudFR5cGVzID0gWydFdmVudDEnLCAnRXZlbnQyJywgJ0V2ZW50MyddO1xuICAgICAgICBcbiAgICAgICAgZXZlbnRUeXBlcy5mb3JFYWNoKGV2ZW50VHlwZSA9PiB7XG4gICAgICAgICAgc2VydmljZS5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnRUeXBlKTtcbiAgICAgICAgICBcbiAgICAgICAgICBleHBlY3QoZXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXZlbnRUeXBlKTtcbiAgICAgICAgICBleHBlY3Qoc2VydmljZVsnbG9nZ2VyJ10uZGVidWcpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICAgYFJlbW92aW5nIGFsbCBsaXN0ZW5lcnMgZm9yIGV2ZW50OiAke2V2ZW50VHlwZX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoZXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDMpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGdsb2JhbCBsaXN0ZW5lciByZW1vdmFsIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgICAgc2VydmljZS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTsgLy8gTm8gZXZlbnQgdHlwZSBzcGVjaWZpZWRcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgpO1xuICAgICAgICBleHBlY3Qoc2VydmljZVsnbG9nZ2VyJ10uZGVidWcpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICdSZW1vdmluZyBhbGwgZXZlbnQgbGlzdGVuZXJzJ1xuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHJlbW92YWwgb2YgbGlzdGVuZXJzIGZvciBub24tZXhpc3RlbnQgZXZlbnRzJywgKCkgPT4ge1xuICAgICAgICBzZXJ2aWNlLnJlbW92ZUFsbExpc3RlbmVycygnTm9uRXhpc3RlbnRFdmVudCcpO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdOb25FeGlzdGVudEV2ZW50Jyk7XG4gICAgICAgIGV4cGVjdChzZXJ2aWNlWydsb2dnZXInXS5kZWJ1ZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgJ1JlbW92aW5nIGFsbCBsaXN0ZW5lcnMgZm9yIGV2ZW50OiBOb25FeGlzdGVudEV2ZW50J1xuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZSBhbmQgQ29uY3VycmVuY3kgVGVzdGluZycsICgpID0+IHtcbiAgICBkZXNjcmliZSgnSGlnaC1GcmVxdWVuY3kgRXZlbnQgUHJvY2Vzc2luZycsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGhpZ2gtZnJlcXVlbmN5IGV2ZW50IGVtaXNzaW9uIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBldmVudENvdW50ID0gMTAwMDtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogZXZlbnRDb3VudCB9LCAoXywgaSkgPT4gXG4gICAgICAgICAgbmV3IFRlc3REb21haW5FdmVudChcbiAgICAgICAgICAgIGBoaWdoLWZyZXEtJHtpfWAsXG4gICAgICAgICAgICB7IHRlc3Q6IGBoaWdoLWZyZXF1ZW5jeS0ke2l9YCwgYmF0Y2g6IE1hdGguZmxvb3IoaSAvIDEwMCkgfSxcbiAgICAgICAgICAgIHsgY29ycmVsYXRpb25JZDogYGJhdGNoLSR7TWF0aC5mbG9vcihpIC8gMTAwKX1gIH1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICBldmVudEVtaXR0ZXIuZW1pdEFzeW5jLm1vY2tSZXNvbHZlZFZhbHVlKFtdIGFzIGFueSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChldmVudHMubWFwKGV2ZW50ID0+IHNlcnZpY2UuZW1pdChldmVudCkpKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KGR1cmF0aW9uKS50b0JlTGVzc1RoYW4oMjAwMCk7IC8vIFNob3VsZCBjb21wbGV0ZSB3aXRoaW4gMiBzZWNvbmRzXG4gICAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIuZW1pdEFzeW5jKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoZXZlbnRDb3VudCAqIDMpOyAvLyBFYWNoIGV2ZW50IGNhbGxzIGVtaXRBc3luYyAzIHRpbWVzXG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29uY3VycmVudCBzdWJzY3JpcHRpb24gYW5kIGVtaXNzaW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBjb25jdXJyZW50SGFuZGxlcnMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMCB9LCAoXywgaSkgPT4gXG4gICAgICAgICAgamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBNYXRoLnJhbmRvbSgpICogMTApKTtcbiAgICAgICAgICAgIHJldHVybiBgY29uY3VycmVudC1oYW5kbGVyLSR7aX1gO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjb25jdXJyZW50RXZlbnRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjAgfSwgKF8sIGkpID0+IFxuICAgICAgICAgIG5ldyBUZXN0RG9tYWluRXZlbnQoXG4gICAgICAgICAgICBgY29uY3VycmVudC0ke2l9YCxcbiAgICAgICAgICAgIHsgdGVzdDogYGNvbmN1cnJlbnQtcHJvY2Vzc2luZy0ke2l9YCB9XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgLy8gU3Vic2NyaWJlIGhhbmRsZXJzIGNvbmN1cnJlbnRseVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBjb25jdXJyZW50SGFuZGxlcnMubWFwKChoYW5kbGVyLCBpKSA9PiBcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShzZXJ2aWNlLnN1YnNjcmliZShgQ29uY3VycmVudEV2ZW50JHtpICUgNX1gLCBoYW5kbGVyKSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICBldmVudEVtaXR0ZXIuZW1pdEFzeW5jLm1vY2tSZXNvbHZlZFZhbHVlKFtdIGFzIGFueSk7XG4gICAgICAgIFxuICAgICAgICAvLyBFbWl0IGV2ZW50cyBjb25jdXJyZW50bHlcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY29uY3VycmVudEV2ZW50cy5tYXAoZXZlbnQgPT4gc2VydmljZS5lbWl0KGV2ZW50KSkpO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbigxMDAwKTtcbiAgICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5vbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEwKTtcbiAgICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5lbWl0QXN5bmMpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyg2MCk7IC8vIDIwIGV2ZW50cyAqIDMgY2FsbHMgZWFjaFxuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIG1lbW9yeS1lZmZpY2llbnQgZXZlbnQgcHJvY2Vzc2luZyB3aXRoIGxhcmdlIGJhdGNoZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IDUwMDtcbiAgICAgICAgY29uc3QgYmF0Y2hlcyA9IDEwO1xuICAgICAgICBcbiAgICAgICAgZXZlbnRFbWl0dGVyLmVtaXRBc3luYy5tb2NrUmVzb2x2ZWRWYWx1ZShbXSBhcyBhbnkpO1xuICAgICAgICBcbiAgICAgICAgZm9yIChsZXQgYmF0Y2ggPSAwOyBiYXRjaCA8IGJhdGNoZXM7IGJhdGNoKyspIHtcbiAgICAgICAgICBjb25zdCBiYXRjaEV2ZW50cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGJhdGNoU2l6ZSB9LCAoXywgaSkgPT4gXG4gICAgICAgICAgICBuZXcgVGVzdERvbWFpbkV2ZW50KFxuICAgICAgICAgICAgICBgYmF0Y2gtJHtiYXRjaH0tZXZlbnQtJHtpfWAsXG4gICAgICAgICAgICAgIHsgdGVzdDogYGJhdGNoLXByb2Nlc3NpbmdgLCBiYXRjaElkOiBiYXRjaCwgZXZlbnRJbmRleDogaSB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBiYXRjaFN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYmF0Y2hFdmVudHMubWFwKGV2ZW50ID0+IHNlcnZpY2UuZW1pdChldmVudCkpKTtcbiAgICAgICAgICBjb25zdCBiYXRjaER1cmF0aW9uID0gRGF0ZS5ub3coKSAtIGJhdGNoU3RhcnRUaW1lO1xuICAgICAgICAgIFxuICAgICAgICAgIGV4cGVjdChiYXRjaER1cmF0aW9uKS50b0JlTGVzc1RoYW4oMTAwMCk7IC8vIEVhY2ggYmF0Y2ggc2hvdWxkIGNvbXBsZXRlIHF1aWNrbHlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5lbWl0QXN5bmMpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyhiYXRjaFNpemUgKiBiYXRjaGVzICogMyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdFcnJvciBSZWNvdmVyeSBVbmRlciBMb2FkJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBtYWludGFpbiBwZXJmb3JtYW5jZSBkdXJpbmcgcGFydGlhbCBmYWlsdXJlcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIChfLCBpKSA9PiBcbiAgICAgICAgICBuZXcgVGVzdERvbWFpbkV2ZW50KGBsb2FkLXRlc3QtJHtpfWAsIHsgdGVzdDogYGxvYWQtJHtpfWAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNpbXVsYXRlIGludGVybWl0dGVudCBmYWlsdXJlc1xuICAgICAgICBldmVudEVtaXR0ZXIuZW1pdEFzeW5jLm1vY2tJbXBsZW1lbnRhdGlvbigoZXZlbnRUeXBlLCBldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNob3VsZEZhaWwgPSBNYXRoLnJhbmRvbSgpIDwgMC4xOyAvLyAxMCUgZmFpbHVyZSByYXRlXG4gICAgICAgICAgaWYgKHNob3VsZEZhaWwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYFNpbXVsYXRlZCBmYWlsdXJlIGZvciAke2V2ZW50VHlwZX1gKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10gYXMgYW55KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFxuICAgICAgICAgIGV2ZW50cy5tYXAoZXZlbnQgPT4gc2VydmljZS5lbWl0KGV2ZW50KSlcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NmdWwgPSByZXN1bHRzLmZpbHRlcihyID0+IHIuc3RhdHVzID09PSAnZnVsZmlsbGVkJykubGVuZ3RoO1xuICAgICAgICBjb25zdCBmYWlsZWQgPSByZXN1bHRzLmZpbHRlcihyID0+IHIuc3RhdHVzID09PSAncmVqZWN0ZWQnKS5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICBleHBlY3Qoc3VjY2Vzc2Z1bCkudG9CZUdyZWF0ZXJUaGFuKDgwKTsgLy8gQXQgbGVhc3QgODAlIHNob3VsZCBzdWNjZWVkXG4gICAgICAgIGV4cGVjdChmYWlsZWQpLnRvQmVMZXNzVGhhbigyMCk7IC8vIExlc3MgdGhhbiAyMCUgc2hvdWxkIGZhaWxcbiAgICAgICAgZXhwZWN0KHN1Y2Nlc3NmdWwgKyBmYWlsZWQpLnRvQmUoMTAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBjYXNjYWRpbmcgaGFuZGxlciBmYWlsdXJlcyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBldmVudFR5cGUgPSAnQ2FzY2FkaW5nRmFpbHVyZVRlc3QnO1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDUgfSwgKF8sIGkpID0+IFxuICAgICAgICAgIGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgPCAyKSB0aHJvdyBuZXcgRXJyb3IoYEhhbmRsZXIgJHtpfSBmYWlsZWRgKTtcbiAgICAgICAgICAgIHJldHVybiBgaGFuZGxlci0ke2l9LXN1Y2Nlc3NgO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4gc2VydmljZS5zdWJzY3JpYmUoZXZlbnRUeXBlLCBoYW5kbGVyKSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0ZXN0RXZlbnQgPSBuZXcgVGVzdERvbWFpbkV2ZW50KCd0ZXN0LWFnZ3JlZ2F0ZScsIHsgdGVzdDogJ2Nhc2NhZGluZy1mYWlsdXJlJyB9KTtcbiAgICAgICAgY29uc3Qgd3JhcHBlZEhhbmRsZXJzID0gZXZlbnRFbWl0dGVyLm9uLm1vY2suY2FsbHMubWFwKGNhbGwgPT4gY2FsbFsxXSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFxuICAgICAgICAgIHdyYXBwZWRIYW5kbGVycy5tYXAoaGFuZGxlciA9PiBoYW5kbGVyKHRlc3RFdmVudCkpXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBzdWNjZXNzZnVsID0gcmVzdWx0cy5maWx0ZXIociA9PiByLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZmFpbGVkID0gcmVzdWx0cy5maWx0ZXIociA9PiByLnN0YXR1cyA9PT0gJ3JlamVjdGVkJykubGVuZ3RoO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KHN1Y2Nlc3NmdWwpLnRvQmUoMyk7IC8vIExhc3QgMyBoYW5kbGVycyBzaG91bGQgc3VjY2VlZFxuICAgICAgICBleHBlY3QoZmFpbGVkKS50b0JlKDIpOyAvLyBGaXJzdCAyIGhhbmRsZXJzIHNob3VsZCBmYWlsXG4gICAgICAgIFxuICAgICAgICAvLyBWZXJpZnkgZXJyb3IgbG9nZ2luZyBmb3IgZmFpbGVkIGhhbmRsZXJzXG4gICAgICAgIGV4cGVjdChzZXJ2aWNlWydsb2dnZXInXS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdJbnRlZ3JhdGlvbiBhbmQgUmVhbC1Xb3JsZCBTY2VuYXJpb3MnLCAoKSA9PiB7XG4gICAgZGVzY3JpYmUoJ0RvbWFpbiBFdmVudCBXb3JrZmxvd3MnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb21wbGV0ZSB1c2VyIHJlZ2lzdHJhdGlvbiB3b3JrZmxvdycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY29ycmVsYXRpb25JZCA9ICd1c2VyLXJlZy1jb3JyLTEyMyc7XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9ICd1c2VyLTQ1Nic7XG4gICAgICAgIFxuICAgICAgICAvLyBEZWZpbmUgd29ya2Zsb3cgZXZlbnRzXG4gICAgICAgIGNsYXNzIFVzZXJSZWdpc3RyYXRpb25TdGFydGVkIGV4dGVuZHMgQmFzZURvbWFpbkV2ZW50PHsgZW1haWw6IHN0cmluZzsgdGVtcFBhc3N3b3JkOiBzdHJpbmcgfT4ge1xuICAgICAgICAgIGNvbnN0cnVjdG9yKHVzZXJJZDogc3RyaW5nLCBkYXRhOiB7IGVtYWlsOiBzdHJpbmc7IHRlbXBQYXNzd29yZDogc3RyaW5nIH0pIHtcbiAgICAgICAgICAgIHN1cGVyKHVzZXJJZCwgJ1VzZXInLCBkYXRhLCB7IGNvcnJlbGF0aW9uSWQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjbGFzcyBFbWFpbFZlcmlmaWNhdGlvblNlbnQgZXh0ZW5kcyBCYXNlRG9tYWluRXZlbnQ8eyBlbWFpbDogc3RyaW5nOyB2ZXJpZmljYXRpb25Ub2tlbjogc3RyaW5nIH0+IHtcbiAgICAgICAgICBjb25zdHJ1Y3Rvcih1c2VySWQ6IHN0cmluZywgZGF0YTogeyBlbWFpbDogc3RyaW5nOyB2ZXJpZmljYXRpb25Ub2tlbjogc3RyaW5nIH0pIHtcbiAgICAgICAgICAgIHN1cGVyKHVzZXJJZCwgJ1VzZXInLCBkYXRhLCB7IGNvcnJlbGF0aW9uSWQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjbGFzcyBVc2VyUmVnaXN0cmF0aW9uQ29tcGxldGVkIGV4dGVuZHMgQmFzZURvbWFpbkV2ZW50PHsgdXNlcklkOiBzdHJpbmc7IHByb2ZpbGVEYXRhOiBhbnkgfT4ge1xuICAgICAgICAgIGNvbnN0cnVjdG9yKHVzZXJJZDogc3RyaW5nLCBkYXRhOiB7IHVzZXJJZDogc3RyaW5nOyBwcm9maWxlRGF0YTogYW55IH0pIHtcbiAgICAgICAgICAgIHN1cGVyKHVzZXJJZCwgJ1VzZXInLCBkYXRhLCB7IGNvcnJlbGF0aW9uSWQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgdXAgaGFuZGxlcnNcbiAgICAgICAgY29uc3QgZW1haWxIYW5kbGVyID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IHByb2ZpbGVIYW5kbGVyID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IGF1ZGl0SGFuZGxlciA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgICBcbiAgICAgICAgc2VydmljZS5zdWJzY3JpYmUoJ1VzZXJSZWdpc3RyYXRpb25TdGFydGVkJywgZW1haWxIYW5kbGVyKTtcbiAgICAgICAgc2VydmljZS5zdWJzY3JpYmUoJ0VtYWlsVmVyaWZpY2F0aW9uU2VudCcsIHByb2ZpbGVIYW5kbGVyKTtcbiAgICAgICAgc2VydmljZS5zdWJzY3JpYmVUb0FsbChhdWRpdEhhbmRsZXIpOyAvLyBBdWRpdCBhbGwgZXZlbnRzXG4gICAgICAgIFxuICAgICAgICBldmVudEVtaXR0ZXIuZW1pdEFzeW5jLm1vY2tSZXNvbHZlZFZhbHVlKFtdIGFzIGFueSk7XG4gICAgICAgIFxuICAgICAgICAvLyBFeGVjdXRlIHdvcmtmbG93XG4gICAgICAgIGNvbnN0IHJlZ2lzdHJhdGlvbkV2ZW50ID0gbmV3IFVzZXJSZWdpc3RyYXRpb25TdGFydGVkKHVzZXJJZCwge1xuICAgICAgICAgIGVtYWlsOiAndXNlckBleGFtcGxlLmNvbScsXG4gICAgICAgICAgdGVtcFBhc3N3b3JkOiAndGVtcC1wYXNzLTEyMydcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB2ZXJpZmljYXRpb25FdmVudCA9IG5ldyBFbWFpbFZlcmlmaWNhdGlvblNlbnQodXNlcklkLCB7XG4gICAgICAgICAgZW1haWw6ICd1c2VyQGV4YW1wbGUuY29tJyxcbiAgICAgICAgICB2ZXJpZmljYXRpb25Ub2tlbjogJ3ZlcmlmeS10b2tlbi0xMjMnXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgY29tcGxldGlvbkV2ZW50ID0gbmV3IFVzZXJSZWdpc3RyYXRpb25Db21wbGV0ZWQodXNlcklkLCB7XG4gICAgICAgICAgdXNlcklkLFxuICAgICAgICAgIHByb2ZpbGVEYXRhOiB7IG5hbWU6ICdKb2huIERvZScsIHByZWZlcmVuY2VzOiB7fSB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgc2VydmljZS5lbWl0KHJlZ2lzdHJhdGlvbkV2ZW50KTtcbiAgICAgICAgYXdhaXQgc2VydmljZS5lbWl0KHZlcmlmaWNhdGlvbkV2ZW50KTtcbiAgICAgICAgYXdhaXQgc2VydmljZS5lbWl0KGNvbXBsZXRpb25FdmVudCk7XG4gICAgICAgIFxuICAgICAgICAvLyBWZXJpZnkgd29ya2Zsb3cgZXhlY3V0aW9uXG4gICAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIuZW1pdEFzeW5jKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoOSk7IC8vIDMgZXZlbnRzICogMyBwYXR0ZXJucyBlYWNoXG4gICAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIub24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygzKTsgLy8gMyBzdWJzY3JpcHRpb25zXG4gICAgICAgIFxuICAgICAgICAvLyBWZXJpZnkgY29ycmVsYXRpb24gSURzIGFyZSBtYWludGFpbmVkXG4gICAgICAgIGV4cGVjdChyZWdpc3RyYXRpb25FdmVudC5tZXRhZGF0YS5jb3JyZWxhdGlvbklkKS50b0JlKGNvcnJlbGF0aW9uSWQpO1xuICAgICAgICBleHBlY3QodmVyaWZpY2F0aW9uRXZlbnQubWV0YWRhdGEuY29ycmVsYXRpb25JZCkudG9CZShjb3JyZWxhdGlvbklkKTtcbiAgICAgICAgZXhwZWN0KGNvbXBsZXRpb25FdmVudC5tZXRhZGF0YS5jb3JyZWxhdGlvbklkKS50b0JlKGNvcnJlbGF0aW9uSWQpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIG9yZGVyIHByb2Nlc3Npbmcgd2l0aCBjb21wZW5zYXRpb24gZXZlbnRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBvcmRlcklkID0gJ29yZGVyLTc4OSc7XG4gICAgICAgIGNvbnN0IGNvcnJlbGF0aW9uSWQgPSAnb3JkZXItcHJvYy1jb3JyLTQ1Nic7XG4gICAgICAgIFxuICAgICAgICBjbGFzcyBPcmRlclBsYWNlZCBleHRlbmRzIEJhc2VEb21haW5FdmVudDx7IG9yZGVySWQ6IHN0cmluZzsgaXRlbXM6IGFueVtdOyB0b3RhbDogbnVtYmVyIH0+IHtcbiAgICAgICAgICBjb25zdHJ1Y3RvcihvcmRlcklkOiBzdHJpbmcsIGRhdGE6IHsgb3JkZXJJZDogc3RyaW5nOyBpdGVtczogYW55W107IHRvdGFsOiBudW1iZXIgfSkge1xuICAgICAgICAgICAgc3VwZXIob3JkZXJJZCwgJ09yZGVyJywgZGF0YSwgeyBjb3JyZWxhdGlvbklkIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY2xhc3MgUGF5bWVudEZhaWxlZCBleHRlbmRzIEJhc2VEb21haW5FdmVudDx7IG9yZGVySWQ6IHN0cmluZzsgcmVhc29uOiBzdHJpbmc7IGFtb3VudDogbnVtYmVyIH0+IHtcbiAgICAgICAgICBjb25zdHJ1Y3RvcihvcmRlcklkOiBzdHJpbmcsIGRhdGE6IHsgb3JkZXJJZDogc3RyaW5nOyByZWFzb246IHN0cmluZzsgYW1vdW50OiBudW1iZXIgfSkge1xuICAgICAgICAgICAgc3VwZXIob3JkZXJJZCwgJ1BheW1lbnQnLCBkYXRhLCB7IGNvcnJlbGF0aW9uSWQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjbGFzcyBPcmRlckNhbmNlbGxlZCBleHRlbmRzIEJhc2VEb21haW5FdmVudDx7IG9yZGVySWQ6IHN0cmluZzsgcmVhc29uOiBzdHJpbmc7IGNvbXBlbnNhdGlvbjogYW55IH0+IHtcbiAgICAgICAgICBjb25zdHJ1Y3RvcihvcmRlcklkOiBzdHJpbmcsIGRhdGE6IHsgb3JkZXJJZDogc3RyaW5nOyByZWFzb246IHN0cmluZzsgY29tcGVuc2F0aW9uOiBhbnkgfSkge1xuICAgICAgICAgICAgc3VwZXIob3JkZXJJZCwgJ09yZGVyJywgZGF0YSwgeyBjb3JyZWxhdGlvbklkIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU2V0IHVwIGNvbXBlbnNhdGlvbiBoYW5kbGVyc1xuICAgICAgICBjb25zdCBpbnZlbnRvcnlIYW5kbGVyID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbkhhbmRsZXIgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgcmVmdW5kSGFuZGxlciA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgICBcbiAgICAgICAgc2VydmljZS5zdWJzY3JpYmVUb0FnZ3JlZ2F0ZSgnT3JkZXInLCBpbnZlbnRvcnlIYW5kbGVyKTtcbiAgICAgICAgc2VydmljZS5zdWJzY3JpYmUoJ1BheW1lbnRGYWlsZWQnLCByZWZ1bmRIYW5kbGVyKTtcbiAgICAgICAgc2VydmljZS5zdWJzY3JpYmUoJ09yZGVyQ2FuY2VsbGVkJywgbm90aWZpY2F0aW9uSGFuZGxlcik7XG4gICAgICAgIFxuICAgICAgICBldmVudEVtaXR0ZXIuZW1pdEFzeW5jLm1vY2tSZXNvbHZlZFZhbHVlKFtdIGFzIGFueSk7XG4gICAgICAgIFxuICAgICAgICAvLyBFeGVjdXRlIG9yZGVyIHByb2Nlc3Npbmcgd2l0aCBjb21wZW5zYXRpb25cbiAgICAgICAgY29uc3Qgb3JkZXJFdmVudCA9IG5ldyBPcmRlclBsYWNlZChvcmRlcklkLCB7XG4gICAgICAgICAgb3JkZXJJZCxcbiAgICAgICAgICBpdGVtczogW3sgaWQ6ICdpdGVtLTEnLCBxdWFudGl0eTogMiB9XSxcbiAgICAgICAgICB0b3RhbDogOTkuOTlcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBwYXltZW50RmFpbGVkRXZlbnQgPSBuZXcgUGF5bWVudEZhaWxlZChvcmRlcklkLCB7XG4gICAgICAgICAgb3JkZXJJZCxcbiAgICAgICAgICByZWFzb246ICdJbnN1ZmZpY2llbnQgZnVuZHMnLFxuICAgICAgICAgIGFtb3VudDogOTkuOTlcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjb21wZW5zYXRpb25FdmVudCA9IG5ldyBPcmRlckNhbmNlbGxlZChvcmRlcklkLCB7XG4gICAgICAgICAgb3JkZXJJZCxcbiAgICAgICAgICByZWFzb246ICdQYXltZW50IGZhaWxlZCcsXG4gICAgICAgICAgY29tcGVuc2F0aW9uOiB7IGludmVudG9yeVJlbGVhc2VkOiB0cnVlLCByZWZ1bmRJbml0aWF0ZWQ6IHRydWUgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IHNlcnZpY2UuZW1pdChvcmRlckV2ZW50KTtcbiAgICAgICAgYXdhaXQgc2VydmljZS5lbWl0KHBheW1lbnRGYWlsZWRFdmVudCk7XG4gICAgICAgIGF3YWl0IHNlcnZpY2UuZW1pdChjb21wZW5zYXRpb25FdmVudCk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoZXZlbnRFbWl0dGVyLmVtaXRBc3luYykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDkpO1xuICAgICAgICBleHBlY3QoZXZlbnRFbWl0dGVyLm9uKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdFdmVudCBDb3JyZWxhdGlvbiBhbmQgVHJhY2luZycsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gZXZlbnQgY29ycmVsYXRpb24gYWNyb3NzIGNvbXBsZXggd29ya2Zsb3dzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBjb3JyZWxhdGlvbklkID0gJ2NvbXBsZXgtd29ya2Zsb3ctY29yci03ODknO1xuICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSAnc2Vzc2lvbi0xMjMnO1xuICAgICAgICBjb25zdCB1c2VySWQgPSAndXNlci00NTYnO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgZXZlbnRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAgfSwgKF8sIGkpID0+IFxuICAgICAgICAgIG5ldyBUZXN0RG9tYWluRXZlbnQoXG4gICAgICAgICAgICBgd29ya2Zsb3ctc3RlcC0ke2l9YCxcbiAgICAgICAgICAgIHsgXG4gICAgICAgICAgICAgIHRlc3Q6IGB3b3JrZmxvdy1zdGVwLSR7aX1gLFxuICAgICAgICAgICAgICBzdGVwTnVtYmVyOiBpLFxuICAgICAgICAgICAgICBwcmV2aW91c1N0ZXA6IGkgPiAwID8gYHdvcmtmbG93LXN0ZXAtJHtpLTF9YCA6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQsXG4gICAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgdXNlcklkLFxuICAgICAgICAgICAgICBjYXVzYXRpb25JZDogaSA+IDAgPyBgd29ya2Zsb3ctc3RlcC0ke2ktMX1gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGV2ZW50RW1pdHRlci5lbWl0QXN5bmMubW9ja1Jlc29sdmVkVmFsdWUoW10gYXMgYW55KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFByb2Nlc3Mgd29ya2Zsb3cgc2VxdWVudGlhbGx5IHRvIG1haW50YWluIGNhdXNhdGlvblxuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICAgIGF3YWl0IHNlcnZpY2UuZW1pdChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFZlcmlmeSBhbGwgZXZlbnRzIG1haW50YWluIGNvcnJlbGF0aW9uXG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKChldmVudCwgaSkgPT4ge1xuICAgICAgICAgIGV4cGVjdChldmVudC5tZXRhZGF0YS5jb3JyZWxhdGlvbklkKS50b0JlKGNvcnJlbGF0aW9uSWQpO1xuICAgICAgICAgIGV4cGVjdChldmVudC5tZXRhZGF0YS5zZXNzaW9uSWQpLnRvQmUoc2Vzc2lvbklkKTtcbiAgICAgICAgICBleHBlY3QoZXZlbnQubWV0YWRhdGEudXNlcklkKS50b0JlKHVzZXJJZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBleHBlY3QoZXZlbnQubWV0YWRhdGEuY2F1c2F0aW9uSWQpLnRvQmUoYHdvcmtmbG93LXN0ZXAtJHtpLTF9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIuZW1pdEFzeW5jKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMzApOyAvLyAxMCBldmVudHMgKiAzIHBhdHRlcm5zXG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXZlbnQgdHJhY2luZyB3aXRoIGRpc3RyaWJ1dGVkIHN5c3RlbSBzY2VuYXJpb3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRyYWNlSWQgPSAndHJhY2UtZGlzdHJpYnV0ZWQtYWJjMTIzJztcbiAgICAgICAgY29uc3Qgc2VydmljZUluc3RhbmNlcyA9IFsnYXBpLTEnLCAnYXBpLTInLCAnd29ya2VyLTEnLCAnd29ya2VyLTInXTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGRpc3RyaWJ1dGVkRXZlbnRzID0gc2VydmljZUluc3RhbmNlcy5mbGF0TWFwKChpbnN0YW5jZSwgc2VydmljZUluZGV4KSA9PiBcbiAgICAgICAgICBBcnJheS5mcm9tKHsgbGVuZ3RoOiAzIH0sIChfLCBldmVudEluZGV4KSA9PiBcbiAgICAgICAgICAgIG5ldyBUZXN0RG9tYWluRXZlbnQoXG4gICAgICAgICAgICAgIGAke2luc3RhbmNlfS1ldmVudC0ke2V2ZW50SW5kZXh9YCxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRlc3Q6IGBkaXN0cmlidXRlZC1ldmVudGAsXG4gICAgICAgICAgICAgICAgc2VydmljZUluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBldmVudFNlcXVlbmNlOiBldmVudEluZGV4LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29ycmVsYXRpb25JZDogdHJhY2VJZCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IGByZXEtJHtzZXJ2aWNlSW5kZXh9LSR7ZXZlbnRJbmRleH1gLFxuICAgICAgICAgICAgICAgIHVzZXJBZ2VudDogYFNlcnZpY2UvJHtpbnN0YW5jZX1gLFxuICAgICAgICAgICAgICAgIGlwQWRkcmVzczogYDEwLjAuJHtzZXJ2aWNlSW5kZXh9LiR7ZXZlbnRJbmRleCArIDF9YCxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGV2ZW50RW1pdHRlci5lbWl0QXN5bmMubW9ja1Jlc29sdmVkVmFsdWUoW10gYXMgYW55KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFByb2Nlc3MgZGlzdHJpYnV0ZWQgZXZlbnRzIGNvbmN1cnJlbnRseVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChkaXN0cmlidXRlZEV2ZW50cy5tYXAoZXZlbnQgPT4gc2VydmljZS5lbWl0KGV2ZW50KSkpO1xuICAgICAgICBcbiAgICAgICAgLy8gVmVyaWZ5IGRpc3RyaWJ1dGVkIHRyYWNpbmdcbiAgICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5lbWl0QXN5bmMpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygzNik7IC8vIDEyIGV2ZW50cyAqIDMgcGF0dGVybnNcbiAgICAgICAgXG4gICAgICAgIGRpc3RyaWJ1dGVkRXZlbnRzLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgIGV4cGVjdChldmVudC5tZXRhZGF0YS5jb3JyZWxhdGlvbklkKS50b0JlKHRyYWNlSWQpO1xuICAgICAgICAgIGV4cGVjdChldmVudC5tZXRhZGF0YS5yZXF1ZXN0SWQpLnRvTWF0Y2goL15yZXEtXFxkKy1cXGQrJC8pO1xuICAgICAgICAgIGV4cGVjdChldmVudC5tZXRhZGF0YS51c2VyQWdlbnQpLnRvTWF0Y2goL15TZXJ2aWNlXFwvKGFwaXx3b3JrZXIpLVxcZCskLyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNZW1vcnkgTWFuYWdlbWVudCBhbmQgQ2xlYW51cCcsICgpID0+IHtcbiAgICBkZXNjcmliZSgnRXZlbnQgSGFuZGxlciBNZW1vcnkgTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHN1YnNjcmlwdGlvbiBjbGVhbnVwIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBldmVudFR5cGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIChfLCBpKSA9PiBgRXZlbnRUeXBlJHtpfWApO1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMCB9LCAoXywgaSkgPT4gXG4gICAgICAgICAgamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBgaGFuZGxlci0ke2l9YClcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN1YnNjcmliZSBtYW55IGhhbmRsZXJzXG4gICAgICAgIGV2ZW50VHlwZXMuZm9yRWFjaCgoZXZlbnRUeXBlLCBpKSA9PiB7XG4gICAgICAgICAgc2VydmljZS5zdWJzY3JpYmUoZXZlbnRUeXBlLCBoYW5kbGVyc1tpXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5vbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEwMCk7XG4gICAgICAgIFxuICAgICAgICAvLyBVbnN1YnNjcmliZSBoYWxmIG9mIHRoZW1cbiAgICAgICAgZXZlbnRUeXBlcy5zbGljZSgwLCA1MCkuZm9yRWFjaCgoZXZlbnRUeXBlLCBpKSA9PiB7XG4gICAgICAgICAgc2VydmljZS51bnN1YnNjcmliZShldmVudFR5cGUsIGhhbmRsZXJzW2ldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoZXZlbnRFbWl0dGVyLm9mZikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDUwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciBzcGVjaWZpYyBldmVudCB0eXBlc1xuICAgICAgICBldmVudFR5cGVzLnNsaWNlKDUwLCA3NSkuZm9yRWFjaChldmVudFR5cGUgPT4ge1xuICAgICAgICAgIHNlcnZpY2UucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50VHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyNSk7XG4gICAgICAgIFxuICAgICAgICAvLyBHbG9iYWwgY2xlYW51cFxuICAgICAgICBzZXJ2aWNlLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMpLnRvSGF2ZUJlZW5MYXN0Q2FsbGVkV2l0aCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGxhcmdlLXNjYWxlIHN1YnNjcmlwdGlvbiBhbmQgY2xlYW51cCBjeWNsZXMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN5Y2xlcyA9IDEwO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zUGVyQ3ljbGUgPSA1MDtcbiAgICAgICAgXG4gICAgICAgIGZvciAobGV0IGN5Y2xlID0gMDsgY3ljbGUgPCBjeWNsZXM7IGN5Y2xlKyspIHtcbiAgICAgICAgICAvLyBTdWJzY3JpYmUgaGFuZGxlcnNcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1YnNjcmlwdGlvbnNQZXJDeWNsZTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFR5cGUgPSBgQ3ljbGUke2N5Y2xlfUV2ZW50JHtpfWA7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gamVzdC5mbigpO1xuICAgICAgICAgICAgc2VydmljZS5zdWJzY3JpYmUoZXZlbnRUeXBlLCBoYW5kbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2ltdWxhdGUgc29tZSBwcm9jZXNzaW5nIHRpbWVcbiAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgMSkge30gLy8gQnJpZWYgcHJvY2Vzc2luZ1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsZWFudXAgaGFsZiB0aGUgc3Vic2NyaXB0aW9uc1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3Vic2NyaXB0aW9uc1BlckN5Y2xlIC8gMjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFR5cGUgPSBgQ3ljbGUke2N5Y2xlfUV2ZW50JHtpfWA7XG4gICAgICAgICAgICBzZXJ2aWNlLnJlbW92ZUFsbExpc3RlbmVycyhldmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5vbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKGN5Y2xlcyAqIHN1YnNjcmlwdGlvbnNQZXJDeWNsZSk7XG4gICAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoY3ljbGVzICogc3Vic2NyaXB0aW9uc1BlckN5Y2xlIC8gMik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ludGVncmF0aW9uIFRlc3RzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbXBsZXRlIGV2ZW50IGZsb3cgd2l0aCBhZHZhbmNlZCBwYXR0ZXJucycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgIGNvbnN0IHRlc3RFdmVudCA9IG5ldyBUZXN0RG9tYWluRXZlbnQoJ2FnZ3JlZ2F0ZS0xJywge1xuICAgICAgICB0ZXN0OiAnaW50ZWdyYXRpb24tdGVzdCcsXG4gICAgICAgIGNvbXBsZXhEYXRhOiB7XG4gICAgICAgICAgbmVzdGVkT2JqZWN0OiB7IHZhbHVlOiAnbmVzdGVkJyB9LFxuICAgICAgICAgIGFycmF5RGF0YTogWzEsIDIsIDMsIDQsIDVdLFxuICAgICAgICAgIG1ldGFkYXRhOiB7IHZlcnNpb246IDIsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBldmVudEVtaXR0ZXIuZW1pdEFzeW5jLm1vY2tSZXNvbHZlZFZhbHVlKFtdIGFzIGFueSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgc2VydmljZS5zdWJzY3JpYmUoJ1Rlc3REb21haW5FdmVudCcsIGhhbmRsZXIpO1xuICAgICAgYXdhaXQgc2VydmljZS5lbWl0KHRlc3RFdmVudCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGV2ZW50RW1pdHRlci5vbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdUZXN0RG9tYWluRXZlbnQnLFxuICAgICAgICBleHBlY3QuYW55KEZ1bmN0aW9uKSxcbiAgICAgICk7XG4gICAgICBleHBlY3QoZXZlbnRFbWl0dGVyLmVtaXRBc3luYykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDMpO1xuICAgICAgZXhwZWN0KHNlcnZpY2VbJ2xvZ2dlciddLmRlYnVnKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ0VtaXR0aW5nIGV2ZW50JyksXG4gICAgICAgIGV4cGVjdC5hbnkoT2JqZWN0KSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBldmVudCBtZXRhZGF0YSBjb3JyZWN0bHkgd2l0aCBhbGwgZmllbGRzJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgY29tcGxldGVNZXRhZGF0YSA9IHtcbiAgICAgICAgdXNlcklkOiAndXNlci0xMjMnLFxuICAgICAgICBzZXNzaW9uSWQ6ICdzZXNzaW9uLTQ1NicsXG4gICAgICAgIGNvcnJlbGF0aW9uSWQ6ICdjb3JyLTc4OScsXG4gICAgICAgIGNhdXNhdGlvbklkOiAnY2F1c2UtMTAxJyxcbiAgICAgICAgdXNlclJvbGU6ICdhZG1pbicsXG4gICAgICAgIGlwQWRkcmVzczogJzE5Mi4xNjguMS4xMDAnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCBUZXN0IEJyb3dzZXInLFxuICAgICAgICByZXF1ZXN0SWQ6ICdyZXEtMTEyMjMzJyxcbiAgICAgIH07XG4gICAgICBjb25zdCB0ZXN0RXZlbnQgPSBuZXcgVGVzdERvbWFpbkV2ZW50KFxuICAgICAgICAnYWdncmVnYXRlLTEnLFxuICAgICAgICB7IHRlc3Q6ICdtZXRhZGF0YS10ZXN0JywgaW5jbHVkZUFsbDogdHJ1ZSB9LFxuICAgICAgICBjb21wbGV0ZU1ldGFkYXRhLFxuICAgICAgKTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCBldmVudE1ldGFkYXRhID0gdGVzdEV2ZW50Lm1ldGFkYXRhO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChldmVudE1ldGFkYXRhLnVzZXJJZCkudG9CZSgndXNlci0xMjMnKTtcbiAgICAgIGV4cGVjdChldmVudE1ldGFkYXRhLnNlc3Npb25JZCkudG9CZSgnc2Vzc2lvbi00NTYnKTtcbiAgICAgIGV4cGVjdChldmVudE1ldGFkYXRhLmNvcnJlbGF0aW9uSWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZXZlbnRNZXRhZGF0YS5jYXVzYXRpb25JZCkudG9CZSgnY2F1c2UtMTAxJyk7XG4gICAgICBleHBlY3QoZXZlbnRNZXRhZGF0YS51c2VyUm9sZSkudG9CZSgnYWRtaW4nKTtcbiAgICAgIGV4cGVjdChldmVudE1ldGFkYXRhLmlwQWRkcmVzcykudG9CZSgnMTkyLjE2OC4xLjEwMCcpO1xuICAgICAgZXhwZWN0KGV2ZW50TWV0YWRhdGEudXNlckFnZW50KS50b0JlKCdNb3ppbGxhLzUuMCBUZXN0IEJyb3dzZXInKTtcbiAgICAgIGV4cGVjdChldmVudE1ldGFkYXRhLnJlcXVlc3RJZCkudG9CZSgncmVxLTExMjIzMycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW5kLXRvLWVuZCBldmVudCBwcm9jZXNzaW5nIHdpdGggbXVsdGlwbGUgc3Vic2NyaWJlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBldmVudFR5cGUgPSAnQ29tcGxleFdvcmtmbG93RXZlbnQnO1xuICAgICAgY29uc3QgaGFuZGxlcnMgPSBbXG4gICAgICAgIGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnYXVkaXQtbG9nZ2VkJyksXG4gICAgICAgIGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnbm90aWZpY2F0aW9uLXNlbnQnKSxcbiAgICAgICAgamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKCdhbmFseXRpY3MtcmVjb3JkZWQnKSxcbiAgICAgICAgamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKCdjYWNoZS11cGRhdGVkJyksXG4gICAgICBdO1xuICAgICAgXG4gICAgICAvLyBTdWJzY3JpYmUgYWxsIGhhbmRsZXJzXG4gICAgICBoYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4gc2VydmljZS5zdWJzY3JpYmUoZXZlbnRUeXBlLCBoYW5kbGVyKSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHRlc3RFdmVudCA9IG5ldyBUZXN0RG9tYWluRXZlbnQoXG4gICAgICAgICd3b3JrZmxvdy1hZ2dyZWdhdGUnLFxuICAgICAgICB7XG4gICAgICAgICAgdGVzdDogJ2VuZC10by1lbmQtdGVzdCcsXG4gICAgICAgICAgd29ya2Zsb3dJZDogJ3dmLTEyMycsXG4gICAgICAgICAgZGF0YTogeyBhY3Rpb246ICdjb21wbGV0ZScsIHJlc3VsdDogJ3N1Y2Nlc3MnIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHVzZXJJZDogJ3VzZXItNzg5JyxcbiAgICAgICAgICBzZXNzaW9uSWQ6ICdzZXNzaW9uLWVuZC10by1lbmQnLFxuICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6ICdjb3JyLWVuZC10by1lbmQtMTIzJyxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgZXZlbnRFbWl0dGVyLmVtaXRBc3luYy5tb2NrUmVzb2x2ZWRWYWx1ZShbXSBhcyBhbnkpO1xuICAgICAgXG4gICAgICAvLyBFbWl0IGV2ZW50XG4gICAgICBhd2FpdCBzZXJ2aWNlLmVtaXQodGVzdEV2ZW50KTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgaGFuZGxlciBleGVjdXRpb25cbiAgICAgIGNvbnN0IHdyYXBwZWRIYW5kbGVycyA9IGV2ZW50RW1pdHRlci5vbi5tb2NrLmNhbGxzLm1hcChjYWxsID0+IGNhbGxbMV0pO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwod3JhcHBlZEhhbmRsZXJzLm1hcChoYW5kbGVyID0+IGhhbmRsZXIodGVzdEV2ZW50KSkpO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgY29tcGxldGUgd29ya2Zsb3dcbiAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIub24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyg0KTtcbiAgICAgIGV4cGVjdChldmVudEVtaXR0ZXIuZW1pdEFzeW5jKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7IC8vIHNwZWNpZmljLCB3aWxkY2FyZCwgYWdncmVnYXRlXG4gICAgICBoYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4ge1xuICAgICAgICBleHBlY3QoaGFuZGxlcikudG9IYXZlQmVlbkNhbGxlZFdpdGgodGVzdEV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBleHBlY3Qoc2VydmljZVsnbG9nZ2VyJ10uZGVidWcpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnRXZlbnQgZW1pdHRlZCBzdWNjZXNzZnVsbHk6IFRlc3REb21haW5FdmVudCdcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=