66183480d7f39a9e66f24991b6c0d269
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var MessageEncryptionService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageEncryptionService = void 0;
const common_1 = require("@nestjs/common");
const crypto = require("crypto");
let MessageEncryptionService = MessageEncryptionService_1 = class MessageEncryptionService {
    logger = new common_1.Logger(MessageEncryptionService_1.name);
    algorithm = 'aes-256-gcm';
    keyLength = 32; // 256 bits
    ivLength = 16; // 128 bits
    tagLength = 16; // 128 bits
    // In production, these should be loaded from secure key management service
    encryptionKeys = new Map();
    constructor() {
        this.initializeKeys();
    }
    /**
     * Initialize encryption keys for different conversation types
     * In production, integrate with AWS KMS, HashiCorp Vault, or similar
     */
    initializeKeys() {
        // Master key from environment (should be in secure key management)
        const masterKeyHex = process.env.MESSAGE_ENCRYPTION_KEY ||
            crypto.randomBytes(this.keyLength).toString('hex');
        // Derive keys for different conversation types
        this.encryptionKeys.set('default', Buffer.from(masterKeyHex, 'hex'));
        // Therapy conversations get their own key for extra security
        const therapyKey = this.deriveKey(masterKeyHex, 'therapy-conversations');
        this.encryptionKeys.set('therapy', therapyKey);
        // Support conversations
        const supportKey = this.deriveKey(masterKeyHex, 'support-conversations');
        this.encryptionKeys.set('support', supportKey);
        this.logger.log('Message encryption keys initialized');
    }
    /**
     * Derive a key from master key using PBKDF2
     */
    deriveKey(masterKey, salt) {
        return crypto.pbkdf2Sync(masterKey, salt, 100000, this.keyLength, 'sha512');
    }
    /**
     * Encrypt a message with AES-256-GCM
     */
    async encryptMessage(content, conversationType = 'default') {
        try {
            const key = this.encryptionKeys.get(conversationType) ||
                this.encryptionKeys.get('default');
            // Generate random IV for each message
            const iv = crypto.randomBytes(this.ivLength);
            // Create cipher
            const cipher = crypto.createCipheriv(this.algorithm, key, iv);
            // Encrypt the content
            let encrypted = cipher.update(content, 'utf8', 'hex');
            encrypted += cipher.final('hex');
            // Get authentication tag
            const authTag = cipher.getAuthTag();
            const result = {
                encryptedContent: encrypted,
                iv: iv.toString('hex'),
                authTag: authTag.toString('hex'),
                keyId: conversationType,
            };
            this.logger.debug(`Message encrypted with ${conversationType} key (length: ${content.length} chars)`);
            return result;
        }
        catch (error) {
            this.logger.error('Message encryption failed:', error);
            throw new Error('Failed to encrypt message');
        }
    }
    /**
     * Decrypt a message with AES-256-GCM
     */
    async decryptMessage(encryptedMessage) {
        try {
            const { encryptedContent, iv, authTag, keyId } = encryptedMessage;
            const key = this.encryptionKeys.get(keyId) || this.encryptionKeys.get('default');
            // Create decipher
            const decipher = crypto.createDecipheriv(this.algorithm, key, Buffer.from(iv, 'hex'));
            // Set auth tag
            decipher.setAuthTag(Buffer.from(authTag, 'hex'));
            // Decrypt the content
            let decrypted = decipher.update(encryptedContent, 'hex', 'utf8');
            decrypted += decipher.final('utf8');
            this.logger.debug(`Message decrypted with ${keyId} key (length: ${decrypted.length} chars)`);
            return {
                content: decrypted,
                decryptedAt: new Date(),
            };
        }
        catch (error) {
            this.logger.error('Message decryption failed:', error);
            throw new Error('Failed to decrypt message - content may be corrupted');
        }
    }
    /**
     * Determine conversation type for encryption key selection
     */
    getConversationType(conversationParticipants) {
        const hasTherapist = conversationParticipants.some((p) => p.role === 'therapist');
        const hasClient = conversationParticipants.some((p) => p.role === 'client');
        const hasModerator = conversationParticipants.some((p) => p.role === 'moderator');
        if (hasTherapist && hasClient) {
            return 'therapy'; // Therapeutic conversations need highest security
        }
        if (hasModerator) {
            return 'support'; // Support conversations
        }
        return 'default'; // Regular user conversations
    }
    /**
     * Rotate encryption keys (for security maintenance)
     */
    async rotateKeys() {
        this.logger.warn('Key rotation not implemented - should integrate with secure key management service');
        // TODO: Implement key rotation with proper key management service
        // 1. Generate new keys
        // 2. Re-encrypt recent messages with new keys
        // 3. Update key references
        // 4. Schedule old key cleanup
    }
    /**
     * Validate encrypted message integrity
     */
    async validateMessageIntegrity(encryptedMessage) {
        try {
            await this.decryptMessage(encryptedMessage);
            return true;
        }
        catch (error) {
            this.logger.warn('Message integrity validation failed:', error);
            return false;
        }
    }
    /**
     * Batch encrypt multiple messages (for migration or bulk operations)
     */
    async batchEncryptMessages(messages) {
        const results = [];
        for (const message of messages) {
            try {
                const encrypted = await this.encryptMessage(message.content, message.conversationType || 'default');
                results.push(encrypted);
            }
            catch (error) {
                this.logger.error('Batch encryption failed for message:', error);
                // Continue with other messages, don't fail the entire batch
                results.push({
                    encryptedContent: '',
                    iv: '',
                    authTag: '',
                    keyId: 'failed',
                });
            }
        }
        this.logger.log(`Batch encrypted ${results.length} messages`);
        return results;
    }
    /**
     * Check if encryption is properly configured
     */
    isEncryptionAvailable() {
        return this.encryptionKeys.size > 0 && this.encryptionKeys.has('default');
    }
    /**
     * Get encryption status for monitoring
     */
    getEncryptionStatus() {
        return {
            algorithm: this.algorithm,
            keyCount: this.encryptionKeys.size,
            availableKeyTypes: Array.from(this.encryptionKeys.keys()),
            isConfigured: this.isEncryptionAvailable(),
        };
    }
};
exports.MessageEncryptionService = MessageEncryptionService;
exports.MessageEncryptionService = MessageEncryptionService = MessageEncryptionService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [])
], MessageEncryptionService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvd2V0b29hL0RvY3VtZW50cy9jb2RlL3Byb2plY3RzL21lbnRhcmEvbWVudGFyYS1hcGkvc3JjL21lc3NhZ2luZy9zZXJ2aWNlcy9tZXNzYWdlLWVuY3J5cHRpb24uc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQW9EO0FBQ3BELGlDQUFpQztBQWUxQixJQUFNLHdCQUF3QixnQ0FBOUIsTUFBTSx3QkFBd0I7SUFDbEIsTUFBTSxHQUFHLElBQUksZUFBTSxDQUFDLDBCQUF3QixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ25ELFNBQVMsR0FBRyxhQUFhLENBQUM7SUFDMUIsU0FBUyxHQUFHLEVBQUUsQ0FBQyxDQUFDLFdBQVc7SUFDM0IsUUFBUSxHQUFHLEVBQUUsQ0FBQyxDQUFDLFdBQVc7SUFDMUIsU0FBUyxHQUFHLEVBQUUsQ0FBQyxDQUFDLFdBQVc7SUFFNUMsMkVBQTJFO0lBQzFELGNBQWMsR0FBRyxJQUFJLEdBQUcsRUFBa0IsQ0FBQztJQUU1RDtRQUNFLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUN4QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssY0FBYztRQUNwQixtRUFBbUU7UUFDbkUsTUFBTSxZQUFZLEdBQ2hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsc0JBQXNCO1lBQ2xDLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVyRCwrQ0FBK0M7UUFDL0MsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFFckUsNkRBQTZEO1FBQzdELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxFQUFFLHVCQUF1QixDQUFDLENBQUM7UUFDekUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FB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QUFNLENBQUMsS0FBSyxDQUFDLHNDQUFzQyxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUNqRSw0REFBNEQ7Z0JBQzVELE9BQU8sQ0FBQyxJQUFJLENBQUM7b0JBQ1gsZ0JBQWdCLEVBQUUsRUFBRTtvQkFDcEIsRUFBRSxFQUFFLEVBQUU7b0JBQ04sT0FBTyxFQUFFLEVBQUU7b0JBQ1gsS0FBSyxFQUFFLFFBQVE7aUJBQ2hCLENBQUMsQ0FBQztZQUNMLENBQUM7UUFDSCxDQUFDO1FBRUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLE9BQU8sQ0FBQyxNQUFNLFdBQVcsQ0FBQyxDQUFDO1FBQzlELE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFRDs7T0FFRztJQUNILHFCQUFxQjtRQUNuQixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUM1RSxDQUFDO0lBRUQ7O09BRUc7SUFDSCxtQkFBbUI7UUFDakIsT0FBTztZQUNMLFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUztZQUN6QixRQUFRLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJO1lBQ2xDLGlCQUFpQixFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUN6RCxZQUFZLEVBQUUsSUFBSSxDQUFDLHFCQUFxQixFQUFFO1NBQzNDLENBQUM7SUFDSixDQUFDO0NBQ0YsQ0FBQTtBQTFPWSw0REFBd0I7bUNBQXhCLHdCQUF3QjtJQURwQyxJQUFBLG1CQUFVLEdBQUU7O0dBQ0Esd0JBQXdCLENBME9wQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvaG9tZS93ZXRvb2EvRG9jdW1lbnRzL2NvZGUvcHJvamVjdHMvbWVudGFyYS9tZW50YXJhLWFwaS9zcmMvbWVzc2FnaW5nL3NlcnZpY2VzL21lc3NhZ2UtZW5jcnlwdGlvbi5zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIExvZ2dlciB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEVuY3J5cHRlZE1lc3NhZ2Uge1xuICBlbmNyeXB0ZWRDb250ZW50OiBzdHJpbmc7XG4gIGl2OiBzdHJpbmc7XG4gIGF1dGhUYWc6IHN0cmluZztcbiAga2V5SWQ6IHN0cmluZzsgLy8gRm9yIGtleSByb3RhdGlvblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlY3J5cHRlZE1lc3NhZ2Uge1xuICBjb250ZW50OiBzdHJpbmc7XG4gIGRlY3J5cHRlZEF0OiBEYXRlO1xufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTWVzc2FnZUVuY3J5cHRpb25TZXJ2aWNlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBsb2dnZXIgPSBuZXcgTG9nZ2VyKE1lc3NhZ2VFbmNyeXB0aW9uU2VydmljZS5uYW1lKTtcbiAgcHJpdmF0ZSByZWFkb25seSBhbGdvcml0aG0gPSAnYWVzLTI1Ni1nY20nO1xuICBwcml2YXRlIHJlYWRvbmx5IGtleUxlbmd0aCA9IDMyOyAvLyAyNTYgYml0c1xuICBwcml2YXRlIHJlYWRvbmx5IGl2TGVuZ3RoID0gMTY7IC8vIDEyOCBiaXRzXG4gIHByaXZhdGUgcmVhZG9ubHkgdGFnTGVuZ3RoID0gMTY7IC8vIDEyOCBiaXRzXG5cbiAgLy8gSW4gcHJvZHVjdGlvbiwgdGhlc2Ugc2hvdWxkIGJlIGxvYWRlZCBmcm9tIHNlY3VyZSBrZXkgbWFuYWdlbWVudCBzZXJ2aWNlXG4gIHByaXZhdGUgcmVhZG9ubHkgZW5jcnlwdGlvbktleXMgPSBuZXcgTWFwPHN0cmluZywgQnVmZmVyPigpO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZUtleXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGVuY3J5cHRpb24ga2V5cyBmb3IgZGlmZmVyZW50IGNvbnZlcnNhdGlvbiB0eXBlc1xuICAgKiBJbiBwcm9kdWN0aW9uLCBpbnRlZ3JhdGUgd2l0aCBBV1MgS01TLCBIYXNoaUNvcnAgVmF1bHQsIG9yIHNpbWlsYXJcbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUtleXMoKSB7XG4gICAgLy8gTWFzdGVyIGtleSBmcm9tIGVudmlyb25tZW50IChzaG91bGQgYmUgaW4gc2VjdXJlIGtleSBtYW5hZ2VtZW50KVxuICAgIGNvbnN0IG1hc3RlcktleUhleCA9XG4gICAgICBwcm9jZXNzLmVudi5NRVNTQUdFX0VOQ1JZUFRJT05fS0VZIHx8XG4gICAgICBjcnlwdG8ucmFuZG9tQnl0ZXModGhpcy5rZXlMZW5ndGgpLnRvU3RyaW5nKCdoZXgnKTtcblxuICAgIC8vIERlcml2ZSBrZXlzIGZvciBkaWZmZXJlbnQgY29udmVyc2F0aW9uIHR5cGVzXG4gICAgdGhpcy5lbmNyeXB0aW9uS2V5cy5zZXQoJ2RlZmF1bHQnLCBCdWZmZXIuZnJvbShtYXN0ZXJLZXlIZXgsICdoZXgnKSk7XG5cbiAgICAvLyBUaGVyYXB5IGNvbnZlcnNhdGlvbnMgZ2V0IHRoZWlyIG93biBrZXkgZm9yIGV4dHJhIHNlY3VyaXR5XG4gICAgY29uc3QgdGhlcmFweUtleSA9IHRoaXMuZGVyaXZlS2V5KG1hc3RlcktleUhleCwgJ3RoZXJhcHktY29udmVyc2F0aW9ucycpO1xuICAgIHRoaXMuZW5jcnlwdGlvbktleXMuc2V0KCd0aGVyYXB5JywgdGhlcmFweUtleSk7XG5cbiAgICAvLyBTdXBwb3J0IGNvbnZlcnNhdGlvbnNcbiAgICBjb25zdCBzdXBwb3J0S2V5ID0gdGhpcy5kZXJpdmVLZXkobWFzdGVyS2V5SGV4LCAnc3VwcG9ydC1jb252ZXJzYXRpb25zJyk7XG4gICAgdGhpcy5lbmNyeXB0aW9uS2V5cy5zZXQoJ3N1cHBvcnQnLCBzdXBwb3J0S2V5KTtcblxuICAgIHRoaXMubG9nZ2VyLmxvZygnTWVzc2FnZSBlbmNyeXB0aW9uIGtleXMgaW5pdGlhbGl6ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJpdmUgYSBrZXkgZnJvbSBtYXN0ZXIga2V5IHVzaW5nIFBCS0RGMlxuICAgKi9cbiAgcHJpdmF0ZSBkZXJpdmVLZXkobWFzdGVyS2V5OiBzdHJpbmcsIHNhbHQ6IHN0cmluZyk6IEJ1ZmZlciB7XG4gICAgcmV0dXJuIGNyeXB0by5wYmtkZjJTeW5jKG1hc3RlcktleSwgc2FsdCwgMTAwMDAwLCB0aGlzLmtleUxlbmd0aCwgJ3NoYTUxMicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY3J5cHQgYSBtZXNzYWdlIHdpdGggQUVTLTI1Ni1HQ01cbiAgICovXG4gIGFzeW5jIGVuY3J5cHRNZXNzYWdlKFxuICAgIGNvbnRlbnQ6IHN0cmluZyxcbiAgICBjb252ZXJzYXRpb25UeXBlOiAndGhlcmFweScgfCAnc3VwcG9ydCcgfCAnZGVmYXVsdCcgPSAnZGVmYXVsdCcsXG4gICk6IFByb21pc2U8RW5jcnlwdGVkTWVzc2FnZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXkgPVxuICAgICAgICB0aGlzLmVuY3J5cHRpb25LZXlzLmdldChjb252ZXJzYXRpb25UeXBlKSB8fFxuICAgICAgICB0aGlzLmVuY3J5cHRpb25LZXlzLmdldCgnZGVmYXVsdCcpITtcblxuICAgICAgLy8gR2VuZXJhdGUgcmFuZG9tIElWIGZvciBlYWNoIG1lc3NhZ2VcbiAgICAgIGNvbnN0IGl2ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKHRoaXMuaXZMZW5ndGgpO1xuXG4gICAgICAvLyBDcmVhdGUgY2lwaGVyXG4gICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYodGhpcy5hbGdvcml0aG0sIGtleSwgaXYpO1xuXG4gICAgICAvLyBFbmNyeXB0IHRoZSBjb250ZW50XG4gICAgICBsZXQgZW5jcnlwdGVkID0gY2lwaGVyLnVwZGF0ZShjb250ZW50LCAndXRmOCcsICdoZXgnKTtcbiAgICAgIGVuY3J5cHRlZCArPSBjaXBoZXIuZmluYWwoJ2hleCcpO1xuXG4gICAgICAvLyBHZXQgYXV0aGVudGljYXRpb24gdGFnXG4gICAgICBjb25zdCBhdXRoVGFnID0gY2lwaGVyLmdldEF1dGhUYWcoKTtcblxuICAgICAgY29uc3QgcmVzdWx0OiBFbmNyeXB0ZWRNZXNzYWdlID0ge1xuICAgICAgICBlbmNyeXB0ZWRDb250ZW50OiBlbmNyeXB0ZWQsXG4gICAgICAgIGl2OiBpdi50b1N0cmluZygnaGV4JyksXG4gICAgICAgIGF1dGhUYWc6IGF1dGhUYWcudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICBrZXlJZDogY29udmVyc2F0aW9uVHlwZSxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICBgTWVzc2FnZSBlbmNyeXB0ZWQgd2l0aCAke2NvbnZlcnNhdGlvblR5cGV9IGtleSAobGVuZ3RoOiAke2NvbnRlbnQubGVuZ3RofSBjaGFycylgLFxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ01lc3NhZ2UgZW5jcnlwdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZW5jcnlwdCBtZXNzYWdlJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlY3J5cHQgYSBtZXNzYWdlIHdpdGggQUVTLTI1Ni1HQ01cbiAgICovXG4gIGFzeW5jIGRlY3J5cHRNZXNzYWdlKFxuICAgIGVuY3J5cHRlZE1lc3NhZ2U6IEVuY3J5cHRlZE1lc3NhZ2UsXG4gICk6IFByb21pc2U8RGVjcnlwdGVkTWVzc2FnZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVuY3J5cHRlZENvbnRlbnQsIGl2LCBhdXRoVGFnLCBrZXlJZCB9ID0gZW5jcnlwdGVkTWVzc2FnZTtcblxuICAgICAgY29uc3Qga2V5ID1cbiAgICAgICAgdGhpcy5lbmNyeXB0aW9uS2V5cy5nZXQoa2V5SWQpIHx8IHRoaXMuZW5jcnlwdGlvbktleXMuZ2V0KCdkZWZhdWx0JykhO1xuXG4gICAgICAvLyBDcmVhdGUgZGVjaXBoZXJcbiAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoXG4gICAgICAgIHRoaXMuYWxnb3JpdGhtLFxuICAgICAgICBrZXksXG4gICAgICAgIEJ1ZmZlci5mcm9tKGl2LCAnaGV4JyksXG4gICAgICApO1xuXG4gICAgICAvLyBTZXQgYXV0aCB0YWdcbiAgICAgIGRlY2lwaGVyLnNldEF1dGhUYWcoQnVmZmVyLmZyb20oYXV0aFRhZywgJ2hleCcpKTtcblxuICAgICAgLy8gRGVjcnlwdCB0aGUgY29udGVudFxuICAgICAgbGV0IGRlY3J5cHRlZCA9IGRlY2lwaGVyLnVwZGF0ZShlbmNyeXB0ZWRDb250ZW50LCAnaGV4JywgJ3V0ZjgnKTtcbiAgICAgIGRlY3J5cHRlZCArPSBkZWNpcGhlci5maW5hbCgndXRmOCcpO1xuXG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgYE1lc3NhZ2UgZGVjcnlwdGVkIHdpdGggJHtrZXlJZH0ga2V5IChsZW5ndGg6ICR7ZGVjcnlwdGVkLmxlbmd0aH0gY2hhcnMpYCxcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnQ6IGRlY3J5cHRlZCxcbiAgICAgICAgZGVjcnlwdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcignTWVzc2FnZSBkZWNyeXB0aW9uIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWNyeXB0IG1lc3NhZ2UgLSBjb250ZW50IG1heSBiZSBjb3JydXB0ZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGNvbnZlcnNhdGlvbiB0eXBlIGZvciBlbmNyeXB0aW9uIGtleSBzZWxlY3Rpb25cbiAgICovXG4gIGdldENvbnZlcnNhdGlvblR5cGUoXG4gICAgY29udmVyc2F0aW9uUGFydGljaXBhbnRzOiB7IHJvbGU6IHN0cmluZyB9W10sXG4gICk6ICd0aGVyYXB5JyB8ICdzdXBwb3J0JyB8ICdkZWZhdWx0JyB7XG4gICAgY29uc3QgaGFzVGhlcmFwaXN0ID0gY29udmVyc2F0aW9uUGFydGljaXBhbnRzLnNvbWUoXG4gICAgICAocCkgPT4gcC5yb2xlID09PSAndGhlcmFwaXN0JyxcbiAgICApO1xuICAgIGNvbnN0IGhhc0NsaWVudCA9IGNvbnZlcnNhdGlvblBhcnRpY2lwYW50cy5zb21lKChwKSA9PiBwLnJvbGUgPT09ICdjbGllbnQnKTtcbiAgICBjb25zdCBoYXNNb2RlcmF0b3IgPSBjb252ZXJzYXRpb25QYXJ0aWNpcGFudHMuc29tZShcbiAgICAgIChwKSA9PiBwLnJvbGUgPT09ICdtb2RlcmF0b3InLFxuICAgICk7XG5cbiAgICBpZiAoaGFzVGhlcmFwaXN0ICYmIGhhc0NsaWVudCkge1xuICAgICAgcmV0dXJuICd0aGVyYXB5JzsgLy8gVGhlcmFwZXV0aWMgY29udmVyc2F0aW9ucyBuZWVkIGhpZ2hlc3Qgc2VjdXJpdHlcbiAgICB9XG5cbiAgICBpZiAoaGFzTW9kZXJhdG9yKSB7XG4gICAgICByZXR1cm4gJ3N1cHBvcnQnOyAvLyBTdXBwb3J0IGNvbnZlcnNhdGlvbnNcbiAgICB9XG5cbiAgICByZXR1cm4gJ2RlZmF1bHQnOyAvLyBSZWd1bGFyIHVzZXIgY29udmVyc2F0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIFJvdGF0ZSBlbmNyeXB0aW9uIGtleXMgKGZvciBzZWN1cml0eSBtYWludGVuYW5jZSlcbiAgICovXG4gIGFzeW5jIHJvdGF0ZUtleXMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICdLZXkgcm90YXRpb24gbm90IGltcGxlbWVudGVkIC0gc2hvdWxkIGludGVncmF0ZSB3aXRoIHNlY3VyZSBrZXkgbWFuYWdlbWVudCBzZXJ2aWNlJyxcbiAgICApO1xuICAgIC8vIFRPRE86IEltcGxlbWVudCBrZXkgcm90YXRpb24gd2l0aCBwcm9wZXIga2V5IG1hbmFnZW1lbnQgc2VydmljZVxuICAgIC8vIDEuIEdlbmVyYXRlIG5ldyBrZXlzXG4gICAgLy8gMi4gUmUtZW5jcnlwdCByZWNlbnQgbWVzc2FnZXMgd2l0aCBuZXcga2V5c1xuICAgIC8vIDMuIFVwZGF0ZSBrZXkgcmVmZXJlbmNlc1xuICAgIC8vIDQuIFNjaGVkdWxlIG9sZCBrZXkgY2xlYW51cFxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGVuY3J5cHRlZCBtZXNzYWdlIGludGVncml0eVxuICAgKi9cbiAgYXN5bmMgdmFsaWRhdGVNZXNzYWdlSW50ZWdyaXR5KFxuICAgIGVuY3J5cHRlZE1lc3NhZ2U6IEVuY3J5cHRlZE1lc3NhZ2UsXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmRlY3J5cHRNZXNzYWdlKGVuY3J5cHRlZE1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ01lc3NhZ2UgaW50ZWdyaXR5IHZhbGlkYXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQmF0Y2ggZW5jcnlwdCBtdWx0aXBsZSBtZXNzYWdlcyAoZm9yIG1pZ3JhdGlvbiBvciBidWxrIG9wZXJhdGlvbnMpXG4gICAqL1xuICBhc3luYyBiYXRjaEVuY3J5cHRNZXNzYWdlcyhcbiAgICBtZXNzYWdlczoge1xuICAgICAgY29udGVudDogc3RyaW5nO1xuICAgICAgY29udmVyc2F0aW9uVHlwZT86ICd0aGVyYXB5JyB8ICdzdXBwb3J0JyB8ICdkZWZhdWx0JztcbiAgICB9W10sXG4gICk6IFByb21pc2U8RW5jcnlwdGVkTWVzc2FnZVtdPiB7XG4gICAgY29uc3QgcmVzdWx0czogRW5jcnlwdGVkTWVzc2FnZVtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGF3YWl0IHRoaXMuZW5jcnlwdE1lc3NhZ2UoXG4gICAgICAgICAgbWVzc2FnZS5jb250ZW50LFxuICAgICAgICAgIG1lc3NhZ2UuY29udmVyc2F0aW9uVHlwZSB8fCAnZGVmYXVsdCcsXG4gICAgICAgICk7XG4gICAgICAgIHJlc3VsdHMucHVzaChlbmNyeXB0ZWQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0JhdGNoIGVuY3J5cHRpb24gZmFpbGVkIGZvciBtZXNzYWdlOicsIGVycm9yKTtcbiAgICAgICAgLy8gQ29udGludWUgd2l0aCBvdGhlciBtZXNzYWdlcywgZG9uJ3QgZmFpbCB0aGUgZW50aXJlIGJhdGNoXG4gICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgZW5jcnlwdGVkQ29udGVudDogJycsXG4gICAgICAgICAgaXY6ICcnLFxuICAgICAgICAgIGF1dGhUYWc6ICcnLFxuICAgICAgICAgIGtleUlkOiAnZmFpbGVkJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sb2dnZXIubG9nKGBCYXRjaCBlbmNyeXB0ZWQgJHtyZXN1bHRzLmxlbmd0aH0gbWVzc2FnZXNgKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBlbmNyeXB0aW9uIGlzIHByb3Blcmx5IGNvbmZpZ3VyZWRcbiAgICovXG4gIGlzRW5jcnlwdGlvbkF2YWlsYWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uS2V5cy5zaXplID4gMCAmJiB0aGlzLmVuY3J5cHRpb25LZXlzLmhhcygnZGVmYXVsdCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBlbmNyeXB0aW9uIHN0YXR1cyBmb3IgbW9uaXRvcmluZ1xuICAgKi9cbiAgZ2V0RW5jcnlwdGlvblN0YXR1cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWxnb3JpdGhtOiB0aGlzLmFsZ29yaXRobSxcbiAgICAgIGtleUNvdW50OiB0aGlzLmVuY3J5cHRpb25LZXlzLnNpemUsXG4gICAgICBhdmFpbGFibGVLZXlUeXBlczogQXJyYXkuZnJvbSh0aGlzLmVuY3J5cHRpb25LZXlzLmtleXMoKSksXG4gICAgICBpc0NvbmZpZ3VyZWQ6IHRoaXMuaXNFbmNyeXB0aW9uQXZhaWxhYmxlKCksXG4gICAgfTtcbiAgfVxufVxuIl0sInZlcnNpb24iOjN9