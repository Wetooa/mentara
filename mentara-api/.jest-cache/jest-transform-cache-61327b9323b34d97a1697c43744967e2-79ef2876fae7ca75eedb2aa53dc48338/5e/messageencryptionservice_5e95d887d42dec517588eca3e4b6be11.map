{"file":"/home/wetooa/Documents/code/projects/mentara/mentara-api/src/messaging/services/message-encryption.service.ts","mappings":"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","names":[],"sources":["/home/wetooa/Documents/code/projects/mentara/mentara-api/src/messaging/services/message-encryption.service.ts"],"sourcesContent":["import { Injectable, Logger } from '@nestjs/common';\nimport * as crypto from 'crypto';\n\nexport interface EncryptedMessage {\n  encryptedContent: string;\n  iv: string;\n  authTag: string;\n  keyId: string; // For key rotation\n}\n\nexport interface DecryptedMessage {\n  content: string;\n  decryptedAt: Date;\n}\n\n@Injectable()\nexport class MessageEncryptionService {\n  private readonly logger = new Logger(MessageEncryptionService.name);\n  private readonly algorithm = 'aes-256-gcm';\n  private readonly keyLength = 32; // 256 bits\n  private readonly ivLength = 16; // 128 bits\n  private readonly tagLength = 16; // 128 bits\n\n  // In production, these should be loaded from secure key management service\n  private readonly encryptionKeys = new Map<string, Buffer>();\n\n  constructor() {\n    this.initializeKeys();\n  }\n\n  /**\n   * Initialize encryption keys for different conversation types\n   * In production, integrate with AWS KMS, HashiCorp Vault, or similar\n   */\n  private initializeKeys() {\n    // Master key from environment (should be in secure key management)\n    const masterKeyHex =\n      process.env.MESSAGE_ENCRYPTION_KEY ||\n      crypto.randomBytes(this.keyLength).toString('hex');\n\n    // Derive keys for different conversation types\n    this.encryptionKeys.set('default', Buffer.from(masterKeyHex, 'hex'));\n\n    // Therapy conversations get their own key for extra security\n    const therapyKey = this.deriveKey(masterKeyHex, 'therapy-conversations');\n    this.encryptionKeys.set('therapy', therapyKey);\n\n    // Support conversations\n    const supportKey = this.deriveKey(masterKeyHex, 'support-conversations');\n    this.encryptionKeys.set('support', supportKey);\n\n    this.logger.log('Message encryption keys initialized');\n  }\n\n  /**\n   * Derive a key from master key using PBKDF2\n   */\n  private deriveKey(masterKey: string, salt: string): Buffer {\n    return crypto.pbkdf2Sync(masterKey, salt, 100000, this.keyLength, 'sha512');\n  }\n\n  /**\n   * Encrypt a message with AES-256-GCM\n   */\n  async encryptMessage(\n    content: string,\n    conversationType: 'therapy' | 'support' | 'default' = 'default',\n  ): Promise<EncryptedMessage> {\n    try {\n      const key =\n        this.encryptionKeys.get(conversationType) ||\n        this.encryptionKeys.get('default')!;\n\n      // Generate random IV for each message\n      const iv = crypto.randomBytes(this.ivLength);\n\n      // Create cipher\n      const cipher = crypto.createCipheriv(this.algorithm, key, iv);\n\n      // Encrypt the content\n      let encrypted = cipher.update(content, 'utf8', 'hex');\n      encrypted += cipher.final('hex');\n\n      // Get authentication tag\n      const authTag = cipher.getAuthTag();\n\n      const result: EncryptedMessage = {\n        encryptedContent: encrypted,\n        iv: iv.toString('hex'),\n        authTag: authTag.toString('hex'),\n        keyId: conversationType,\n      };\n\n      this.logger.debug(\n        `Message encrypted with ${conversationType} key (length: ${content.length} chars)`,\n      );\n\n      return result;\n    } catch (error) {\n      this.logger.error('Message encryption failed:', error);\n      throw new Error('Failed to encrypt message');\n    }\n  }\n\n  /**\n   * Decrypt a message with AES-256-GCM\n   */\n  async decryptMessage(\n    encryptedMessage: EncryptedMessage,\n  ): Promise<DecryptedMessage> {\n    try {\n      const { encryptedContent, iv, authTag, keyId } = encryptedMessage;\n\n      const key =\n        this.encryptionKeys.get(keyId) || this.encryptionKeys.get('default')!;\n\n      // Create decipher\n      const decipher = crypto.createDecipheriv(\n        this.algorithm,\n        key,\n        Buffer.from(iv, 'hex'),\n      );\n\n      // Set auth tag\n      decipher.setAuthTag(Buffer.from(authTag, 'hex'));\n\n      // Decrypt the content\n      let decrypted = decipher.update(encryptedContent, 'hex', 'utf8');\n      decrypted += decipher.final('utf8');\n\n      this.logger.debug(\n        `Message decrypted with ${keyId} key (length: ${decrypted.length} chars)`,\n      );\n\n      return {\n        content: decrypted,\n        decryptedAt: new Date(),\n      };\n    } catch (error) {\n      this.logger.error('Message decryption failed:', error);\n      throw new Error('Failed to decrypt message - content may be corrupted');\n    }\n  }\n\n  /**\n   * Determine conversation type for encryption key selection\n   */\n  getConversationType(\n    conversationParticipants: { role: string }[],\n  ): 'therapy' | 'support' | 'default' {\n    const hasTherapist = conversationParticipants.some(\n      (p) => p.role === 'therapist',\n    );\n    const hasClient = conversationParticipants.some((p) => p.role === 'client');\n    const hasModerator = conversationParticipants.some(\n      (p) => p.role === 'moderator',\n    );\n\n    if (hasTherapist && hasClient) {\n      return 'therapy'; // Therapeutic conversations need highest security\n    }\n\n    if (hasModerator) {\n      return 'support'; // Support conversations\n    }\n\n    return 'default'; // Regular user conversations\n  }\n\n  /**\n   * Rotate encryption keys (for security maintenance)\n   */\n  async rotateKeys(): Promise<void> {\n    this.logger.warn(\n      'Key rotation not implemented - should integrate with secure key management service',\n    );\n    // TODO: Implement key rotation with proper key management service\n    // 1. Generate new keys\n    // 2. Re-encrypt recent messages with new keys\n    // 3. Update key references\n    // 4. Schedule old key cleanup\n  }\n\n  /**\n   * Validate encrypted message integrity\n   */\n  async validateMessageIntegrity(\n    encryptedMessage: EncryptedMessage,\n  ): Promise<boolean> {\n    try {\n      await this.decryptMessage(encryptedMessage);\n      return true;\n    } catch (error) {\n      this.logger.warn('Message integrity validation failed:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Batch encrypt multiple messages (for migration or bulk operations)\n   */\n  async batchEncryptMessages(\n    messages: {\n      content: string;\n      conversationType?: 'therapy' | 'support' | 'default';\n    }[],\n  ): Promise<EncryptedMessage[]> {\n    const results: EncryptedMessage[] = [];\n\n    for (const message of messages) {\n      try {\n        const encrypted = await this.encryptMessage(\n          message.content,\n          message.conversationType || 'default',\n        );\n        results.push(encrypted);\n      } catch (error) {\n        this.logger.error('Batch encryption failed for message:', error);\n        // Continue with other messages, don't fail the entire batch\n        results.push({\n          encryptedContent: '',\n          iv: '',\n          authTag: '',\n          keyId: 'failed',\n        });\n      }\n    }\n\n    this.logger.log(`Batch encrypted ${results.length} messages`);\n    return results;\n  }\n\n  /**\n   * Check if encryption is properly configured\n   */\n  isEncryptionAvailable(): boolean {\n    return this.encryptionKeys.size > 0 && this.encryptionKeys.has('default');\n  }\n\n  /**\n   * Get encryption status for monitoring\n   */\n  getEncryptionStatus() {\n    return {\n      algorithm: this.algorithm,\n      keyCount: this.encryptionKeys.size,\n      availableKeyTypes: Array.from(this.encryptionKeys.keys()),\n      isConfigured: this.isEncryptionAvailable(),\n    };\n  }\n}\n"],"version":3}