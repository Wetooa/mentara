{"file":"/home/wetooa/Documents/code/projects/mentara/mentara-api/src/messaging/services/websocket-auth.service.ts","mappings":"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","names":[],"sources":["/home/wetooa/Documents/code/projects/mentara/mentara-api/src/messaging/services/websocket-auth.service.ts"],"sourcesContent":["import { Injectable, Logger } from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { PrismaService } from 'src/providers/prisma-client.provider';\nimport { Socket } from 'socket.io';\nimport { WsException } from '@nestjs/websockets';\n\nexport interface AuthenticatedUser {\n  userId: string;\n  role?: string;\n}\n\n@Injectable()\nexport class WebSocketAuthService {\n  private readonly logger = new Logger(WebSocketAuthService.name);\n\n  constructor(\n    private readonly jwtService: JwtService,\n    private readonly prisma: PrismaService,\n  ) {}\n\n  async authenticateSocket(socket: Socket): Promise<AuthenticatedUser | null> {\n    try {\n      // Extract token from various sources\n      const token = this.extractToken(socket);\n\n      if (!token) {\n        this.logger.warn(`Socket ${socket.id} connected without valid token`);\n        return null;\n      }\n\n      // Verify JWT token\n      const payload = this.jwtService.verify(token);\n\n      if (!payload.sub) {\n        this.logger.warn(`Socket ${socket.id} has invalid token payload`);\n        return null;\n      }\n\n      // Validate user exists in database and is not deactivated\n      const user = await this.prisma.user.findUnique({\n        where: {\n          id: payload.sub,\n          deactivatedAt: null,\n        },\n        select: {\n          id: true,\n          role: true,\n          emailVerified: true,\n        },\n      });\n\n      if (!user) {\n        this.logger.warn(`Socket ${socket.id} user not found or deactivated`);\n        return null;\n      }\n\n      this.logger.log(\n        `Socket ${socket.id} authenticated as user ${user.id} with role ${user.role}`,\n      );\n\n      return {\n        userId: user.id,\n        role: user.role,\n      };\n    } catch (error) {\n      this.logger.error(\n        `Socket ${socket.id} authentication failed:`,\n        error instanceof Error ? error.message : error,\n      );\n      return null;\n    }\n  }\n\n  private extractToken(socket: Socket): string | null {\n    // Try different token sources in order of preference\n\n    // 1. Authorization header (Bearer token)\n    const authHeader = socket.handshake.headers.authorization;\n    if (\n      authHeader &&\n      typeof authHeader === 'string' &&\n      authHeader.startsWith('Bearer ')\n    ) {\n      const token = authHeader.substring(7).trim();\n      return token.length > 0 ? token : null;\n    }\n\n    // 2. Auth object in handshake\n    const authToken = socket.handshake.auth?.token;\n    if (authToken && typeof authToken === 'string') {\n      return authToken;\n    }\n\n    // 3. Query parameter\n    const queryToken = socket.handshake.query?.token;\n    if (queryToken && typeof queryToken === 'string') {\n      return queryToken;\n    }\n\n    // 4. Cookie (for browser connections)\n    const cookies = socket.handshake.headers.cookie;\n    if (cookies) {\n      const sessionCookie = this.extractCookieValue(cookies, '__session');\n      if (sessionCookie) {\n        return sessionCookie;\n      }\n    }\n\n    return null;\n  }\n\n  private extractCookieValue(cookies: string, name: string): string | null {\n    try {\n      // Escape special regex characters in cookie name\n      const escapedName = name.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n      const match = cookies.match(new RegExp(`(^| )${escapedName}=([^;]+)`));\n      if (match && match[2]) {\n        return decodeURIComponent(match[2]);\n      }\n      return null;\n    } catch (error) {\n      this.logger.warn(`Failed to extract cookie value for ${name}:`, error);\n      return null;\n    }\n  }\n\n  async validateToken(token: string): Promise<boolean> {\n    try {\n      // Simply verify if the JWT token is valid\n      const payload = this.jwtService.verify(token);\n\n      // Additional validation: check if user still exists and is active\n      const user = await this.prisma.user.findUnique({\n        where: {\n          id: payload.sub,\n          deactivatedAt: null,\n        },\n        select: { id: true },\n      });\n\n      return !!user;\n    } catch (error) {\n      this.logger.warn('Token validation failed:', error);\n      return false;\n    }\n  }\n}\n"],"version":3}