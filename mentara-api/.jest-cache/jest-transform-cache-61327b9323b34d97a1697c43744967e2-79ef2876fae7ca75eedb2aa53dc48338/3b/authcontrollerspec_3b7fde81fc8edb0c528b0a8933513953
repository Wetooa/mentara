0c031f23c00a878ecd71cad050cf8dab
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const testing_1 = require("@nestjs/testing");
const common_1 = require("@nestjs/common");
const auth_controller_1 = require("./auth.controller");
const auth_service_1 = require("./auth.service");
const prisma_client_provider_1 = require("../providers/prisma-client.provider");
const test_utils_1 = require("../test-utils");
const enhanced_test_helpers_1 = require("../test-utils/enhanced-test-helpers");
describe('AuthController', () => {
    let controller;
    let authService;
    const mockAuthService = {
        registerClient: jest.fn(),
        registerTherapist: jest.fn(),
        getUsers: jest.fn(),
        getUser: jest.fn(),
        forceLogout: jest.fn(),
    };
    beforeEach(async () => {
        const mockPrisma = (0, test_utils_1.createMockPrismaService)();
        const module = await testing_1.Test.createTestingModule({
            controllers: [auth_controller_1.AuthController],
            providers: [
                {
                    provide: auth_service_1.AuthService,
                    useValue: mockAuthService,
                },
                {
                    provide: prisma_client_provider_1.PrismaService,
                    useValue: mockPrisma,
                },
            ],
        }).compile();
        controller = module.get(auth_controller_1.AuthController);
        authService = module.get(auth_service_1.AuthService);
        // Reset all mocks before each test
        jest.clearAllMocks();
    });
    describe('basic functionality', () => {
        it('should be defined', () => {
            expect(controller).toBeDefined();
        });
        it('should have authService injected', () => {
            expect(authService).toBeDefined();
        });
    });
    describe('registerClient', () => {
        const mockClientData = {
            user: {
                firstName: 'John',
                lastName: 'Doe',
                email: 'john.doe@example.com',
                mobile: '+1234567890',
                address: '123 Main St',
                birthDate: '1990-01-01',
            },
            hasSeenTherapistRecommendations: false,
        };
        it('should successfully register a client', async () => {
            const expectedResult = {
                id: test_utils_1.TEST_USER_IDS.CLIENT,
                ...mockClientData,
                createdAt: new Date(),
                updatedAt: new Date(),
            };
            authService.registerClient.mockResolvedValue(expectedResult);
            const result = await controller.registerClient(test_utils_1.TEST_USER_IDS.CLIENT, mockClientData);
            expect(authService.registerClient).toHaveBeenCalledWith(test_utils_1.TEST_USER_IDS.CLIENT, mockClientData);
            expect(result).toEqual(expectedResult);
        });
        it('should handle registration conflict', async () => {
            authService.registerClient.mockRejectedValue(new common_1.ConflictException('User already exists'));
            await expect(controller.registerClient(test_utils_1.TEST_USER_IDS.CLIENT, mockClientData)).rejects.toThrow(common_1.ConflictException);
        });
    });
    describe('registerTherapist', () => {
        const mockTherapistData = {
            user: {
                firstName: 'Dr. Jane',
                lastName: 'Smith',
                email: 'jane.smith@example.com',
                mobile: '+1234567890',
                address: '456 Medical Center',
                birthDate: '1980-01-01',
            },
            mobile: '+1234567890',
            province: 'Test Province',
        };
        it('should successfully register a therapist', async () => {
            const expectedResult = {
                id: test_utils_1.TEST_USER_IDS.THERAPIST,
                ...mockTherapistData,
                status: 'pending',
                createdAt: new Date(),
                updatedAt: new Date(),
            };
            authService.registerTherapist.mockResolvedValue(expectedResult);
            const result = await controller.registerTherapist(test_utils_1.TEST_USER_IDS.THERAPIST, mockTherapistData);
            expect(authService.registerTherapist).toHaveBeenCalledWith(test_utils_1.TEST_USER_IDS.THERAPIST, mockTherapistData);
            expect(result).toEqual(expectedResult);
        });
        it('should handle therapist registration conflict', async () => {
            authService.registerTherapist.mockRejectedValue(new common_1.ConflictException('Therapist already exists'));
            await expect(controller.registerTherapist(test_utils_1.TEST_USER_IDS.THERAPIST, mockTherapistData)).rejects.toThrow(common_1.ConflictException);
        });
    });
    describe('getAllUsers', () => {
        it('should return list of all users', async () => {
            const mockUsers = [
                { id: 'user1', emailAddresses: [{ emailAddress: 'user1@test.com' }] },
                { id: 'user2', emailAddresses: [{ emailAddress: 'user2@test.com' }] },
            ];
            authService.getUsers.mockResolvedValue(mockUsers);
            const result = await controller.getAllUsers();
            expect(authService.getUsers).toHaveBeenCalled();
            expect(result).toEqual(mockUsers);
        });
        it('should handle service errors when fetching users', async () => {
            authService.getUsers.mockRejectedValue(new Error('Clerk API error'));
            await expect(controller.getAllUsers()).rejects.toThrow('Clerk API error');
        });
    });
    describe('getMe', () => {
        it('should return current user profile', async () => {
            const mockUser = {
                id: test_utils_1.TEST_USER_IDS.CLIENT,
                emailAddresses: [{ emailAddress: 'test@example.com' }],
                firstName: 'John',
                lastName: 'Doe',
            };
            authService.getUser.mockResolvedValue(mockUser);
            const result = await controller.getMe(test_utils_1.TEST_USER_IDS.CLIENT);
            expect(authService.getUser).toHaveBeenCalledWith(test_utils_1.TEST_USER_IDS.CLIENT);
            expect(result).toEqual(mockUser);
        });
        it('should handle user not found scenario', async () => {
            authService.getUser.mockResolvedValue(undefined);
            const result = await controller.getMe('non-existent-id');
            expect(result).toBeUndefined();
        });
    });
    describe('forceLogout', () => {
        it('should successfully force logout user', async () => {
            const expectedResult = {
                success: true,
                message: 'User sessions revoked successfully',
            };
            authService.forceLogout.mockResolvedValue(expectedResult);
            const result = await controller.forceLogout(test_utils_1.TEST_USER_IDS.CLIENT);
            expect(authService.forceLogout).toHaveBeenCalledWith(test_utils_1.TEST_USER_IDS.CLIENT);
            expect(result).toEqual(expectedResult);
        });
        it('should handle force logout errors', async () => {
            authService.forceLogout.mockRejectedValue(new common_1.InternalServerErrorException('Force logout failed'));
            await enhanced_test_helpers_1.TestAssertions.expectToThrowNestException(() => controller.forceLogout(test_utils_1.TEST_USER_IDS.CLIENT), common_1.InternalServerErrorException, 'Force logout failed');
        });
    });
    describe('authentication flow integration', () => {
        it('should handle complete client registration flow', async () => {
            const mockRequest = enhanced_test_helpers_1.MockBuilder.createMockRequest('client');
            const clientDto = {
                user: enhanced_test_helpers_1.TestDataGenerator.createUser({ role: 'client' }),
                hasSeenTherapistRecommendations: false,
            };
            const expectedClient = {
                id: 'client-123',
                ...clientDto,
                createdAt: new Date(),
                updatedAt: new Date(),
            };
            authService.registerClient.mockResolvedValue(expectedClient);
            const result = await controller.registerClient(mockRequest.user.userId, clientDto);
            expect(authService.registerClient).toHaveBeenCalledWith(mockRequest.user.userId, clientDto);
            expect(result).toEqual(expectedClient);
        });
        it('should handle complete therapist registration flow', async () => {
            const mockRequest = enhanced_test_helpers_1.MockBuilder.createMockRequest('therapist');
            const therapistDto = {
                user: enhanced_test_helpers_1.TestDataGenerator.createUser({ role: 'therapist' }),
                mobile: '+1234567890',
                province: 'Test Province',
            };
            const expectedTherapist = {
                id: 'therapist-123',
                ...therapistDto,
                status: 'pending',
                createdAt: new Date(),
                updatedAt: new Date(),
            };
            authService.registerTherapist.mockResolvedValue(expectedTherapist);
            const result = await controller.registerTherapist(mockRequest.user.userId, therapistDto);
            expect(authService.registerTherapist).toHaveBeenCalledWith(mockRequest.user.userId, therapistDto);
            expect(result).toEqual(expectedTherapist);
        });
    });
    describe('error handling', () => {
        it('should handle service errors gracefully', async () => {
            authService.registerClient.mockRejectedValue(new Error('Database connection failed'));
            await expect(controller.registerClient(test_utils_1.TEST_USER_IDS.CLIENT, {})).rejects.toThrow('Database connection failed');
        });
        it('should handle authentication service failures', async () => {
            authService.getUsers.mockRejectedValue(new common_1.InternalServerErrorException('Authentication service unavailable'));
            await expect(controller.getAllUsers()).rejects.toThrow('Authentication service unavailable');
        });
        it('should handle invalid user data', async () => {
            const invalidData = {
                user: null,
                hasSeenTherapistRecommendations: null,
            };
            authService.registerClient.mockRejectedValue(new Error('Invalid user data provided'));
            await expect(controller.registerClient(test_utils_1.TEST_USER_IDS.CLIENT, invalidData)).rejects.toThrow('Invalid user data provided');
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvd2V0b29hL0RvY3VtZW50cy9jb2RlL3Byb2plY3RzL21lbnRhcmEvbWVudGFyYS1hcGkvc3JjL2F1dGgvYXV0aC5jb250cm9sbGVyLnNwZWMudHMiLCJtYXBwaW5ncyI6Ijs7QUFBQSw2Q0FBc0Q7QUFDdEQsMkNBQWlGO0FBQ2pGLHVEQUFtRDtBQUNuRCxpREFBNkM7QUFDN0MsZ0ZBQW9FO0FBQ3BFLDhDQUd1QjtBQUN2QiwrRUFJNkM7QUFFN0MsUUFBUSxDQUFDLGdCQUFnQixFQUFFLEdBQUcsRUFBRTtJQUM5QixJQUFJLFVBQTBCLENBQUM7SUFDL0IsSUFBSSxXQUFxQyxDQUFDO0lBRTFDLE1BQU0sZUFBZSxHQUFHO1FBQ3RCLGNBQWMsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQ3pCLGlCQUFpQixFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDNUIsUUFBUSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDbkIsT0FBTyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDbEIsV0FBVyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7S0FDdkIsQ0FBQztJQUVGLFVBQVUsQ0FBQyxLQUFLLElBQUksRUFBRTtRQUNwQixNQUFNLFVBQVUsR0FBRyxJQUFBLG9DQUF1QixHQUFFLENBQUM7UUFFN0MsTUFBTSxNQUFNLEdBQWtCLE1BQU0sY0FBSSxDQUFDLG1CQUFtQixDQUFDO1lBQzNELFdBQVcsRUFBRSxDQUFDLGdDQUFjLENBQUM7WUFDN0IsU0FBUyxFQUFFO2dCQUNUO29CQUNFLE9BQU8sRUFBRSwwQkFBVztvQkFDcEIsUUFBUSxFQUFFLGVBQWU7aUJBQzFCO2dCQUNEO29CQUNFLE9BQU8sRUFBRSxzQ0FBYTtvQkFDdEIsUUFBUSxFQUFFLFVBQVU7aUJBQ3JCO2FBQ0Y7U0FDRixDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFFYixVQUFVLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBaUIsZ0NBQWMsQ0FBQyxDQUFDO1FBQ3hELFdBQVcsR0FBRyxNQUFNLENBQUMsR0FB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MUMsSUFBSSxLQUFLLENBQUMsNEJBQTRCLENBQUMsQ0FDeEMsQ0FBQztZQUVGLE1BQU0sTUFBTSxDQUNWLFVBQVUsQ0FBQyxjQUFjLENBQUMsMEJBQWEsQ0FBQyxNQUFNLEVBQUUsRUFBUyxDQUFDLENBQzNELENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1FBQ2xELENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLCtDQUErQyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQzdELFdBQVcsQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQ3BDLElBQUkscUNBQTRCLENBQUMsb0NBQW9DLENBQUMsQ0FDdkUsQ0FBQztZQUVGLE1BQU0sTUFBTSxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQ3BELG9DQUFvQyxDQUNyQyxDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsaUNBQWlDLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDL0MsTUFBTSxXQUFXLEdBQUc7Z0JBQ2xCLElBQUksRUFBRSxJQUFJO2dCQUNWLCtCQUErQixFQUFFLElBQUk7YUFDdEMsQ0FBQztZQUVGLFdBQVcsQ0FBQyxjQUFjLENBQUMsaUJBQWlCLENBQzFDLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQ3hDLENBQUM7WUFFRixNQUFNLE1BQU0sQ0FDVixVQUFVLENBQUMsY0FBYyxDQUFDLDBCQUFhLENBQUMsTUFBTSxFQUFFLFdBQWtCLENBQUMsQ0FDcEUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLDRCQUE0QixDQUFDLENBQUM7UUFDbEQsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9ob21lL3dldG9vYS9Eb2N1bWVudHMvY29kZS9wcm9qZWN0cy9tZW50YXJhL21lbnRhcmEtYXBpL3NyYy9hdXRoL2F1dGguY29udHJvbGxlci5zcGVjLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRlc3QsIFRlc3RpbmdNb2R1bGUgfSBmcm9tICdAbmVzdGpzL3Rlc3RpbmcnO1xuaW1wb3J0IHsgQ29uZmxpY3RFeGNlcHRpb24sIEludGVybmFsU2VydmVyRXJyb3JFeGNlcHRpb24gfSBmcm9tICdAbmVzdGpzL2NvbW1vbic7XG5pbXBvcnQgeyBBdXRoQ29udHJvbGxlciB9IGZyb20gJy4vYXV0aC5jb250cm9sbGVyJztcbmltcG9ydCB7IEF1dGhTZXJ2aWNlIH0gZnJvbSAnLi9hdXRoLnNlcnZpY2UnO1xuaW1wb3J0IHsgUHJpc21hU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9wcmlzbWEtY2xpZW50LnByb3ZpZGVyJztcbmltcG9ydCB7XG4gIGNyZWF0ZU1vY2tQcmlzbWFTZXJ2aWNlLFxuICBURVNUX1VTRVJfSURTLFxufSBmcm9tICcuLi90ZXN0LXV0aWxzJztcbmltcG9ydCB7XG4gIE1vY2tCdWlsZGVyLFxuICBUZXN0RGF0YUdlbmVyYXRvcixcbiAgVGVzdEFzc2VydGlvbnMsXG59IGZyb20gJy4uL3Rlc3QtdXRpbHMvZW5oYW5jZWQtdGVzdC1oZWxwZXJzJztcblxuZGVzY3JpYmUoJ0F1dGhDb250cm9sbGVyJywgKCkgPT4ge1xuICBsZXQgY29udHJvbGxlcjogQXV0aENvbnRyb2xsZXI7XG4gIGxldCBhdXRoU2VydmljZTogamVzdC5Nb2NrZWQ8QXV0aFNlcnZpY2U+O1xuXG4gIGNvbnN0IG1vY2tBdXRoU2VydmljZSA9IHtcbiAgICByZWdpc3RlckNsaWVudDogamVzdC5mbigpLFxuICAgIHJlZ2lzdGVyVGhlcmFwaXN0OiBqZXN0LmZuKCksXG4gICAgZ2V0VXNlcnM6IGplc3QuZm4oKSxcbiAgICBnZXRVc2VyOiBqZXN0LmZuKCksXG4gICAgZm9yY2VMb2dvdXQ6IGplc3QuZm4oKSxcbiAgfTtcblxuICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtb2NrUHJpc21hID0gY3JlYXRlTW9ja1ByaXNtYVNlcnZpY2UoKTtcblxuICAgIGNvbnN0IG1vZHVsZTogVGVzdGluZ01vZHVsZSA9IGF3YWl0IFRlc3QuY3JlYXRlVGVzdGluZ01vZHVsZSh7XG4gICAgICBjb250cm9sbGVyczogW0F1dGhDb250cm9sbGVyXSxcbiAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogQXV0aFNlcnZpY2UsXG4gICAgICAgICAgdXNlVmFsdWU6IG1vY2tBdXRoU2VydmljZSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHByb3ZpZGU6IFByaXNtYVNlcnZpY2UsXG4gICAgICAgICAgdXNlVmFsdWU6IG1vY2tQcmlzbWEsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0pLmNvbXBpbGUoKTtcblxuICAgIGNvbnRyb2xsZXIgPSBtb2R1bGUuZ2V0PEF1dGhDb250cm9sbGVyPihBdXRoQ29udHJvbGxlcik7XG4gICAgYXV0aFNlcnZpY2UgPSBtb2R1bGUuZ2V0KEF1dGhTZXJ2aWNlKTtcblxuICAgIC8vIFJlc2V0IGFsbCBtb2NrcyBiZWZvcmUgZWFjaCB0ZXN0XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdiYXNpYyBmdW5jdGlvbmFsaXR5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYmUgZGVmaW5lZCcsICgpID0+IHtcbiAgICAgIGV4cGVjdChjb250cm9sbGVyKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYXZlIGF1dGhTZXJ2aWNlIGluamVjdGVkJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KGF1dGhTZXJ2aWNlKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgncmVnaXN0ZXJDbGllbnQnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja0NsaWVudERhdGEgPSB7XG4gICAgICB1c2VyOiB7XG4gICAgICAgIGZpcnN0TmFtZTogJ0pvaG4nLFxuICAgICAgICBsYXN0TmFtZTogJ0RvZScsXG4gICAgICAgIGVtYWlsOiAnam9obi5kb2VAZXhhbXBsZS5jb20nLFxuICAgICAgICBtb2JpbGU6ICcrMTIzNDU2Nzg5MCcsXG4gICAgICAgIGFkZHJlc3M6ICcxMjMgTWFpbiBTdCcsXG4gICAgICAgIGJpcnRoRGF0ZTogJzE5OTAtMDEtMDEnLFxuICAgICAgfSxcbiAgICAgIGhhc1NlZW5UaGVyYXBpc3RSZWNvbW1lbmRhdGlvbnM6IGZhbHNlLFxuICAgIH07XG5cbiAgICBpdCgnc2hvdWxkIHN1Y2Nlc3NmdWxseSByZWdpc3RlciBhIGNsaWVudCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV4cGVjdGVkUmVzdWx0ID0ge1xuICAgICAgICBpZDogVEVTVF9VU0VSX0lEUy5DTElFTlQsXG4gICAgICAgIC4uLm1vY2tDbGllbnREYXRhLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgIH07XG5cbiAgICAgIGF1dGhTZXJ2aWNlLnJlZ2lzdGVyQ2xpZW50Lm1vY2tSZXNvbHZlZFZhbHVlKGV4cGVjdGVkUmVzdWx0IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbnRyb2xsZXIucmVnaXN0ZXJDbGllbnQoXG4gICAgICAgIFRFU1RfVVNFUl9JRFMuQ0xJRU5ULFxuICAgICAgICBtb2NrQ2xpZW50RGF0YSBhcyBhbnksXG4gICAgICApO1xuXG4gICAgICBleHBlY3QoYXV0aFNlcnZpY2UucmVnaXN0ZXJDbGllbnQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBURVNUX1VTRVJfSURTLkNMSUVOVCxcbiAgICAgICAgbW9ja0NsaWVudERhdGEsXG4gICAgICApO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChleHBlY3RlZFJlc3VsdCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSByZWdpc3RyYXRpb24gY29uZmxpY3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhdXRoU2VydmljZS5yZWdpc3RlckNsaWVudC5tb2NrUmVqZWN0ZWRWYWx1ZShcbiAgICAgICAgbmV3IENvbmZsaWN0RXhjZXB0aW9uKCdVc2VyIGFscmVhZHkgZXhpc3RzJyksXG4gICAgICApO1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIGNvbnRyb2xsZXIucmVnaXN0ZXJDbGllbnQoVEVTVF9VU0VSX0lEUy5DTElFTlQsIG1vY2tDbGllbnREYXRhIGFzIGFueSksXG4gICAgICApLnJlamVjdHMudG9UaHJvdyhDb25mbGljdEV4Y2VwdGlvbik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdyZWdpc3RlclRoZXJhcGlzdCcsICgpID0+IHtcbiAgICBjb25zdCBtb2NrVGhlcmFwaXN0RGF0YSA9IHtcbiAgICAgIHVzZXI6IHtcbiAgICAgICAgZmlyc3ROYW1lOiAnRHIuIEphbmUnLFxuICAgICAgICBsYXN0TmFtZTogJ1NtaXRoJyxcbiAgICAgICAgZW1haWw6ICdqYW5lLnNtaXRoQGV4YW1wbGUuY29tJyxcbiAgICAgICAgbW9iaWxlOiAnKzEyMzQ1Njc4OTAnLFxuICAgICAgICBhZGRyZXNzOiAnNDU2IE1lZGljYWwgQ2VudGVyJyxcbiAgICAgICAgYmlydGhEYXRlOiAnMTk4MC0wMS0wMScsXG4gICAgICB9LFxuICAgICAgbW9iaWxlOiAnKzEyMzQ1Njc4OTAnLFxuICAgICAgcHJvdmluY2U6ICdUZXN0IFByb3ZpbmNlJyxcbiAgICB9O1xuXG4gICAgaXQoJ3Nob3VsZCBzdWNjZXNzZnVsbHkgcmVnaXN0ZXIgYSB0aGVyYXBpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBleHBlY3RlZFJlc3VsdCA9IHtcbiAgICAgICAgaWQ6IFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNULFxuICAgICAgICAuLi5tb2NrVGhlcmFwaXN0RGF0YSxcbiAgICAgICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgfTtcblxuICAgICAgYXV0aFNlcnZpY2UucmVnaXN0ZXJUaGVyYXBpc3QubW9ja1Jlc29sdmVkVmFsdWUoZXhwZWN0ZWRSZXN1bHQgYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29udHJvbGxlci5yZWdpc3RlclRoZXJhcGlzdChcbiAgICAgICAgVEVTVF9VU0VSX0lEUy5USEVSQVBJU1QsXG4gICAgICAgIG1vY2tUaGVyYXBpc3REYXRhIGFzIGFueSxcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChhdXRoU2VydmljZS5yZWdpc3RlclRoZXJhcGlzdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNULFxuICAgICAgICBtb2NrVGhlcmFwaXN0RGF0YSxcbiAgICAgICk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKGV4cGVjdGVkUmVzdWx0KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHRoZXJhcGlzdCByZWdpc3RyYXRpb24gY29uZmxpY3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhdXRoU2VydmljZS5yZWdpc3RlclRoZXJhcGlzdC5tb2NrUmVqZWN0ZWRWYWx1ZShcbiAgICAgICAgbmV3IENvbmZsaWN0RXhjZXB0aW9uKCdUaGVyYXBpc3QgYWxyZWFkeSBleGlzdHMnKSxcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgY29udHJvbGxlci5yZWdpc3RlclRoZXJhcGlzdChURVNUX1VTRVJfSURTLlRIRVJBUElTVCwgbW9ja1RoZXJhcGlzdERhdGEgYXMgYW55KSxcbiAgICAgICkucmVqZWN0cy50b1Rocm93KENvbmZsaWN0RXhjZXB0aW9uKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldEFsbFVzZXJzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIGxpc3Qgb2YgYWxsIHVzZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1VzZXJzID0gW1xuICAgICAgICB7IGlkOiAndXNlcjEnLCBlbWFpbEFkZHJlc3NlczogW3sgZW1haWxBZGRyZXNzOiAndXNlcjFAdGVzdC5jb20nIH1dIH0sXG4gICAgICAgIHsgaWQ6ICd1c2VyMicsIGVtYWlsQWRkcmVzc2VzOiBbeyBlbWFpbEFkZHJlc3M6ICd1c2VyMkB0ZXN0LmNvbScgfV0gfSxcbiAgICAgIF07XG5cbiAgICAgIGF1dGhTZXJ2aWNlLmdldFVzZXJzLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VycyBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb250cm9sbGVyLmdldEFsbFVzZXJzKCk7XG5cbiAgICAgIGV4cGVjdChhdXRoU2VydmljZS5nZXRVc2VycykudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrVXNlcnMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc2VydmljZSBlcnJvcnMgd2hlbiBmZXRjaGluZyB1c2VycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF1dGhTZXJ2aWNlLmdldFVzZXJzLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQ2xlcmsgQVBJIGVycm9yJykpO1xuXG4gICAgICBhd2FpdCBleHBlY3QoY29udHJvbGxlci5nZXRBbGxVc2VycygpKS5yZWplY3RzLnRvVGhyb3coJ0NsZXJrIEFQSSBlcnJvcicpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0TWUnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gY3VycmVudCB1c2VyIHByb2ZpbGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrVXNlciA9IHtcbiAgICAgICAgaWQ6IFRFU1RfVVNFUl9JRFMuQ0xJRU5ULFxuICAgICAgICBlbWFpbEFkZHJlc3NlczogW3sgZW1haWxBZGRyZXNzOiAndGVzdEBleGFtcGxlLmNvbScgfV0sXG4gICAgICAgIGZpcnN0TmFtZTogJ0pvaG4nLFxuICAgICAgICBsYXN0TmFtZTogJ0RvZScsXG4gICAgICB9O1xuXG4gICAgICBhdXRoU2VydmljZS5nZXRVc2VyLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyIGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbnRyb2xsZXIuZ2V0TWUoVEVTVF9VU0VSX0lEUy5DTElFTlQpO1xuXG4gICAgICBleHBlY3QoYXV0aFNlcnZpY2UuZ2V0VXNlcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoVEVTVF9VU0VSX0lEUy5DTElFTlQpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrVXNlcik7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB1c2VyIG5vdCBmb3VuZCBzY2VuYXJpbycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF1dGhTZXJ2aWNlLmdldFVzZXIubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkIGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbnRyb2xsZXIuZ2V0TWUoJ25vbi1leGlzdGVudC1pZCcpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlVW5kZWZpbmVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdmb3JjZUxvZ291dCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHN1Y2Nlc3NmdWxseSBmb3JjZSBsb2dvdXQgdXNlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV4cGVjdGVkUmVzdWx0ID0ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBtZXNzYWdlOiAnVXNlciBzZXNzaW9ucyByZXZva2VkIHN1Y2Nlc3NmdWxseScsXG4gICAgICB9O1xuXG4gICAgICBhdXRoU2VydmljZS5mb3JjZUxvZ291dC5tb2NrUmVzb2x2ZWRWYWx1ZShleHBlY3RlZFJlc3VsdCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbnRyb2xsZXIuZm9yY2VMb2dvdXQoVEVTVF9VU0VSX0lEUy5DTElFTlQpO1xuXG4gICAgICBleHBlY3QoYXV0aFNlcnZpY2UuZm9yY2VMb2dvdXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFRFU1RfVVNFUl9JRFMuQ0xJRU5UKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoZXhwZWN0ZWRSZXN1bHQpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZm9yY2UgbG9nb3V0IGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF1dGhTZXJ2aWNlLmZvcmNlTG9nb3V0Lm1vY2tSZWplY3RlZFZhbHVlKFxuICAgICAgICBuZXcgSW50ZXJuYWxTZXJ2ZXJFcnJvckV4Y2VwdGlvbignRm9yY2UgbG9nb3V0IGZhaWxlZCcpLFxuICAgICAgKTtcblxuICAgICAgYXdhaXQgVGVzdEFzc2VydGlvbnMuZXhwZWN0VG9UaHJvd05lc3RFeGNlcHRpb24oXG4gICAgICAgICgpID0+IGNvbnRyb2xsZXIuZm9yY2VMb2dvdXQoVEVTVF9VU0VSX0lEUy5DTElFTlQpLFxuICAgICAgICBJbnRlcm5hbFNlcnZlckVycm9yRXhjZXB0aW9uLFxuICAgICAgICAnRm9yY2UgbG9nb3V0IGZhaWxlZCcsXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnYXV0aGVudGljYXRpb24gZmxvdyBpbnRlZ3JhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb21wbGV0ZSBjbGllbnQgcmVnaXN0cmF0aW9uIGZsb3cnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IE1vY2tCdWlsZGVyLmNyZWF0ZU1vY2tSZXF1ZXN0KCdjbGllbnQnKTtcbiAgICAgIGNvbnN0IGNsaWVudER0byA9IHtcbiAgICAgICAgdXNlcjogVGVzdERhdGFHZW5lcmF0b3IuY3JlYXRlVXNlcih7IHJvbGU6ICdjbGllbnQnIH0pLFxuICAgICAgICBoYXNTZWVuVGhlcmFwaXN0UmVjb21tZW5kYXRpb25zOiBmYWxzZSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGV4cGVjdGVkQ2xpZW50ID0ge1xuICAgICAgICBpZDogJ2NsaWVudC0xMjMnLFxuICAgICAgICAuLi5jbGllbnREdG8sXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgfTtcblxuICAgICAgYXV0aFNlcnZpY2UucmVnaXN0ZXJDbGllbnQubW9ja1Jlc29sdmVkVmFsdWUoZXhwZWN0ZWRDbGllbnQgYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29udHJvbGxlci5yZWdpc3RlckNsaWVudChcbiAgICAgICAgbW9ja1JlcXVlc3QudXNlci51c2VySWQsXG4gICAgICAgIGNsaWVudER0byBhcyBhbnksXG4gICAgICApO1xuXG4gICAgICBleHBlY3QoYXV0aFNlcnZpY2UucmVnaXN0ZXJDbGllbnQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBtb2NrUmVxdWVzdC51c2VyLnVzZXJJZCxcbiAgICAgICAgY2xpZW50RHRvLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoZXhwZWN0ZWRDbGllbnQpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29tcGxldGUgdGhlcmFwaXN0IHJlZ2lzdHJhdGlvbiBmbG93JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1JlcXVlc3QgPSBNb2NrQnVpbGRlci5jcmVhdGVNb2NrUmVxdWVzdCgndGhlcmFwaXN0Jyk7XG4gICAgICBjb25zdCB0aGVyYXBpc3REdG8gPSB7XG4gICAgICAgIHVzZXI6IFRlc3REYXRhR2VuZXJhdG9yLmNyZWF0ZVVzZXIoeyByb2xlOiAndGhlcmFwaXN0JyB9KSxcbiAgICAgICAgbW9iaWxlOiAnKzEyMzQ1Njc4OTAnLFxuICAgICAgICBwcm92aW5jZTogJ1Rlc3QgUHJvdmluY2UnLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgZXhwZWN0ZWRUaGVyYXBpc3QgPSB7XG4gICAgICAgIGlkOiAndGhlcmFwaXN0LTEyMycsXG4gICAgICAgIC4uLnRoZXJhcGlzdER0byxcbiAgICAgICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgfTtcblxuICAgICAgYXV0aFNlcnZpY2UucmVnaXN0ZXJUaGVyYXBpc3QubW9ja1Jlc29sdmVkVmFsdWUoZXhwZWN0ZWRUaGVyYXBpc3QgYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29udHJvbGxlci5yZWdpc3RlclRoZXJhcGlzdChcbiAgICAgICAgbW9ja1JlcXVlc3QudXNlci51c2VySWQsXG4gICAgICAgIHRoZXJhcGlzdER0byBhcyBhbnksXG4gICAgICApO1xuXG4gICAgICBleHBlY3QoYXV0aFNlcnZpY2UucmVnaXN0ZXJUaGVyYXBpc3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBtb2NrUmVxdWVzdC51c2VyLnVzZXJJZCxcbiAgICAgICAgdGhlcmFwaXN0RHRvLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoZXhwZWN0ZWRUaGVyYXBpc3QpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZXJyb3IgaGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc2VydmljZSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGF1dGhTZXJ2aWNlLnJlZ2lzdGVyQ2xpZW50Lm1vY2tSZWplY3RlZFZhbHVlKFxuICAgICAgICBuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJyksXG4gICAgICApO1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIGNvbnRyb2xsZXIucmVnaXN0ZXJDbGllbnQoVEVTVF9VU0VSX0lEUy5DTElFTlQsIHt9IGFzIGFueSksXG4gICAgICApLnJlamVjdHMudG9UaHJvdygnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGF1dGhlbnRpY2F0aW9uIHNlcnZpY2UgZmFpbHVyZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhdXRoU2VydmljZS5nZXRVc2Vycy5tb2NrUmVqZWN0ZWRWYWx1ZShcbiAgICAgICAgbmV3IEludGVybmFsU2VydmVyRXJyb3JFeGNlcHRpb24oJ0F1dGhlbnRpY2F0aW9uIHNlcnZpY2UgdW5hdmFpbGFibGUnKSxcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChjb250cm9sbGVyLmdldEFsbFVzZXJzKCkpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgJ0F1dGhlbnRpY2F0aW9uIHNlcnZpY2UgdW5hdmFpbGFibGUnLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGludmFsaWQgdXNlciBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZERhdGEgPSB7XG4gICAgICAgIHVzZXI6IG51bGwsXG4gICAgICAgIGhhc1NlZW5UaGVyYXBpc3RSZWNvbW1lbmRhdGlvbnM6IG51bGwsXG4gICAgICB9O1xuXG4gICAgICBhdXRoU2VydmljZS5yZWdpc3RlckNsaWVudC5tb2NrUmVqZWN0ZWRWYWx1ZShcbiAgICAgICAgbmV3IEVycm9yKCdJbnZhbGlkIHVzZXIgZGF0YSBwcm92aWRlZCcpLFxuICAgICAgKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBjb250cm9sbGVyLnJlZ2lzdGVyQ2xpZW50KFRFU1RfVVNFUl9JRFMuQ0xJRU5ULCBpbnZhbGlkRGF0YSBhcyBhbnkpLFxuICAgICAgKS5yZWplY3RzLnRvVGhyb3coJ0ludmFsaWQgdXNlciBkYXRhIHByb3ZpZGVkJyk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=