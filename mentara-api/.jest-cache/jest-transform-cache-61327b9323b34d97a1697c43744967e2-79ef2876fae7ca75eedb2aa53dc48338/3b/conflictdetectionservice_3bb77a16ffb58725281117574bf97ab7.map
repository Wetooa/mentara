{"file":"/home/wetooa/Documents/code/projects/mentara/mentara-api/src/booking/services/conflict-detection.service.ts","mappings":";;;;;;;;;;;;;AAAA,2CAAiE;AACjE,mFAAuE;AAchE,IAAM,wBAAwB,GAA9B,MAAM,wBAAwB;IACN;IAA7B,YAA6B,MAAqB;QAArB,WAAM,GAAN,MAAM,CAAe;IAAG,CAAC;IAEtD;;OAEG;IACH,KAAK,CAAC,wBAAwB,CAC5B,WAAmB,EACnB,QAAgB,EAChB,SAAe,EACf,QAAgB;QAEhB,MAAM,OAAO,GAAG,IAAI,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,GAAG,QAAQ,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;QACrE,MAAM,SAAS,GAAG,EAAE,SAAS,EAAE,OAAO,EAAE,CAAC;QAEzC,MAAM,CAAC,kBAAkB,EAAE,eAAe,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC;YAC9D,IAAI,CAAC,uBAAuB,CAAC,WAAW,EAAE,SAAS,CAAC;YACpD,IAAI,CAAC,oBAAoB,CAAC,QAAQ,EAAE,SAAS,CAAC;SAC/C,CAAC,CAAC;QAEH,MAAM,WAAW,GACf,kBAAkB,CAAC,MAAM,GAAG,CAAC,IAAI,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC;QAC9D,IAAI,YAAY,GAA6C,MAAM,CAAC;QAEpE,IAAI,kBAAkB,CAAC,MAAM,GAAG,CAAC,IAAI,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAChE,YAAY,GAAG,MAAM,CAAC;QACxB,CAAC;aAAM,IAAI,kBAAkB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACzC,YAAY,GAAG,WAAW,CAAC;QAC7B,CAAC;aAAM,IAAI,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACtC,YAAY,GAAG,QAAQ,CAAC;QAC1B,CAAC;QAED,OAAO;YACL,WAAW;YACX,mBAAmB,EAAE,CAAC,GAAG,kBAAkB,EAAE,GAAG,eAAe,CAAC;YAChE,YAAY;SACb,CAAC;IACJ,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,uBAAuB,CAC3B,WAAmB,EACnB,SAAoB;QAEpB,OAAO,IAAI,CAAC,uBAAuB,CAAC;YAClC,WAAW;YACX,SAAS;YACT,QAAQ,EAAE,CAAC,WAAW,EAAE,WAAW,EAAE,aAAa,CAAC;SACpD,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,oBAAoB,CACxB,QAAgB,EAChB,SAAoB;QAEpB,OAAO,IAAI,CAAC,uBAAuB,CAAC;YAClC,QAAQ;YACR,SAAS;YACT,QAAQ,EAAE,CAAC,WAAW,EAAE,WAAW,EAAE,aAAa,CAAC;SACpD,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,oBAAoB,CACxB,SAAiB,EACjB,WAAmB,EACnB,QAAgB,EAChB,YAAkB,EAClB,WAAmB;QAEnB,MAAM,OAAO,GAAG,IAAI,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,GAAG,WAAW,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;QAC3E,MAAM,SAAS,GAAG,EAAE,SAAS,EAAE,YAAY,EAAE,OAAO,EAAE,CAAC;QAEvD,+CAA+C;QAC/C,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,uBAAuB,CAAC;YACnD,WAAW;YACX,QAAQ;YACR,SAAS;YACT,QAAQ,EAAE,CAAC,WAAW,EAAE,WAAW,EAAE,aAAa,CAAC;YACnD,gBAAgB,EAAE,SAAS;SAC5B,CAAC,CAAC;QAEH,MAAM,kBAAkB,GAAG,SAAS,CAAC,MAAM,CACzC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,WAAW,KAAK,WAAW,CACrC,CAAC;QACF,MAAM,eAAe,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,KAAK,QAAQ,CAAC,CAAC;QAEzE,MAAM,WAAW,GAAG,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC;QACzC,IAAI,YAAY,GAA6C,MAAM,CAAC;QAEpE,IAAI,kBAAkB,CAAC,MAAM,GAAG,CAAC,IAAI,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAChE,YAAY,GAAG,MAAM,CAAC;QACxB,CAAC;aAAM,IAAI,kBAAkB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACzC,YAAY,GAAG,WAAW,CAAC;QAC7B,CAAC;aAAM,IAAI,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACtC,YAAY,GAAG,QAAQ,CAAC;QAC1B,CAAC;QAED,OAAO;YACL,WAAW;YACX,mBAAmB,EAAE,SAAS;YAC9B,YAAY;SACb,CAAC;IACJ,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,kBAAkB,CACtB,QAKE;QAEF,MAAM,SAAS,GAA0D,EAAE,CAAC;QAE5E,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACzC,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YAE5B,kCAAkC;YAClC,MAAM,iBAAiB,GAAG,MAAM,IAAI,CAAC,wBAAwB,CAC3D,OAAO,CAAC,WAAW,EACnB,OAAO,CAAC,QAAQ,EAChB,OAAO,CAAC,SAAS,EACjB,OAAO,CAAC,QAAQ,CACjB,CAAC;YAEF,qDAAqD;YACrD,MAAM,iBAAiB,GAAG,IAAI,CAAC,sBAAsB,CACnD,OAAO,EACP,QAAQ,EACR,CAAC,CACF,CAAC;YAEF,IAAI,iBAAiB,CAAC,WAAW,IAAI,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAClE,SAAS,CAAC,IAAI,CAAC;oBACb,YAAY,EAAE,CAAC;oBACf,SAAS,EAAE;wBACT,WAAW,EAAE,IAAI;wBACjB,mBAAmB,EAAE;4BACnB,GAAG,iBAAiB,CAAC,mBAAmB;4BACxC,GAAG,iBAAiB;yBACrB;wBACD,YAAY,EAAE,iBAAiB,CAAC,YAAY;qBAC7C;iBACF,CAAC,CAAC;YACL,CAAC;QACH,CAAC;QAED,OAAO,SAAS,CAAC;IACnB,CAAC;IAEO,KAAK,CAAC,uBAAuB,CAAC,EACpC,WAAW,EACX,QAAQ,EACR,SAAS,EACT,QAAQ,EACR,gBAAgB,GAOjB;QACC,MAAM,eAAe,GAAU,EAAE,CAAC;QAElC,0BAA0B;QAC1B,IAAI,WAAW,EAAE,CAAC;YAChB,eAAe,CAAC,IAAI,CAAC;gBACnB,WAAW;gBACX,SAAS,EAAE,EAAE,EAAE,EAAE,SAAS,CAAC,OAAO,EAAE;gBACpC,sDAAsD;gBACtD,EAAE,EAAE;oBACF;wBACE,0DAA0D;wBAC1D,SAAS,EAAE,EAAE,GAAG,EAAE,SAAS,CAAC,SAAS,EAAE;qBACxC;oBACD;wBACE,kEAAkE;wBAClE,SAAS,EAAE,EAAE,EAAE,EAAE,SAAS,CAAC,SAAS,EAAE;wBACtC,8EAA8E;qBAC/E;iBACF;gBACD,MAAM,EAAE,EAAE,EAAE,EAAE,QAAQ,EAAE;aACzB,CAAC,CAAC;QACL,CAAC;QAED,uBAAuB;QACvB,IAAI,QAAQ,EAAE,CAAC;YACb,eAAe,CAAC,IAAI,CAAC;gBACnB,QAAQ;gBACR,SAAS,EAAE,EAAE,EAAE,EAAE,SAAS,CAAC,OAAO,EAAE;gBACpC,EAAE,EAAE;oBACF,EAAE,SAAS,EAAE,EAAE,GAAG,EAAE,SAAS,CAAC,SAAS,EAAE,EAAE;oBAC3C,EAAE,SAAS,EAAE,EAAE,EAAE,EAAE,SAAS,CAAC,SAAS,EAAE,EAAE;iBAC3C;gBACD,MAAM,EAAE,EAAE,EAAE,EAAE,QAAQ,EAAE;aACzB,CAAC,CAAC;QACL,CAAC;QAED,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACjC,OAAO,EAAE,CAAC;QACZ,CAAC;QAED,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;YAClD,KAAK,EAAE;gBACL,EAAE,EAAE,eAAe;gBACnB,GAAG,CAAC,gBAAgB,IAAI,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,gBAAgB,EAAE,EAAE,CAAC;aAC3D;YACD,OAAO,EAAE;gBACP,MAAM,EAAE;oBACN,MAAM,EAAE;wBACN,IAAI,EAAE;4BACJ,MAAM,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE;yBAC5C;qBACF;iBACF;gBACD,SAAS,EAAE;oBACT,MAAM,EAAE;wBACN,IAAI,EAAE;4BACJ,MAAM,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE;yBAC5C;qBACF;iBACF;aACF;SACF,CAAC,CAAC;QAEH,4FAA4F;QAC5F,OAAO,QAAQ,CAAC,MAAM,CAAC,CAAC,OAAO,EAAE,EAAE;YACjC,MAAM,cAAc,GAAG,IAAI,IAAI,CAC7B,OAAO,CAAC,SAAS,CAAC,OAAO,EAAE,GAAG,OAAO,CAAC,QAAQ,GAAG,EAAE,GAAG,IAAI,CAC3D,CAAC;YACF,OAAO,IAAI,CAAC,cAAc,CACxB,SAAS,CAAC,SAAS,EACnB,SAAS,CAAC,OAAO,EACjB,OAAO,CAAC,SAAS,EACjB,cAAc,CACf,CAAC;QACJ,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,sBAAsB,CAC5B,cAKC,EACD,WAKE,EACF,YAAoB;QAEpB,MAAM,SAAS,GAAU,EAAE,CAAC;QAC5B,MAAM,cAAc,GAAG,IAAI,IAAI,CAC7B,cAAc,CAAC,SAAS,CAAC,OAAO,EAAE,GAAG,cAAc,CAAC,QAAQ,GAAG,EAAE,GAAG,IAAI,CACzE,CAAC;QAEF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC5C,IAAI,CAAC,KAAK,YAAY;gBAAE,SAAS;YAEjC,MAAM,YAAY,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;YACpC,MAAM,YAAY,GAAG,IAAI,IAAI,CAC3B,YAAY,CAAC,SAAS,CAAC,OAAO,EAAE,GAAG,YAAY,CAAC,QAAQ,GAAG,EAAE,GAAG,IAAI,CACrE,CAAC;YAEF,4CAA4C;YAC5C,MAAM,aAAa,GACjB,cAAc,CAAC,WAAW,KAAK,YAAY,CAAC,WAAW,CAAC;YAC1D,MAAM,UAAU,GAAG,cAAc,CAAC,QAAQ,KAAK,YAAY,CAAC,QAAQ,CAAC;YAErE,IACE,CAAC,aAAa,IAAI,UAAU,CAAC;gBAC7B,IAAI,CAAC,cAAc,CACjB,cAAc,CAAC,SAAS,EACxB,cAAc,EACd,YAAY,CAAC,SAAS,EACtB,YAAY,CACb,EACD,CAAC;gBACD,SAAS,CAAC,IAAI,CAAC;oBACb,GAAG,YAAY;oBACf,YAAY,EACV,aAAa,IAAI,UAAU;wBACzB,CAAC,CAAC,MAAM;wBACR,CAAC,CAAC,aAAa;4BACb,CAAC,CAAC,WAAW;4BACb,CAAC,CAAC,QAAQ;oBAChB,kBAAkB,EAAE,IAAI;oBACxB,aAAa,EAAE,CAAC;iBACjB,CAAC,CAAC;YACL,CAAC;QACH,CAAC;QAED,OAAO,SAAS,CAAC;IACnB,CAAC;IAED;;OAEG;IACH,cAAc,CAAC,MAAY,EAAE,IAAU,EAAE,MAAY,EAAE,IAAU;QAC/D,OAAO,MAAM,GAAG,IAAI,IAAI,IAAI,GAAG,MAAM,CAAC;IACxC,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,mBAAmB,CACvB,WAAmB,EACnB,QAAgB,EAChB,SAAe,EACf,QAAgB;QAEhB,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,wBAAwB,CACnD,WAAW,EACX,QAAQ,EACR,SAAS,EACT,QAAQ,CACT,CAAC;QAEF,IAAI,SAAS,CAAC,WAAW,EAAE,CAAC;YAC1B,MAAM,gBAAgB,GAAG,SAAS,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE;gBACrE,MAAM,YAAY,GAAG,OAAO,CAAC,SAAS,CAAC,cAAc,EAAE,CAAC;gBACxD,MAAM,UAAU,GAAG,IAAI,IAAI,CACzB,OAAO,CAAC,SAAS,CAAC,OAAO,EAAE,GAAG,OAAO,CAAC,QAAQ,GAAG,KAAK,CACvD,CAAC,cAAc,EAAE,CAAC;gBACnB,OAAO,gBAAgB,YAAY,OAAO,UAAU,EAAE,CAAC;YACzD,CAAC,CAAC,CAAC;YAEH,MAAM,IAAI,4BAAmB,CAC3B,+CAA+C,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAC7E,CAAC;QACJ,CAAC;IACH,CAAC;CACF,CAAA;AA5VY,4DAAwB;mCAAxB,wBAAwB;IADpC,IAAA,mBAAU,GAAE;yDAE0B,sCAAa,oBAAb,sCAAa;GADvC,wBAAwB,CA4VpC","names":[],"sources":["/home/wetooa/Documents/code/projects/mentara/mentara-api/src/booking/services/conflict-detection.service.ts"],"sourcesContent":["import { Injectable, BadRequestException } from '@nestjs/common';\nimport { PrismaService } from '../../providers/prisma-client.provider';\n\nexport interface TimeRange {\n  startTime: Date;\n  endTime: Date;\n}\n\nexport interface ConflictResult {\n  hasConflict: boolean;\n  conflictingMeetings: any[];\n  conflictType: 'therapist' | 'client' | 'both' | 'none';\n}\n\n@Injectable()\nexport class ConflictDetectionService {\n  constructor(private readonly prisma: PrismaService) {}\n\n  /**\n   * Check for scheduling conflicts for both therapist and client\n   */\n  async checkSchedulingConflicts(\n    therapistId: string,\n    clientId: string,\n    startTime: Date,\n    duration: number,\n  ): Promise<ConflictResult> {\n    const endTime = new Date(startTime.getTime() + duration * 60 * 1000);\n    const timeRange = { startTime, endTime };\n\n    const [therapistConflicts, clientConflicts] = await Promise.all([\n      this.checkTherapistConflicts(therapistId, timeRange),\n      this.checkClientConflicts(clientId, timeRange),\n    ]);\n\n    const hasConflict =\n      therapistConflicts.length > 0 || clientConflicts.length > 0;\n    let conflictType: 'therapist' | 'client' | 'both' | 'none' = 'none';\n\n    if (therapistConflicts.length > 0 && clientConflicts.length > 0) {\n      conflictType = 'both';\n    } else if (therapistConflicts.length > 0) {\n      conflictType = 'therapist';\n    } else if (clientConflicts.length > 0) {\n      conflictType = 'client';\n    }\n\n    return {\n      hasConflict,\n      conflictingMeetings: [...therapistConflicts, ...clientConflicts],\n      conflictType,\n    };\n  }\n\n  /**\n   * Check for conflicts in therapist's schedule\n   */\n  async checkTherapistConflicts(\n    therapistId: string,\n    timeRange: TimeRange,\n  ): Promise<any[]> {\n    return this.findConflictingMeetings({\n      therapistId,\n      timeRange,\n      statuses: ['SCHEDULED', 'CONFIRMED', 'IN_PROGRESS'],\n    });\n  }\n\n  /**\n   * Check for conflicts in client's schedule\n   */\n  async checkClientConflicts(\n    clientId: string,\n    timeRange: TimeRange,\n  ): Promise<any[]> {\n    return this.findConflictingMeetings({\n      clientId,\n      timeRange,\n      statuses: ['SCHEDULED', 'CONFIRMED', 'IN_PROGRESS'],\n    });\n  }\n\n  /**\n   * Check if updating a meeting would cause conflicts\n   */\n  async checkUpdateConflicts(\n    meetingId: string,\n    therapistId: string,\n    clientId: string,\n    newStartTime: Date,\n    newDuration: number,\n  ): Promise<ConflictResult> {\n    const endTime = new Date(newStartTime.getTime() + newDuration * 60 * 1000);\n    const timeRange = { startTime: newStartTime, endTime };\n\n    // Find conflicts excluding the current meeting\n    const conflicts = await this.findConflictingMeetings({\n      therapistId,\n      clientId,\n      timeRange,\n      statuses: ['SCHEDULED', 'CONFIRMED', 'IN_PROGRESS'],\n      excludeMeetingId: meetingId,\n    });\n\n    const therapistConflicts = conflicts.filter(\n      (m) => m.therapistId === therapistId,\n    );\n    const clientConflicts = conflicts.filter((m) => m.clientId === clientId);\n\n    const hasConflict = conflicts.length > 0;\n    let conflictType: 'therapist' | 'client' | 'both' | 'none' = 'none';\n\n    if (therapistConflicts.length > 0 && clientConflicts.length > 0) {\n      conflictType = 'both';\n    } else if (therapistConflicts.length > 0) {\n      conflictType = 'therapist';\n    } else if (clientConflicts.length > 0) {\n      conflictType = 'client';\n    }\n\n    return {\n      hasConflict,\n      conflictingMeetings: conflicts,\n      conflictType,\n    };\n  }\n\n  /**\n   * Check for conflicts when bulk scheduling multiple meetings\n   */\n  async checkBulkConflicts(\n    meetings: Array<{\n      therapistId: string;\n      clientId: string;\n      startTime: Date;\n      duration: number;\n    }>,\n  ): Promise<{ meetingIndex: number; conflicts: ConflictResult }[]> {\n    const conflicts: { meetingIndex: number; conflicts: ConflictResult }[] = [];\n\n    for (let i = 0; i < meetings.length; i++) {\n      const meeting = meetings[i];\n\n      // Check against existing meetings\n      const existingConflicts = await this.checkSchedulingConflicts(\n        meeting.therapistId,\n        meeting.clientId,\n        meeting.startTime,\n        meeting.duration,\n      );\n\n      // Check against other meetings in the bulk operation\n      const internalConflicts = this.checkInternalConflicts(\n        meeting,\n        meetings,\n        i,\n      );\n\n      if (existingConflicts.hasConflict || internalConflicts.length > 0) {\n        conflicts.push({\n          meetingIndex: i,\n          conflicts: {\n            hasConflict: true,\n            conflictingMeetings: [\n              ...existingConflicts.conflictingMeetings,\n              ...internalConflicts,\n            ],\n            conflictType: existingConflicts.conflictType,\n          },\n        });\n      }\n    }\n\n    return conflicts;\n  }\n\n  private async findConflictingMeetings({\n    therapistId,\n    clientId,\n    timeRange,\n    statuses,\n    excludeMeetingId,\n  }: {\n    therapistId?: string;\n    clientId?: string;\n    timeRange: TimeRange;\n    statuses: string[];\n    excludeMeetingId?: string;\n  }): Promise<any[]> {\n    const whereConditions: any[] = [];\n\n    // Add therapist condition\n    if (therapistId) {\n      whereConditions.push({\n        therapistId,\n        startTime: { lt: timeRange.endTime },\n        // Use a computed endTime for proper overlap detection\n        OR: [\n          {\n            // Meeting starts before our end time and hasn't ended yet\n            startTime: { gte: timeRange.startTime },\n          },\n          {\n            // Meeting started before our start time but extends into our time\n            startTime: { lt: timeRange.startTime },\n            // This is a bit complex in Prisma - we need to use raw SQL or compute endTime\n          },\n        ],\n        status: { in: statuses },\n      });\n    }\n\n    // Add client condition\n    if (clientId) {\n      whereConditions.push({\n        clientId,\n        startTime: { lt: timeRange.endTime },\n        OR: [\n          { startTime: { gte: timeRange.startTime } },\n          { startTime: { lt: timeRange.startTime } },\n        ],\n        status: { in: statuses },\n      });\n    }\n\n    if (whereConditions.length === 0) {\n      return [];\n    }\n\n    const meetings = await this.prisma.meeting.findMany({\n      where: {\n        OR: whereConditions,\n        ...(excludeMeetingId && { id: { not: excludeMeetingId } }),\n      },\n      include: {\n        client: {\n          select: {\n            user: {\n              select: { firstName: true, lastName: true },\n            },\n          },\n        },\n        therapist: {\n          select: {\n            user: {\n              select: { firstName: true, lastName: true },\n            },\n          },\n        },\n      },\n    });\n\n    // Filter meetings that actually overlap (since Prisma doesn't handle computed endTime well)\n    return meetings.filter((meeting) => {\n      const meetingEndTime = new Date(\n        meeting.startTime.getTime() + meeting.duration * 60 * 1000,\n      );\n      return this.hasTimeOverlap(\n        timeRange.startTime,\n        timeRange.endTime,\n        meeting.startTime,\n        meetingEndTime,\n      );\n    });\n  }\n\n  private checkInternalConflicts(\n    currentMeeting: {\n      therapistId: string;\n      clientId: string;\n      startTime: Date;\n      duration: number;\n    },\n    allMeetings: Array<{\n      therapistId: string;\n      clientId: string;\n      startTime: Date;\n      duration: number;\n    }>,\n    currentIndex: number,\n  ): any[] {\n    const conflicts: any[] = [];\n    const currentEndTime = new Date(\n      currentMeeting.startTime.getTime() + currentMeeting.duration * 60 * 1000,\n    );\n\n    for (let i = 0; i < allMeetings.length; i++) {\n      if (i === currentIndex) continue;\n\n      const otherMeeting = allMeetings[i];\n      const otherEndTime = new Date(\n        otherMeeting.startTime.getTime() + otherMeeting.duration * 60 * 1000,\n      );\n\n      // Check if meetings involve the same people\n      const sameTherapist =\n        currentMeeting.therapistId === otherMeeting.therapistId;\n      const sameClient = currentMeeting.clientId === otherMeeting.clientId;\n\n      if (\n        (sameTherapist || sameClient) &&\n        this.hasTimeOverlap(\n          currentMeeting.startTime,\n          currentEndTime,\n          otherMeeting.startTime,\n          otherEndTime,\n        )\n      ) {\n        conflicts.push({\n          ...otherMeeting,\n          conflictType:\n            sameTherapist && sameClient\n              ? 'both'\n              : sameTherapist\n                ? 'therapist'\n                : 'client',\n          isInternalConflict: true,\n          conflictIndex: i,\n        });\n      }\n    }\n\n    return conflicts;\n  }\n\n  /**\n   * Check if two time ranges overlap\n   */\n  hasTimeOverlap(start1: Date, end1: Date, start2: Date, end2: Date): boolean {\n    return start1 < end2 && end1 > start2;\n  }\n\n  /**\n   * Validate that a proposed meeting time doesn't conflict\n   * Throws BadRequestException if conflicts are found\n   */\n  async validateNoConflicts(\n    therapistId: string,\n    clientId: string,\n    startTime: Date,\n    duration: number,\n  ): Promise<void> {\n    const conflicts = await this.checkSchedulingConflicts(\n      therapistId,\n      clientId,\n      startTime,\n      duration,\n    );\n\n    if (conflicts.hasConflict) {\n      const conflictMessages = conflicts.conflictingMeetings.map((meeting) => {\n        const meetingStart = meeting.startTime.toLocaleString();\n        const meetingEnd = new Date(\n          meeting.startTime.getTime() + meeting.duration * 60000,\n        ).toLocaleString();\n        return `Meeting from ${meetingStart} to ${meetingEnd}`;\n      });\n\n      throw new BadRequestException(\n        `Time slot conflicts with existing meetings: ${conflictMessages.join(', ')}`,\n      );\n    }\n  }\n}\n"],"version":3}