{"file":"/home/wetooa/Documents/code/projects/mentara/mentara-api/src/auth/services/email-verification.service.ts","mappings":"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","names":[],"sources":["/home/wetooa/Documents/code/projects/mentara/mentara-api/src/auth/services/email-verification.service.ts"],"sourcesContent":["import {\n  Injectable,\n  BadRequestException,\n  NotFoundException,\n} from '@nestjs/common';\nimport { PrismaService } from '../../providers/prisma-client.provider';\nimport { EmailService } from '../../services/email.service';\nimport { TokenService } from './token.service';\nimport * as crypto from 'crypto';\n\n@Injectable()\nexport class EmailVerificationService {\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly emailService: EmailService,\n    private readonly tokenService: TokenService,\n  ) {}\n\n  async sendVerificationEmail(userId: string): Promise<void> {\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n      select: {\n        id: true,\n        email: true,\n        firstName: true,\n        emailVerified: true,\n        emailVerifyToken: true,\n        emailVerifyTokenExp: true,\n      },\n    });\n\n    if (!user) {\n      throw new NotFoundException('User not found');\n    }\n\n    if (user.emailVerified) {\n      throw new BadRequestException('Email already verified');\n    }\n\n    // Check if there's an existing valid token\n    if (\n      user.emailVerifyToken &&\n      user.emailVerifyTokenExp &&\n      user.emailVerifyTokenExp > new Date()\n    ) {\n      // Resend existing token (rate limiting would be handled at controller level)\n      await this.sendVerificationEmailWithToken(\n        user.email,\n        user.firstName,\n        user.emailVerifyToken,\n      );\n      return;\n    }\n\n    // Generate new verification token\n    const { token, hashedToken, expiresAt } =\n      await this.tokenService.generateEmailVerificationToken();\n\n    // Update user with new token\n    await this.prisma.user.update({\n      where: { id: userId },\n      data: {\n        emailVerifyToken: hashedToken,\n        emailVerifyTokenExp: expiresAt,\n      },\n    });\n\n    // Send verification email\n    await this.sendVerificationEmailWithToken(\n      user.email,\n      user.firstName,\n      token,\n    );\n  }\n\n  async verifyEmail(\n    token: string,\n  ): Promise<{ success: boolean; message: string }> {\n    if (!token) {\n      throw new BadRequestException('Verification token is required');\n    }\n\n    const hashedToken = crypto.createHash('sha256').update(token).digest('hex');\n\n    const user = await this.prisma.user.findUnique({\n      where: { emailVerifyToken: hashedToken },\n      select: {\n        id: true,\n        email: true,\n        emailVerified: true,\n        emailVerifyTokenExp: true,\n      },\n    });\n\n    if (!user) {\n      throw new BadRequestException('Invalid verification token');\n    }\n\n    if (user.emailVerified) {\n      return {\n        success: true,\n        message: 'Email already verified',\n      };\n    }\n\n    if (!user.emailVerifyTokenExp || user.emailVerifyTokenExp < new Date()) {\n      // Clean up expired token\n      await this.prisma.user.update({\n        where: { id: user.id },\n        data: {\n          emailVerifyToken: null,\n          emailVerifyTokenExp: null,\n        },\n      });\n      throw new BadRequestException('Verification token has expired');\n    }\n\n    // Verify the email\n    await this.prisma.user.update({\n      where: { id: user.id },\n      data: {\n        emailVerified: true,\n        emailVerifyToken: null,\n        emailVerifyTokenExp: null,\n        isVerified: true, // Update general verification status\n      },\n    });\n\n    return {\n      success: true,\n      message: 'Email verified successfully',\n    };\n  }\n\n  async resendVerificationEmail(email: string): Promise<void> {\n    const user = await this.prisma.user.findUnique({\n      where: { email },\n      select: {\n        id: true,\n        email: true,\n        firstName: true,\n        emailVerified: true,\n      },\n    });\n\n    if (!user) {\n      // Don't reveal if email exists for security\n      return;\n    }\n\n    if (user.emailVerified) {\n      throw new BadRequestException('Email already verified');\n    }\n\n    await this.sendVerificationEmail(user.id);\n  }\n\n  private async sendVerificationEmailWithToken(\n    email: string,\n    firstName: string,\n    token: string,\n  ): Promise<void> {\n    const verificationUrl = `${process.env.FRONTEND_URL}/verify-email?token=${token}`;\n\n    try {\n      await this.emailService.sendGenericEmail({\n        to: email,\n        subject: 'Verify Your Mentara Account',\n        template: 'email-verification',\n        data: {\n          firstName,\n          verificationUrl,\n          supportEmail: process.env.SUPPORT_EMAIL || 'support@mentara.com',\n        },\n      });\n    } catch (error) {\n      console.error('Failed to send verification email:', error);\n      throw new BadRequestException('Failed to send verification email');\n    }\n  }\n\n  async cleanupExpiredTokens(): Promise<void> {\n    await this.prisma.user.updateMany({\n      where: {\n        emailVerifyTokenExp: {\n          lt: new Date(),\n        },\n      },\n      data: {\n        emailVerifyToken: null,\n        emailVerifyTokenExp: null,\n      },\n    });\n  }\n}\n"],"version":3}