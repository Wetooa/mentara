{"file":"/home/wetooa/Documents/code/projects/mentara/mentara-api/src/therapist/services/advanced-matching.service.ts","mappings":"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","names":[],"sources":["/home/wetooa/Documents/code/projects/mentara/mentara-api/src/therapist/services/advanced-matching.service.ts"],"sourcesContent":["import { Injectable } from '@nestjs/common';\nimport { PrismaService } from '../../providers/prisma-client.provider';\nimport {\n  PreAssessment,\n  Therapist,\n  Client,\n  User,\n  Review,\n  ClientPreference,\n} from '@prisma/client';\n\n// Type definitions for matching service\nexport type UserForMatching = Pick<\n  User,\n  'firstName' | 'lastName' | 'avatarUrl'\n>;\n\nexport type ReviewForMatching = Pick<Review, 'rating' | 'status'>;\n\nexport type ClientForMatching = Client & {\n  preAssessment: PreAssessment;\n  clientPreferences: ClientPreference[];\n  user: UserForMatching;\n};\n\nexport type TherapistForMatching = Therapist & {\n  user: UserForMatching;\n  reviews: ReviewForMatching[];\n};\n\nexport interface MatchingWeights {\n  conditionMatch: number; // 40%\n  approachCompatibility: number; // 25%\n  experienceAndSuccess: number; // 20%\n  reviewsAndRatings: number; // 10%\n  availabilityAndLogistics: number; // 5%\n}\n\nexport interface TherapistScore {\n  therapist: TherapistForMatching;\n  totalScore: number;\n  breakdown: {\n    conditionScore: number;\n    approachScore: number;\n    experienceScore: number;\n    reviewScore: number;\n    logisticsScore: number;\n  };\n  matchExplanation: {\n    primaryMatches: string[];\n    secondaryMatches: string[];\n    approachMatches: string[];\n    experienceYears: number;\n    averageRating: number;\n    totalReviews: number;\n    successRates: Record<string, number>;\n  };\n}\n\nexport interface SeverityMapping {\n  [key: string]: number;\n}\n\nexport interface UserConditionProfile {\n  primaryConditions: Array<{\n    condition: string;\n    severity: string;\n    weight: number;\n  }>;\n  secondaryConditions: Array<{\n    condition: string;\n    severity: string;\n    weight: number;\n  }>;\n  preferredApproaches: string[];\n  sessionPreferences: {\n    format: string[]; // online, in-person, hybrid\n    duration: string[];\n    frequency: string;\n  };\n  demographics: {\n    ageRange: string;\n    genderPreference?: string;\n    languagePreference: string[];\n  };\n  logistics: {\n    maxHourlyRate?: number;\n    province?: string;\n    insuranceTypes?: string[];\n  };\n}\n\n@Injectable()\nexport class AdvancedMatchingService {\n  private readonly defaultWeights: MatchingWeights = {\n    conditionMatch: 0.4,\n    approachCompatibility: 0.25,\n    experienceAndSuccess: 0.2,\n    reviewsAndRatings: 0.1,\n    availabilityAndLogistics: 0.05,\n  };\n\n  private readonly severityWeights: SeverityMapping = {\n    // Depression/Anxiety scales\n    Minimal: 1,\n    Mild: 2,\n    Moderate: 3,\n    'Moderately Severe': 4,\n    Severe: 5,\n    'Very Severe': 5,\n    Extreme: 5,\n\n    // General severity levels\n    Low: 1,\n    High: 4,\n    Substantial: 4,\n\n    // Clinical thresholds\n    Subclinical: 1,\n    Clinical: 4,\n    Subthreshold: 2,\n\n    // Binary indicators\n    Positive: 4,\n    Negative: 0,\n    None: 0,\n  };\n\n  constructor(private readonly prisma: PrismaService) {}\n\n  async calculateAdvancedMatch(\n    client: ClientForMatching,\n    therapist: TherapistForMatching,\n    weights: MatchingWeights = this.defaultWeights,\n  ): Promise<TherapistScore> {\n    // Input validation to prevent runtime errors\n    if (!client?.preAssessment) {\n      throw new Error('Client must have a valid pre-assessment');\n    }\n\n    if (!client.clientPreferences) {\n      throw new Error('Client preferences are required for matching');\n    }\n\n    if (!therapist?.user) {\n      throw new Error('Therapist must have valid user information');\n    }\n    // Build user condition profile\n    const userProfile = this.buildUserConditionProfile(client);\n\n    // Calculate individual score components\n    const conditionScore = this.calculateConditionMatchScore(\n      userProfile,\n      therapist,\n    );\n    const approachScore = this.calculateApproachCompatibilityScore(\n      userProfile,\n      therapist,\n    );\n    const experienceScore = this.calculateExperienceAndSuccessScore(\n      userProfile,\n      therapist,\n    );\n    const reviewScore = await this.calculateReviewScore(therapist);\n    const logisticsScore = this.calculateLogisticsScore(userProfile, therapist);\n\n    // Calculate weighted total score\n    const totalScore = Math.round(\n      conditionScore * weights.conditionMatch +\n        approachScore * weights.approachCompatibility +\n        experienceScore * weights.experienceAndSuccess +\n        reviewScore * weights.reviewsAndRatings +\n        logisticsScore * weights.availabilityAndLogistics,\n    );\n\n    // Build match explanation\n    const matchExplanation = this.buildMatchExplanation(\n      userProfile,\n      therapist,\n      conditionScore,\n      approachScore,\n      experienceScore,\n      reviewScore,\n    );\n\n    return {\n      therapist,\n      totalScore,\n      breakdown: {\n        conditionScore: Math.round(conditionScore),\n        approachScore: Math.round(approachScore),\n        experienceScore: Math.round(experienceScore),\n        reviewScore: Math.round(reviewScore),\n        logisticsScore: Math.round(logisticsScore),\n      },\n      matchExplanation,\n    };\n  }\n\n  private buildUserConditionProfile(\n    client: ClientForMatching,\n  ): UserConditionProfile {\n    const severityLevels = client.preAssessment.severityLevels as Record<\n      string,\n      string\n    >;\n    const questionnaires = client.preAssessment.questionnaires as string[];\n\n    // Categorize conditions by severity\n    const primaryConditions: Array<{\n      condition: string;\n      severity: string;\n      weight: number;\n    }> = [];\n    const secondaryConditions: Array<{\n      condition: string;\n      severity: string;\n      weight: number;\n    }> = [];\n\n    questionnaires.forEach((condition) => {\n      const severity = severityLevels[condition];\n      const weight = this.severityWeights[severity] || 1;\n\n      if (weight >= 4) {\n        primaryConditions.push({ condition, severity, weight });\n      } else if (weight >= 2) {\n        secondaryConditions.push({ condition, severity, weight });\n      }\n    });\n\n    // Extract preferences from client preferences\n    const preferences = this.parseClientPreferences(client.clientPreferences);\n\n    return {\n      primaryConditions,\n      secondaryConditions,\n      preferredApproaches: preferences.approaches || [],\n      sessionPreferences: {\n        format: preferences.sessionFormat || ['online', 'in-person'],\n        duration: preferences.sessionDuration || [],\n        frequency: preferences.sessionFrequency || 'weekly',\n      },\n      demographics: {\n        ageRange: preferences.therapistAge || 'any',\n        genderPreference: preferences.therapistGender,\n        languagePreference: preferences.languages || ['English'],\n      },\n      logistics: {\n        maxHourlyRate: preferences.maxBudget,\n        province: preferences.location,\n        insuranceTypes: preferences.insurance || [],\n      },\n    };\n  }\n\n  /**\n   * Calculates how well a therapist's expertise matches the client's mental health conditions.\n   *\n   * Scoring Logic:\n   * - Primary conditions (severe, clinical): 30 points base, scaled by severity weight (1-5)\n   * - Secondary conditions (moderate): 15 points base, scaled by severity weight\n   * - Expertise depth bonus: 5 points per matched condition, max 20 bonus points\n   * - Total score capped at 100 points\n   *\n   * @param userProfile Client's condition profile with severity weights\n   * @param therapist Therapist with expertise and specialization arrays\n   * @returns Score from 0-100 indicating condition match quality\n   */\n  private calculateConditionMatchScore(\n    userProfile: UserConditionProfile,\n    therapist: Therapist,\n  ): number {\n    let score = 0;\n    const expertise = therapist.expertise || [];\n    const specializations = therapist.illnessSpecializations || [];\n    const allTherapistConditions = [...expertise, ...specializations];\n\n    // Primary conditions scoring: most critical conditions get highest weight\n    // Base score of 30 points, multiplied by severity ratio (weight/5)\n    // Example: Severe depression (weight=5) = 30 * (5/5) = 30 points\n    // Example: Moderate anxiety (weight=3) = 30 * (3/5) = 18 points\n    userProfile.primaryConditions.forEach(({ condition, weight }) => {\n      if (allTherapistConditions.includes(condition)) {\n        score += 30 * (weight / 5); // Scale by severity (1-5 range)\n      }\n    });\n\n    // Secondary conditions scoring: less critical but still important\n    // Base score of 15 points, also scaled by severity\n    userProfile.secondaryConditions.forEach(({ condition, weight }) => {\n      if (allTherapistConditions.includes(condition)) {\n        score += 15 * (weight / 5); // Scale by severity (1-5 range)\n      }\n    });\n\n    // Expertise depth bonus: reward therapists who match multiple conditions\n    // This indicates broader competency in the client's problem areas\n    const matchedConditions = [\n      ...userProfile.primaryConditions.map((c) => c.condition),\n      ...userProfile.secondaryConditions.map((c) => c.condition),\n    ].filter((condition) => allTherapistConditions.includes(condition));\n\n    // 5 points per matched condition, capped at 20 to prevent overweighting\n    const expertiseDepthBonus = Math.min(matchedConditions.length * 5, 20);\n    score += expertiseDepthBonus;\n\n    // Cap final score at 100 to maintain consistent scoring scale\n    return Math.min(score, 100);\n  }\n\n  private calculateApproachCompatibilityScore(\n    userProfile: UserConditionProfile,\n    therapist: Therapist,\n  ): number {\n    let score = 0;\n    const therapistApproaches = therapist.approaches || [];\n    const therapistApproachesList =\n      therapist.therapeuticApproachesUsedList || [];\n    const allApproaches = [...therapistApproaches, ...therapistApproachesList];\n\n    // If user has preferred approaches, match them\n    if (userProfile.preferredApproaches.length > 0) {\n      const matchedApproaches = userProfile.preferredApproaches.filter(\n        (approach) => allApproaches.includes(approach),\n      );\n\n      score =\n        (matchedApproaches.length / userProfile.preferredApproaches.length) *\n        100;\n    } else {\n      // If no preference specified, give points for evidence-based approaches\n      const evidenceBasedApproaches = [\n        'Cognitive Behavioral Therapy (CBT)',\n        'Dialectical Behavior Therapy (DBT)',\n        'Acceptance and Commitment Therapy (ACT)',\n        'Eye Movement Desensitization and Reprocessing (EMDR)',\n        'Mindfulness-Based Cognitive Therapy (MBCT)',\n      ];\n\n      const evidenceBasedCount = allApproaches.filter((approach) =>\n        evidenceBasedApproaches.includes(approach),\n      ).length;\n\n      score = Math.min(evidenceBasedCount * 20, 80); // Max 80 for general evidence-based\n    }\n\n    // Bonus for comprehensive approach diversity\n    const diversityBonus = Math.min(allApproaches.length * 2, 20);\n    score += diversityBonus;\n\n    return Math.min(score, 100);\n  }\n\n  /**\n   * Calculates therapist experience and success rate score using a diminishing returns curve.\n   *\n   * Experience Scoring (70-90 points):\n   * - Years 0-5: 8 points per year (0-40 points) - new therapist learning curve\n   * - Years 5-10: 6 points per year (40-70 points) - experienced but still growing\n   * - Years 10+: 2 points per year (70-90 points, max 20 bonus) - diminishing returns\n   *\n   * Success Rate Bonus (0-20 points):\n   * - Based on therapist's documented success rates for client's specific conditions\n   * - Averages success rates across all relevant conditions\n   * - Scales linearly: 80% success rate = 16 bonus points\n   *\n   * @param userProfile Client's condition profile\n   * @param therapist Therapist with experience and success rate data\n   * @returns Score from 0-100 indicating experience quality\n   */\n  private calculateExperienceAndSuccessScore(\n    userProfile: UserConditionProfile,\n    therapist: Therapist,\n  ): number {\n    let score = 0;\n\n    // Calculate total years of experience from multiple sources\n    const yearsExperience = this.calculateYearsOfExperience(\n      therapist.practiceStartDate,\n    );\n    const additionalYears = therapist.yearsOfExperience || 0;\n    const totalYears = Math.max(yearsExperience, additionalYears);\n\n    // Experience scoring with diminishing returns curve\n    // Reflects that experience gains are most valuable early in career\n    if (totalYears <= 5) {\n      // New therapists: high learning curve, significant improvement per year\n      score += totalYears * 8; // 0-40 points for 0-5 years\n    } else if (totalYears <= 10) {\n      // Experienced therapists: still gaining skills but at slower rate\n      score += 40 + (totalYears - 5) * 6; // 40-70 points for 5-10 years\n    } else {\n      // Senior therapists: diminishing returns, max practical benefit around 15-20 years\n      score += 70 + Math.min((totalYears - 10) * 2, 20); // 70-90 points for 10+ years\n    }\n\n    // Treatment success rates bonus: reward documented effectiveness\n    // Only considers success rates for conditions relevant to this specific client\n    const successRates =\n      (therapist.treatmentSuccessRates as Record<string, number>) || {};\n    const relevantConditions = [\n      ...userProfile.primaryConditions.map((c) => c.condition),\n      ...userProfile.secondaryConditions.map((c) => c.condition),\n    ];\n\n    let successRateBonus = 0;\n    let applicableRates = 0;\n\n    // Calculate average success rate across all relevant conditions\n    relevantConditions.forEach((condition) => {\n      if (successRates[condition] !== undefined) {\n        successRateBonus += successRates[condition];\n        applicableRates++;\n      }\n    });\n\n    if (applicableRates > 0) {\n      const averageSuccessRate = successRateBonus / applicableRates;\n      // Convert percentage to points: 100% success = 20 points, 50% = 10 points\n      score += (averageSuccessRate / 100) * 20; // Up to 20 bonus points\n    }\n\n    return Math.min(score, 100);\n  }\n\n  private async calculateReviewScore(\n    therapist: TherapistForMatching,\n  ): Promise<number> {\n    if (!therapist.reviews || therapist.reviews.length === 0) {\n      return 50; // Neutral score for new therapists\n    }\n\n    const approvedReviews = therapist.reviews.filter(\n      (review) => review.status === 'APPROVED',\n    );\n\n    if (approvedReviews.length === 0) {\n      return 50;\n    }\n\n    // Calculate average rating\n    const totalRating = approvedReviews.reduce(\n      (sum, review) => sum + review.rating,\n      0,\n    );\n    const averageRating = totalRating / approvedReviews.length;\n\n    // Convert 1-5 rating to 0-100 score\n    let score = ((averageRating - 1) / 4) * 100;\n\n    // Bonus for volume of reviews (credibility factor)\n    const volumeBonus = Math.min(approvedReviews.length * 2, 20);\n    score += volumeBonus;\n\n    // Penalty for very few reviews\n    if (approvedReviews.length < 3) {\n      score *= 0.8; // 20% penalty for low review count\n    }\n\n    return Math.min(score, 100);\n  }\n\n  private calculateLogisticsScore(\n    userProfile: UserConditionProfile,\n    therapist: Therapist,\n  ): number {\n    let score = 100; // Start with perfect score, deduct for mismatches\n\n    // Location matching\n    if (\n      userProfile.logistics.province &&\n      therapist.province !== userProfile.logistics.province\n    ) {\n      score -= 30; // Significant penalty for location mismatch\n    }\n\n    // Budget compatibility\n    if (\n      userProfile.logistics.maxHourlyRate &&\n      Number(therapist.hourlyRate) > userProfile.logistics.maxHourlyRate\n    ) {\n      score -= 40; // Major penalty for budget overrun\n    }\n\n    // Insurance compatibility\n    if (\n      userProfile.logistics.insuranceTypes &&\n      userProfile.logistics.insuranceTypes.length > 0\n    ) {\n      const acceptedTypes = therapist.acceptedInsuranceTypes || [];\n      const hasInsuranceMatch = userProfile.logistics.insuranceTypes.some(\n        (type) => acceptedTypes.includes(type),\n      );\n\n      if (!hasInsuranceMatch && therapist.acceptsInsurance) {\n        score -= 20; // Penalty for insurance mismatch\n      }\n    }\n\n    // Language compatibility\n    const therapistLanguages = therapist.languagesOffered || ['English'];\n    const hasLanguageMatch = userProfile.demographics.languagePreference.some(\n      (lang) => therapistLanguages.includes(lang),\n    );\n\n    if (!hasLanguageMatch) {\n      score -= 25; // Penalty for language barrier\n    }\n\n    return Math.max(score, 0);\n  }\n\n  private buildMatchExplanation(\n    userProfile: UserConditionProfile,\n    therapist: TherapistForMatching,\n    conditionScore: number,\n    approachScore: number,\n    experienceScore: number,\n    reviewScore: number,\n  ): TherapistScore['matchExplanation'] {\n    const expertise = therapist.expertise || [];\n    const specializations = therapist.illnessSpecializations || [];\n    const approaches = [\n      ...(therapist.approaches || []),\n      ...(therapist.therapeuticApproachesUsedList || []),\n    ];\n\n    const primaryMatches = userProfile.primaryConditions\n      .map((c) => c.condition)\n      .filter((condition) =>\n        [...expertise, ...specializations].includes(condition),\n      );\n\n    const secondaryMatches = userProfile.secondaryConditions\n      .map((c) => c.condition)\n      .filter((condition) =>\n        [...expertise, ...specializations].includes(condition),\n      );\n\n    const approachMatches = userProfile.preferredApproaches.filter((approach) =>\n      approaches.includes(approach),\n    );\n\n    const experienceYears = this.calculateYearsOfExperience(\n      therapist.practiceStartDate,\n    );\n\n    const approvedReviews =\n      therapist.reviews?.filter((r) => r.status === 'APPROVED') || [];\n    const averageRating =\n      approvedReviews.length > 0\n        ? approvedReviews.reduce((sum, r) => sum + r.rating, 0) /\n          approvedReviews.length\n        : 0;\n\n    const successRates =\n      (therapist.treatmentSuccessRates as Record<string, number>) || {};\n\n    return {\n      primaryMatches,\n      secondaryMatches,\n      approachMatches,\n      experienceYears: Math.max(\n        experienceYears,\n        therapist.yearsOfExperience || 0,\n      ),\n      averageRating: Math.round(averageRating * 10) / 10,\n      totalReviews: approvedReviews.length,\n      successRates,\n    };\n  }\n\n  private parseClientPreferences(\n    preferences: ClientPreference[],\n  ): Record<string, unknown> {\n    const parsed: Record<string, unknown> = {};\n\n    preferences.forEach((pref) => {\n      try {\n        // Handle JSON string values\n        if (typeof pref.value === 'string' && pref.value.startsWith('[')) {\n          parsed[pref.key] = JSON.parse(pref.value);\n        } else {\n          parsed[pref.key] = pref.value;\n        }\n      } catch (error) {\n        // Log parsing errors for debugging but continue with fallback\n        console.warn(`Failed to parse client preference ${pref.key}:`, error);\n        parsed[pref.key] = pref.value; // Fallback to raw value\n      }\n    });\n\n    return parsed;\n  }\n\n  private calculateYearsOfExperience(startDate: Date): number {\n    const now = new Date();\n    let years = now.getFullYear() - startDate.getFullYear();\n\n    if (\n      now.getMonth() < startDate.getMonth() ||\n      (now.getMonth() === startDate.getMonth() &&\n        now.getDate() < startDate.getDate())\n    ) {\n      years--;\n    }\n\n    return Math.max(years, 0);\n  }\n}\n"],"version":3}