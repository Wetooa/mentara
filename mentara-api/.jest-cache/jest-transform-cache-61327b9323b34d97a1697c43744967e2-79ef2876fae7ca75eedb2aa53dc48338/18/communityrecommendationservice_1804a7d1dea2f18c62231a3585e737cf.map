{"file":"/home/wetooa/Documents/code/projects/mentara/mentara-api/src/communities/services/community-recommendation.service.ts","mappings":"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","names":[],"sources":["/home/wetooa/Documents/code/projects/mentara/mentara-api/src/communities/services/community-recommendation.service.ts"],"sourcesContent":["import { Injectable, Logger, NotFoundException } from '@nestjs/common';\nimport { PrismaService } from '../../providers/prisma-client.provider';\nimport { CommunityMatchingService } from './community-matching.service';\n\ninterface CommunityRecommendation {\n  id: string;\n  name: string;\n  slug: string;\n  description: string;\n  imageUrl: string;\n  memberCount: number;\n  compatibilityScore: number;\n  score: number; // alias for compatibility\n  reason: string;\n  status: string; // calculated on-demand\n  createdAt: Date; // dummy values for compatibility\n  updatedAt: Date; // dummy values for compatibility\n}\n\n@Injectable()\nexport class CommunityRecommendationService {\n  private readonly logger = new Logger(CommunityRecommendationService.name);\n\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly communityMatching: CommunityMatchingService,\n  ) {}\n\n  /**\n   * Calculate community recommendations on-demand based on user's assessment data\n   */\n  async getUserRecommendations(\n    userId: string,\n  ): Promise<CommunityRecommendation[]> {\n    try {\n      // Get user's assessment data\n      const user = await this.prisma.user.findUnique({\n        where: { id: userId },\n        include: {\n          memberships: {\n            select: { communityId: true },\n          },\n        },\n      });\n\n      if (!user) {\n        throw new NotFoundException(`User ${userId} not found`);\n      }\n\n      // Get user's current communities to exclude from recommendations\n      const currentCommunityIds = user.memberships.map((m) => m.communityId);\n\n      // Get all available communities\n      const communities = await this.prisma.community.findMany({\n        where: {\n          id: { notIn: currentCommunityIds },\n        },\n        include: {\n          _count: {\n            select: { memberships: true },\n          },\n        },\n      });\n\n      // Calculate compatibility scores on-demand\n      const recommendations: CommunityRecommendation[] = [];\n\n      for (const community of communities) {\n        // Use the existing matching service to calculate compatibility\n        const compatibilityScore = await this.calculateCompatibilityScore(\n          [], // No assessment responses for now - simplified\n          community,\n        );\n\n        if (compatibilityScore > 0.3) {\n          // Only recommend if score is decent\n          const now = new Date();\n          recommendations.push({\n            id: community.id,\n            name: community.name,\n            slug: community.slug,\n            description: community.description,\n            imageUrl: community.imageUrl,\n            memberCount: community._count.memberships,\n            compatibilityScore,\n            score: compatibilityScore, // alias\n            reason: this.generateRecommendationReason(compatibilityScore),\n            status: 'pending', // calculated on-demand\n            createdAt: now, // dummy for compatibility\n            updatedAt: now, // dummy for compatibility\n          });\n        }\n      }\n\n      // Sort by compatibility score and return top 10\n      return recommendations\n        .sort((a, b) => b.compatibilityScore - a.compatibilityScore)\n        .slice(0, 10);\n    } catch (error) {\n      this.logger.error(\n        `Error getting recommendations for user ${userId}:`,\n        error,\n      );\n      return [];\n    }\n  }\n\n  private async calculateCompatibilityScore(\n    assessmentResponses: any[],\n    community: any,\n  ): Promise<number> {\n    // Simplified compatibility calculation\n    // In a real system, this would use the assessment responses to match with community characteristics\n    const baseScore = Math.random() * 0.8 + 0.2; // 0.2-1.0 for demo\n\n    // Factor in community size (smaller communities might be better matches)\n    const sizeBonus = community._count.memberships < 50 ? 0.1 : 0;\n\n    return Math.min(baseScore + sizeBonus, 1.0);\n  }\n\n  private generateRecommendationReason(score: number): string {\n    if (score > 0.8)\n      return 'Excellent match based on your assessment responses';\n    if (score > 0.6) return 'Good compatibility with your interests';\n    if (score > 0.4) return 'Potential good fit for your needs';\n    return 'Moderate compatibility';\n  }\n\n  /**\n   * Generate recommendations for a user (just returns the calculated ones)\n   */\n  async generateRecommendationsForUser(\n    userId: string,\n    force = false,\n  ): Promise<void> {\n    // No-op since we calculate on-demand\n    this.logger.log(\n      `Generated recommendations for user ${userId} (calculated on-demand)`,\n    );\n  }\n\n  /**\n   * Get a specific recommendation by ID (simplified)\n   */\n  async getRecommendationById(\n    recommendationId: string,\n  ): Promise<CommunityRecommendation | null> {\n    // Since we don't store recommendations, we can't fetch by ID\n    // In a real scenario, you'd need to recalculate or return null\n    return null;\n  }\n\n  /**\n   * Handle recommendation interaction (simplified)\n   */\n  async handleRecommendationInteraction(data: {\n    recommendationId: string;\n    action: string;\n    userId: string;\n  }): Promise<void> {\n    // No-op since we don't store interactions\n    this.logger.log(\n      `User ${data.userId} ${data.action}ed recommendation ${data.recommendationId}`,\n    );\n  }\n\n  /**\n   * Stub method for stats - simplified since no table to query\n   */\n  async getRecommendationStats(): Promise<any> {\n    return {\n      totalRecommendations: 0,\n      acceptedRecommendations: 0,\n      rejectedRecommendations: 0,\n      pendingRecommendations: 0,\n      averageCompatibilityScore: 0,\n      topCommunities: [],\n    };\n  }\n}\n"],"version":3}