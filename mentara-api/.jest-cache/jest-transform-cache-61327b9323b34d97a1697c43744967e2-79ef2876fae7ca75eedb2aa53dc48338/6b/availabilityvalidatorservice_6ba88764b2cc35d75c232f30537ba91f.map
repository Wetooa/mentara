{"file":"/home/wetooa/Documents/code/projects/mentara/mentara-api/src/booking/services/availability-validator.service.ts","mappings":"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","names":[],"sources":["/home/wetooa/Documents/code/projects/mentara/mentara-api/src/booking/services/availability-validator.service.ts"],"sourcesContent":["import { Injectable, BadRequestException } from '@nestjs/common';\nimport { PrismaService } from '../../providers/prisma-client.provider';\n\nexport interface ValidationConfig {\n  allowedDurations: number[]; // minutes\n  timeFormat: 'HH:MM' | 'HH:mm';\n  timezone: string;\n  businessHours: {\n    start: string; // HH:MM\n    end: string; // HH:MM\n  };\n  advanceBooking: {\n    minHours: number;\n    maxDays: number;\n  };\n  weekendBooking: boolean;\n}\n\n@Injectable()\nexport class AvailabilityValidatorService {\n  private readonly defaultConfig: ValidationConfig = {\n    allowedDurations: [30, 60, 90, 120],\n    timeFormat: 'HH:MM',\n    timezone: 'UTC',\n    businessHours: {\n      start: '08:00',\n      end: '20:00',\n    },\n    advanceBooking: {\n      minHours: 2,\n      maxDays: 90,\n    },\n    weekendBooking: true,\n  };\n\n  constructor(private readonly prisma: PrismaService) {}\n\n  /**\n   * Validate time format (HH:MM or HH:mm)\n   */\n  validateTimeFormat(\n    timeString: string,\n    format: 'HH:MM' | 'HH:mm' = 'HH:MM',\n  ): boolean {\n    const regex =\n      format === 'HH:MM'\n        ? /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/\n        : /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;\n\n    if (!regex.test(timeString)) {\n      throw new BadRequestException(\n        `Invalid time format. Expected ${format} format (e.g., 09:30)`,\n      );\n    }\n    return true;\n  }\n\n  /**\n   * Validate meeting duration\n   */\n  validateDuration(duration: number, allowedDurations?: number[]): boolean {\n    const allowed = allowedDurations || this.defaultConfig.allowedDurations;\n\n    if (!allowed.includes(duration)) {\n      throw new BadRequestException(\n        `Invalid duration. Allowed durations are: ${allowed.join(', ')} minutes`,\n      );\n    }\n    return true;\n  }\n\n  /**\n   * Validate booking date and time constraints\n   */\n  validateBookingDateTime(\n    startTime: Date,\n    duration: number,\n    config: Partial<ValidationConfig> = {},\n  ): boolean {\n    const finalConfig = { ...this.defaultConfig, ...config };\n\n    this.validateAdvanceBooking(startTime, finalConfig);\n    this.validateBusinessHours(startTime, duration, finalConfig);\n    this.validateWeekendBooking(startTime, finalConfig);\n    this.validateDuration(duration, finalConfig.allowedDurations);\n\n    return true;\n  }\n\n  /**\n   * Validate advance booking constraints\n   */\n  private validateAdvanceBooking(\n    startTime: Date,\n    config: ValidationConfig,\n  ): void {\n    const now = new Date();\n    const timeDiff = startTime.getTime() - now.getTime();\n    const hoursDiff = timeDiff / (1000 * 60 * 60);\n    const daysDiff = timeDiff / (1000 * 60 * 60 * 24);\n\n    if (hoursDiff < config.advanceBooking.minHours) {\n      throw new BadRequestException(\n        `Bookings must be made at least ${config.advanceBooking.minHours} hours in advance`,\n      );\n    }\n\n    if (daysDiff > config.advanceBooking.maxDays) {\n      throw new BadRequestException(\n        `Bookings can only be made up to ${config.advanceBooking.maxDays} days in advance`,\n      );\n    }\n  }\n\n  /**\n   * Validate business hours constraints\n   */\n  private validateBusinessHours(\n    startTime: Date,\n    duration: number,\n    config: ValidationConfig,\n  ): void {\n    const endTime = new Date(startTime.getTime() + duration * 60 * 1000);\n\n    const startTimeStr = this.formatTime(startTime);\n    const endTimeStr = this.formatTime(endTime);\n\n    if (\n      startTimeStr < config.businessHours.start ||\n      endTimeStr > config.businessHours.end\n    ) {\n      throw new BadRequestException(\n        `Meeting must be within business hours (${config.businessHours.start} - ${config.businessHours.end})`,\n      );\n    }\n  }\n\n  /**\n   * Validate weekend booking if not allowed\n   */\n  private validateWeekendBooking(\n    startTime: Date,\n    config: ValidationConfig,\n  ): void {\n    if (!config.weekendBooking) {\n      const dayOfWeek = startTime.getDay();\n      if (dayOfWeek === 0 || dayOfWeek === 6) {\n        // Sunday = 0, Saturday = 6\n        throw new BadRequestException('Weekend bookings are not allowed');\n      }\n    }\n  }\n\n  /**\n   * Check if therapist is available at the specified time\n   */\n\n  /**\n   * Validate therapist availability with transaction support (simplified UTC-only version)\n   */\n  async validateTherapistAvailabilityWithTransaction(\n    therapistId: string,\n    startTime: Date,\n    duration: number,\n    prismaClient: any, // Accept transaction client or regular prisma\n  ): Promise<boolean> {\n    // Simple UTC-based validation (no timezone conversion)\n    // Convert to numeric day string to match database schema (0=Sunday, 1=Monday, etc.)\n    const dayOfWeek = startTime.getDay().toString();\n    const startTimeStr = this.formatTime(startTime);\n    const endTime = new Date(startTime.getTime() + duration * 60 * 1000);\n    const endTimeStr = this.formatTime(endTime);\n\n    const availability = await prismaClient.therapistAvailability.findFirst({\n      where: {\n        therapistId,\n        dayOfWeek,\n        startTime: { lte: startTimeStr },\n        endTime: { gte: endTimeStr },\n        isAvailable: true,\n      },\n    });\n\n    if (!availability) {\n      throw new BadRequestException(\n        `Therapist is not available at the requested time (${startTimeStr}-${endTimeStr} on day ${dayOfWeek} UTC)`,\n      );\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if therapist is available at the specified time\n   */\n  async validateTherapistAvailability(\n    therapistId: string,\n    startTime: Date,\n    duration: number,\n  ): Promise<boolean> {\n    // Convert to numeric day string to match database schema (0=Sunday, 1=Monday, etc.)\n    const dayOfWeek = startTime.getDay().toString();\n    const startTimeStr = this.formatTime(startTime);\n    const endTime = new Date(startTime.getTime() + duration * 60 * 1000);\n    const endTimeStr = this.formatTime(endTime);\n\n    const availability = await this.prisma.therapistAvailability.findFirst({\n      where: {\n        therapistId,\n        dayOfWeek,\n        startTime: { lte: startTimeStr },\n        endTime: { gte: endTimeStr },\n        isAvailable: true,\n      },\n    });\n\n    if (!availability) {\n      throw new BadRequestException(\n        'Therapist is not available at the requested time',\n      );\n    }\n\n    return true;\n  }\n\n  /**\n   * Validate client-therapist relationship exists\n   */\n  async validateClientTherapistRelationship(\n    clientId: string,\n    therapistId: string,\n  ): Promise<boolean> {\n    const relationship = await this.prisma.clientTherapist.findFirst({\n      where: {\n        clientId,\n        therapistId,\n      },\n    });\n\n    if (!relationship) {\n      throw new BadRequestException(\n        'You can only book sessions with your assigned therapists',\n      );\n    }\n\n    return true;\n  }\n\n  /**\n   * Validate therapist exists and is active\n   */\n  async validateTherapistExists(therapistId: string): Promise<boolean> {\n    const therapist = await this.prisma.therapist.findFirst({\n      where: {\n        userId: therapistId,\n        status: 'APPROVED',\n      },\n      include: {\n        user: {\n          select: {\n            isActive: true,\n          },\n        },\n      },\n    });\n\n    if (!therapist || !therapist.user.isActive) {\n      throw new BadRequestException('Therapist not found or inactive');\n    }\n\n    return true;\n  }\n\n  /**\n   * Validate availability slot overlap\n   */\n  validateAvailabilityOverlap(\n    startTime1: string,\n    endTime1: string,\n    startTime2: string,\n    endTime2: string,\n  ): boolean {\n    if (startTime1 >= endTime1) {\n      throw new BadRequestException('Start time must be before end time');\n    }\n\n    if (startTime2 >= endTime2) {\n      throw new BadRequestException('Start time must be before end time');\n    }\n\n    const hasOverlap = startTime1 < endTime2 && endTime1 > startTime2;\n\n    if (hasOverlap) {\n      throw new BadRequestException(\n        'Availability slot overlaps with existing availability',\n      );\n    }\n\n    return true;\n  }\n\n  /**\n   * Validate timezone (if timezone support is needed)\n   */\n  validateTimezone(timezone: string): boolean {\n    try {\n      // Check if timezone is valid\n      Intl.DateTimeFormat(undefined, { timeZone: timezone });\n      return true;\n    } catch {\n      throw new BadRequestException(`Invalid timezone: ${timezone}`);\n    }\n  }\n\n  /**\n   * Comprehensive validation for meeting creation\n   */\n  async validateMeetingCreation({\n    therapistId,\n    clientId,\n    startTime,\n    duration,\n    config = {},\n  }: {\n    therapistId: string;\n    clientId: string;\n    startTime: Date;\n    duration: number;\n    config?: Partial<ValidationConfig>;\n  }): Promise<boolean> {\n    // Run all validations\n    await Promise.all([\n      this.validateTherapistExists(therapistId),\n      this.validateClientTherapistRelationship(clientId, therapistId),\n      this.validateTherapistAvailability(therapistId, startTime, duration),\n    ]);\n\n    this.validateBookingDateTime(startTime, duration, config);\n\n    return true;\n  }\n\n  /**\n   * Comprehensive validation for availability creation\n   */\n  async validateAvailabilityCreation({\n    therapistId,\n    dayOfWeek,\n    startTime,\n    endTime,\n  }: {\n    therapistId: string;\n    dayOfWeek: number;\n    startTime: string;\n    endTime: string;\n  }): Promise<boolean> {\n    // Validate therapist exists\n    await this.validateTherapistExists(therapistId);\n\n    // Validate time formats\n    this.validateTimeFormat(startTime);\n    this.validateTimeFormat(endTime);\n\n    // Validate time range\n    if (startTime >= endTime) {\n      throw new BadRequestException('Start time must be before end time');\n    }\n\n    // Validate day of week\n    if (dayOfWeek < 0 || dayOfWeek > 6) {\n      throw new BadRequestException(\n        'Day of week must be between 0 (Sunday) and 6 (Saturday)',\n      );\n    }\n\n    // Convert numeric day to day name string to match database schema\n    const dayOfWeekString = new Date(2024, 0, dayOfWeek) // Use dummy date with desired day\n      .toLocaleDateString('en-US', { weekday: 'long' })\n      .toUpperCase();\n\n    // Check for overlapping availability\n    const overlapping = await this.prisma.therapistAvailability.findFirst({\n      where: {\n        therapistId,\n        dayOfWeek: dayOfWeekString,\n        OR: [\n          {\n            startTime: { lt: endTime },\n            endTime: { gt: startTime },\n          },\n        ],\n      },\n    });\n\n    if (overlapping) {\n      throw new BadRequestException(\n        'Availability slot overlaps with existing availability',\n      );\n    }\n\n    return true;\n  }\n\n  /**\n   * Format Date to HH:MM string\n   */\n  private formatTime(date: Date): string {\n    return date.toTimeString().slice(0, 5);\n  }\n\n  /**\n   * Parse time string to minutes since midnight\n   */\n  private parseTimeToMinutes(timeString: string): number {\n    const [hours, minutes] = timeString.split(':').map(Number);\n    return hours * 60 + minutes;\n  }\n\n  /**\n   * Convert minutes since midnight to HH:MM string\n   */\n  private minutesToTimeString(minutes: number): string {\n    const hours = Math.floor(minutes / 60);\n    const mins = minutes % 60;\n    return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;\n  }\n}\n"],"version":3}