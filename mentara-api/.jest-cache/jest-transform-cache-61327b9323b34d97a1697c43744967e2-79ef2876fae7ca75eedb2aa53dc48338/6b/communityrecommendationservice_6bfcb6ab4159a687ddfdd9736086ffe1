d6d12cc74204174b91f1ca6d8d951530
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var CommunityRecommendationService_1;
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommunityRecommendationService = void 0;
const common_1 = require("@nestjs/common");
const prisma_client_provider_1 = require("../../providers/prisma-client.provider");
const community_matching_service_1 = require("./community-matching.service");
const community_configs_1 = require("../../config/community-configs");
const ai_service_client_1 = require("../../pre-assessment/services/ai-service.client");
let CommunityRecommendationService = CommunityRecommendationService_1 = class CommunityRecommendationService {
    prisma;
    communityMatching;
    aiServiceClient;
    logger = new common_1.Logger(CommunityRecommendationService_1.name);
    constructor(prisma, communityMatching, aiServiceClient) {
        this.prisma = prisma;
        this.communityMatching = communityMatching;
        this.aiServiceClient = aiServiceClient;
    }
    /**
     * Calculate community recommendations based on AI disorder predictions from user's assessment
     */
    async getUserRecommendations(userId) {
        try {
            // Get user's data including preassessment and current memberships
            const user = await this.prisma.user.findUnique({
                where: { id: userId },
                include: {
                    client: {
                        include: {
                            preAssessment: true,
                        },
                    },
                    memberships: {
                        select: { communityId: true },
                    },
                },
            });
            if (!user || !user.client) {
                throw new common_1.NotFoundException(`User ${userId} not found or not a client`);
            }
            // Check if user has completed preassessment
            if (!user.client.preAssessment) {
                this.logger.warn(`No preassessment found for user ${userId}`);
                return this.getFallbackRecommendations(userId);
            }
            // Get AI disorder predictions from preassessment data
            let disorderPredictions = {};
            try {
                const assessmentAnswers = user.client.preAssessment.answers;
                if (assessmentAnswers?.questionnaires && Array.isArray(assessmentAnswers.questionnaires)) {
                    const aiResult = await this.aiServiceClient.predict(assessmentAnswers.questionnaires);
                    disorderPredictions = aiResult.predictions || {};
                    this.logger.log(`AI predictions obtained for user ${userId}: ${Object.keys(disorderPredictions).filter(k => disorderPredictions[k]).join(', ')}`);
                }
                else {
                    this.logger.warn(`Invalid preassessment data format for user ${userId}`);
                    return this.getFallbackRecommendations(userId);
                }
            }
            catch (error) {
                this.logger.error(`Failed to get AI predictions for user ${userId}:`, error);
                return this.getFallbackRecommendations(userId);
            }
            // Get user's current communities to exclude from recommendations
            const currentCommunityIds = user.memberships.map((m) => m.communityId);
            // Get community recommendations based on AI predictions
            const aiRecommendations = (0, community_configs_1.getCommunityRecommendationsWithScores)(disorderPredictions);
            if (aiRecommendations.length === 0) {
                this.logger.log(`No AI-based recommendations for user ${userId}, using fallback`);
                return this.getFallbackRecommendations(userId);
            }
            // Get database communities that match recommendations
            const recommendedSlugs = aiRecommendations.map(rec => rec.slug);
            const communities = await this.prisma.community.findMany({
                where: {
                    slug: { in: recommendedSlugs },
                    id: { notIn: currentCommunityIds },
                },
                include: {
                    _count: {
                        select: { memberships: true },
                    },
                },
            });
            // Create final recommendations with real data
            const recommendations = [];
            const now = new Date();
            for (const community of communities) {
                const aiRec = aiRecommendations.find(rec => rec.slug === community.slug);
                if (aiRec) {
                    recommendations.push({
                        id: community.id,
                        name: community.name,
                        slug: community.slug,
                        description: community.description,
                        imageUrl: community.imageUrl || '/images/communities/default.jpg',
                        memberCount: community._count.memberships,
                        compatibilityScore: aiRec.score,
                        score: aiRec.score,
                        reason: this.generateAIBasedReason(disorderPredictions, aiRec.slug),
                        status: 'pending',
                        createdAt: now,
                        updatedAt: now,
                    });
                }
            }
            // Sort by AI compatibility score and return
            const sortedRecommendations = recommendations
                .sort((a, b) => b.compatibilityScore - a.compatibilityScore)
                .slice(0, 8); // Limit to top 8 recommendations
            this.logger.log(`Generated ${sortedRecommendations.length} AI-based community recommendations for user ${userId}`);
            return sortedRecommendations;
        }
        catch (error) {
            this.logger.error(`Error getting recommendations for user ${userId}:`, error);
            return this.getFallbackRecommendations(userId);
        }
    }
    async calculateCompatibilityScore(assessmentResponses, community) {
        // Simplified compatibility calculation
        // In a real system, this would use the assessment responses to match with community characteristics
        const baseScore = Math.random() * 0.8 + 0.2; // 0.2-1.0 for demo
        // Factor in community size (smaller communities might be better matches)
        const sizeBonus = community._count.memberships < 50 ? 0.1 : 0;
        return Math.min(baseScore + sizeBonus, 1.0);
    }
    generateRecommendationReason(score) {
        if (score > 0.8)
            return 'Excellent match based on your assessment responses';
        if (score > 0.6)
            return 'Good compatibility with your interests';
        if (score > 0.4)
            return 'Potential good fit for your needs';
        return 'Moderate compatibility';
    }
    /**
     * Generate AI-based recommendation reason
     */
    generateAIBasedReason(disorderPredictions, communitySlug) {
        const activeDisorders = Object.keys(disorderPredictions).filter(disorder => disorderPredictions[disorder]);
        const community = (0, community_configs_1.getCommunityBySlug)(communitySlug);
        if (!community) {
            return 'Recommended based on your assessment responses';
        }
        // Map common disorders to user-friendly terms
        const disorderNames = {
            Has_Depression: 'depression',
            Has_Anxiety: 'anxiety',
            Has_Social_Anxiety: 'social anxiety',
            Has_PTSD: 'PTSD',
            Has_Panic_Disorder: 'panic disorder',
            Has_Bipolar: 'bipolar disorder',
            Has_OCD: 'OCD',
            Has_Insomnia: 'sleep issues',
            Has_High_Stress: 'stress',
            Has_Burnout: 'burnout',
            Has_Binge_Eating: 'eating concerns',
            Has_ADHD: 'ADHD',
            Has_Alcohol_Problem: 'alcohol concerns',
            Has_Drug_Problem: 'substance concerns',
            Has_Phobia: 'phobias',
            Has_Agoraphobia: 'agoraphobia',
            Has_BloodPhobia: 'blood phobia',
            Has_SocialPhobia: 'social phobia',
            Has_Hoarding: 'hoarding tendencies',
        };
        const relevantDisorders = activeDisorders
            .filter(disorder => disorderNames[disorder])
            .map(disorder => disorderNames[disorder]);
        if (relevantDisorders.length > 0) {
            const disorderList = relevantDisorders.length === 1
                ? relevantDisorders[0]
                : relevantDisorders.slice(0, -1).join(', ') + ' and ' + relevantDisorders[relevantDisorders.length - 1];
            return `Recommended based on your ${disorderList} assessment results`;
        }
        return 'Recommended based on your mental health assessment';
    }
    /**
     * Get fallback community recommendations when AI predictions are not available
     */
    async getFallbackRecommendations(userId) {
        try {
            // Get user's current communities to exclude
            const user = await this.prisma.user.findUnique({
                where: { id: userId },
                include: {
                    memberships: {
                        select: { communityId: true },
                    },
                },
            });
            const currentCommunityIds = user?.memberships.map((m) => m.communityId) || [];
            // Get popular communities (by member count) as fallback
            const communities = await this.prisma.community.findMany({
                where: {
                    id: { notIn: currentCommunityIds },
                },
                include: {
                    _count: {
                        select: { memberships: true },
                    },
                },
                orderBy: {
                    memberships: {
                        _count: 'desc',
                    },
                },
                take: 6,
            });
            const now = new Date();
            return communities.map((community, index) => ({
                id: community.id,
                name: community.name,
                slug: community.slug,
                description: community.description,
                imageUrl: community.imageUrl || '/images/communities/default.jpg',
                memberCount: community._count.memberships,
                compatibilityScore: 0.6 - (index * 0.05), // Decreasing score based on popularity
                score: 0.6 - (index * 0.05),
                reason: 'Popular community that might interest you',
                status: 'pending',
                createdAt: now,
                updatedAt: now,
            }));
        }
        catch (error) {
            this.logger.error(`Error getting fallback recommendations for user ${userId}:`, error);
            return [];
        }
    }
    /**
     * Generate recommendations for a user (just returns the calculated ones)
     */
    async generateRecommendationsForUser(userId, force = false) {
        // No-op since we calculate on-demand
        this.logger.log(`Generated recommendations for user ${userId} (calculated on-demand)`);
    }
    /**
     * Get a specific recommendation by ID (simplified)
     */
    async getRecommendationById(recommendationId) {
        // Since we don't store recommendations, we can't fetch by ID
        // In a real scenario, you'd need to recalculate or return null
        return null;
    }
    /**
     * Handle recommendation interaction (simplified)
     */
    async handleRecommendationInteraction(data) {
        // No-op since we don't store interactions
        this.logger.log(`User ${data.userId} ${data.action}ed recommendation ${data.recommendationId}`);
    }
    /**
     * Stub method for stats - simplified since no table to query
     */
    async getRecommendationStats() {
        return {
            totalRecommendations: 0,
            acceptedRecommendations: 0,
            rejectedRecommendations: 0,
            pendingRecommendations: 0,
            averageCompatibilityScore: 0,
            topCommunities: [],
        };
    }
    /**
     * Join multiple recommended communities immediately
     */
    async joinRecommendedCommunities(userId, communitySlugs) {
        const successfulJoins = [];
        const failedJoins = [];
        for (const slug of communitySlugs) {
            try {
                // Find the community by slug
                const community = await this.prisma.community.findUnique({
                    where: { slug },
                    select: { id: true, name: true, slug: true }
                });
                if (!community) {
                    failedJoins.push({ slug, reason: 'Community not found' });
                    continue;
                }
                // Check if user is already a member
                const existingMembership = await this.prisma.membership.findUnique({
                    where: {
                        userId_communityId: {
                            userId,
                            communityId: community.id
                        }
                    }
                });
                if (existingMembership) {
                    failedJoins.push({ slug, reason: 'Already a member' });
                    continue;
                }
                // Create membership
                await this.prisma.membership.create({
                    data: {
                        userId,
                        communityId: community.id,
                        joinedAt: new Date()
                    }
                });
                successfulJoins.push({
                    communityId: community.id,
                    communityName: community.name,
                    slug: community.slug
                });
                this.logger.log(`User ${userId} successfully joined community ${community.name} (${slug})`);
            }
            catch (error) {
                this.logger.error(`Error joining community ${slug} for user ${userId}:`, error);
                failedJoins.push({
                    slug,
                    reason: error instanceof Error ? error.message : 'Unknown error'
                });
            }
        }
        this.logger.log(`Community join results for user ${userId}: ${successfulJoins.length} successful, ${failedJoins.length} failed`);
        return { successfulJoins, failedJoins };
    }
};
exports.CommunityRecommendationService = CommunityRecommendationService;
exports.CommunityRecommendationService = CommunityRecommendationService = CommunityRecommendationService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof prisma_client_provider_1.PrismaService !== "undefined" && prisma_client_provider_1.PrismaService) === "function" ? _a : Object, typeof (_b = typeof community_matching_service_1.CommunityMatchingService !== "undefined" && community_matching_service_1.CommunityMatchingService) === "function" ? _b : Object, typeof (_c = typeof ai_service_client_1.AiServiceClient !== "undefined" && ai_service_client_1.AiServiceClient) === "function" ? _c : Object])
], CommunityRecommendationService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvd2V0b29hL0RvY3VtZW50cy9jb2RlL3Byb2plY3RzL21lbnRhcmEvbWVudGFyYS1hcGkvc3JjL2NvbW11bml0aWVzL3NlcnZpY2VzL2NvbW11bml0eS1yZWNvbW1lbmRhdGlvbi5zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQXVFO0FBQ3ZFLG1GQUF1RTtBQUN2RSw2RUFBd0U7QUFDeEUsc0VBSXdDO0FBQ3hDLHVGQUFrRjtBQWtCM0UsSUFBTSw4QkFBOEIsc0NBQXBDLE1BQU0sOEJBQThCO0lBSXRCO0lBQ0E7SUFDQTtJQUxGLE1BQU0sR0FBRyxJQUFJLGVBQU0sQ0FBQyxnQ0FBOEIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUUxRSxZQUNtQixNQUFxQixFQUNyQixpQkFBMkMsRUFDM0MsZUFBZ0M7UUFGaEMsV0FBTSxHQUFOLE1BQU0sQ0FBZTtRQUNyQixzQkFBaUIsR0FBakIsaUJBQWlCLENBQTBCO1FBQzNDLG9CQUFlLEdBQWYsZUFBZSxDQUFpQjtJQUNoRCxDQUFDO0lBRUo7O09BRUc7SUFDSCxLQUFLLENBQUMsc0JBQXNCLENBQzFCLE1BQWM7UUFFZCxJQUFJLENBQUM7WUFDSCxrRUFBa0U7WUFDbEUsTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7Z0JBQzdDLEtBQUssRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUU7Z0JBQ3JCLE9BQU8sRUFBRTtvQkFDUCxNQUFNLEVBQUU7d0JBQ04sT0FBTyxFQUFFOzRCQUNQLGFBQWEsRUFBRSxJQUFJO3lCQUNwQjtxQkFDRjtvQkFDRCxXQUFXLEVBQUU7d0JBQ1gsTUFBTSxFQUFFLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRTtxQkFDOUI7aUJBQ0Y7YUFDRixDQUFDLENBQUM7WUFFSCxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUMxQixNQUFNLElBQUksMEJBQWlCLENBQUMs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LFNBQVMsQ0FBQyxJQUFJLEtBQUssSUFBSSxHQUFHLENBQUMsQ0FBQztZQUU5RixDQUFDO1lBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztnQkFDZixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQywyQkFBMkIsSUFBSSxhQUFhLE1BQU0sR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUNoRixXQUFXLENBQUMsSUFBSSxDQUFDO29CQUNmLElBQUk7b0JBQ0osTUFBTSxFQUFFLEtBQUssWUFBWSxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLGVBQWU7aUJBQ2pFLENBQUMsQ0FBQztZQUNMLENBQUM7UUFDSCxDQUFDO1FBRUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQ2IsbUNBQW1DLE1BQU0sS0FBSyxlQUFlLENBQUMsTUFBTSxnQkFBZ0IsV0FBVyxDQUFDLE1BQU0sU0FBUyxDQUNoSCxDQUFDO1FBRUYsT0FBTyxFQUFFLGVBQWUsRUFBRSxXQUFXLEVBQUUsQ0FBQztJQUMxQyxDQUFDO0NBQ0YsQ0FBQTtBQXpYWSx3RUFBOEI7eUNBQTlCLDhCQUE4QjtJQUQxQyxJQUFBLG1CQUFVLEdBQUU7eURBS2dCLHNDQUFhLG9CQUFiLHNDQUFhLG9EQUNGLHFEQUF3QixvQkFBeEIscURBQXdCLG9EQUMxQixtQ0FBZSxvQkFBZixtQ0FBZTtHQU54Qyw4QkFBOEIsQ0F5WDFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9ob21lL3dldG9vYS9Eb2N1bWVudHMvY29kZS9wcm9qZWN0cy9tZW50YXJhL21lbnRhcmEtYXBpL3NyYy9jb21tdW5pdGllcy9zZXJ2aWNlcy9jb21tdW5pdHktcmVjb21tZW5kYXRpb24uc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBMb2dnZXIsIE5vdEZvdW5kRXhjZXB0aW9uIH0gZnJvbSAnQG5lc3Rqcy9jb21tb24nO1xuaW1wb3J0IHsgUHJpc21hU2VydmljZSB9IGZyb20gJy4uLy4uL3Byb3ZpZGVycy9wcmlzbWEtY2xpZW50LnByb3ZpZGVyJztcbmltcG9ydCB7IENvbW11bml0eU1hdGNoaW5nU2VydmljZSB9IGZyb20gJy4vY29tbXVuaXR5LW1hdGNoaW5nLnNlcnZpY2UnO1xuaW1wb3J0IHsgXG4gIGdldENvbW11bml0eVJlY29tbWVuZGF0aW9uc1dpdGhTY29yZXMsXG4gIGdldENvbW11bml0eUJ5U2x1ZyxcbiAgSUxMTkVTU19DT01NVU5JVElFUyBcbn0gZnJvbSAnLi4vLi4vY29uZmlnL2NvbW11bml0eS1jb25maWdzJztcbmltcG9ydCB7IEFpU2VydmljZUNsaWVudCB9IGZyb20gJy4uLy4uL3ByZS1hc3Nlc3NtZW50L3NlcnZpY2VzL2FpLXNlcnZpY2UuY2xpZW50JztcblxuZXhwb3J0IGludGVyZmFjZSBDb21tdW5pdHlSZWNvbW1lbmRhdGlvbiB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgc2x1Zzogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICBpbWFnZVVybDogc3RyaW5nO1xuICBtZW1iZXJDb3VudDogbnVtYmVyO1xuICBjb21wYXRpYmlsaXR5U2NvcmU6IG51bWJlcjtcbiAgc2NvcmU6IG51bWJlcjsgLy8gYWxpYXMgZm9yIGNvbXBhdGliaWxpdHlcbiAgcmVhc29uOiBzdHJpbmc7XG4gIHN0YXR1czogc3RyaW5nOyAvLyBjYWxjdWxhdGVkIG9uLWRlbWFuZFxuICBjcmVhdGVkQXQ6IERhdGU7IC8vIGR1bW15IHZhbHVlcyBmb3IgY29tcGF0aWJpbGl0eVxuICB1cGRhdGVkQXQ6IERhdGU7IC8vIGR1bW15IHZhbHVlcyBmb3IgY29tcGF0aWJpbGl0eVxufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ29tbXVuaXR5UmVjb21tZW5kYXRpb25TZXJ2aWNlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBsb2dnZXIgPSBuZXcgTG9nZ2VyKENvbW11bml0eVJlY29tbWVuZGF0aW9uU2VydmljZS5uYW1lKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHByaXNtYTogUHJpc21hU2VydmljZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbW11bml0eU1hdGNoaW5nOiBDb21tdW5pdHlNYXRjaGluZ1NlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBhaVNlcnZpY2VDbGllbnQ6IEFpU2VydmljZUNsaWVudCxcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgY29tbXVuaXR5IHJlY29tbWVuZGF0aW9ucyBiYXNlZCBvbiBBSSBkaXNvcmRlciBwcmVkaWN0aW9ucyBmcm9tIHVzZXIncyBhc3Nlc3NtZW50XG4gICAqL1xuICBhc3luYyBnZXRVc2VyUmVjb21tZW5kYXRpb25zKFxuICAgIHVzZXJJZDogc3RyaW5nLFxuICApOiBQcm9taXNlPENvbW11bml0eVJlY29tbWVuZGF0aW9uW10+IHtcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IHVzZXIncyBkYXRhIGluY2x1ZGluZyBwcmVhc3Nlc3NtZW50IGFuZCBjdXJyZW50IG1lbWJlcnNoaXBzXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5wcmlzbWEudXNlci5maW5kVW5pcXVlKHtcbiAgICAgICAgd2hlcmU6IHsgaWQ6IHVzZXJJZCB9LFxuICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgY2xpZW50OiB7XG4gICAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICAgIHByZUFzc2Vzc21lbnQ6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWVtYmVyc2hpcHM6IHtcbiAgICAgICAgICAgIHNlbGVjdDogeyBjb21tdW5pdHlJZDogdHJ1ZSB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgaWYgKCF1c2VyIHx8ICF1c2VyLmNsaWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oYFVzZXIgJHt1c2VySWR9IG5vdCBmb3VuZCBvciBub3QgYSBjbGllbnRgKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdXNlciBoYXMgY29tcGxldGVkIHByZWFzc2Vzc21lbnRcbiAgICAgIGlmICghdXNlci5jbGllbnQucHJlQXNzZXNzbWVudCkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBObyBwcmVhc3Nlc3NtZW50IGZvdW5kIGZvciB1c2VyICR7dXNlcklkfWApO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGYWxsYmFja1JlY29tbWVuZGF0aW9ucyh1c2VySWQpO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgQUkgZGlzb3JkZXIgcHJlZGljdGlvbnMgZnJvbSBwcmVhc3Nlc3NtZW50IGRhdGFcbiAgICAgIGxldCBkaXNvcmRlclByZWRpY3Rpb25zOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPiA9IHt9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYXNzZXNzbWVudEFuc3dlcnMgPSB1c2VyLmNsaWVudC5wcmVBc3Nlc3NtZW50LmFuc3dlcnMgYXMgYW55O1xuICAgICAgICBpZiAoYXNzZXNzbWVudEFuc3dlcnM/LnF1ZXN0aW9ubmFpcmVzICYmIEFycmF5LmlzQXJyYXkoYXNzZXNzbWVudEFuc3dlcnMucXVlc3Rpb25uYWlyZXMpKSB7XG4gICAgICAgICAgY29uc3QgYWlSZXN1bHQgPSBhd2FpdCB0aGlzLmFpU2VydmljZUNsaWVudC5wcmVkaWN0KGFzc2Vzc21lbnRBbnN3ZXJzLnF1ZXN0aW9ubmFpcmVzKTtcbiAgICAgICAgICBkaXNvcmRlclByZWRpY3Rpb25zID0gYWlSZXN1bHQucHJlZGljdGlvbnMgfHwge307XG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKGBBSSBwcmVkaWN0aW9ucyBvYnRhaW5lZCBmb3IgdXNlciAke3VzZXJJZH06ICR7T2JqZWN0LmtleXMoZGlzb3JkZXJQcmVkaWN0aW9ucykuZmlsdGVyKGsgPT4gZGlzb3JkZXJQcmVkaWN0aW9uc1trXSkuam9pbignLCAnKX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBJbnZhbGlkIHByZWFzc2Vzc21lbnQgZGF0YSBmb3JtYXQgZm9yIHVzZXIgJHt1c2VySWR9YCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmFsbGJhY2tSZWNvbW1lbmRhdGlvbnModXNlcklkKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBnZXQgQUkgcHJlZGljdGlvbnMgZm9yIHVzZXIgJHt1c2VySWR9OmAsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmFsbGJhY2tSZWNvbW1lbmRhdGlvbnModXNlcklkKTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHVzZXIncyBjdXJyZW50IGNvbW11bml0aWVzIHRvIGV4Y2x1ZGUgZnJvbSByZWNvbW1lbmRhdGlvbnNcbiAgICAgIGNvbnN0IGN1cnJlbnRDb21tdW5pdHlJZHMgPSB1c2VyLm1lbWJlcnNoaXBzLm1hcCgobSkgPT4gbS5jb21tdW5pdHlJZCk7XG5cbiAgICAgIC8vIEdldCBjb21tdW5pdHkgcmVjb21tZW5kYXRpb25zIGJhc2VkIG9uIEFJIHByZWRpY3Rpb25zXG4gICAgICBjb25zdCBhaVJlY29tbWVuZGF0aW9ucyA9IGdldENvbW11bml0eVJlY29tbWVuZGF0aW9uc1dpdGhTY29yZXMoZGlzb3JkZXJQcmVkaWN0aW9ucyk7XG4gICAgICBcbiAgICAgIGlmIChhaVJlY29tbWVuZGF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKGBObyBBSS1iYXNlZCByZWNvbW1lbmRhdGlvbnMgZm9yIHVzZXIgJHt1c2VySWR9LCB1c2luZyBmYWxsYmFja2ApO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGYWxsYmFja1JlY29tbWVuZGF0aW9ucyh1c2VySWQpO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgZGF0YWJhc2UgY29tbXVuaXRpZXMgdGhhdCBtYXRjaCByZWNvbW1lbmRhdGlvbnNcbiAgICAgIGNvbnN0IHJlY29tbWVuZGVkU2x1Z3MgPSBhaVJlY29tbWVuZGF0aW9ucy5tYXAocmVjID0+IHJlYy5zbHVnKTtcbiAgICAgIGNvbnN0IGNvbW11bml0aWVzID0gYXdhaXQgdGhpcy5wcmlzbWEuY29tbXVuaXR5LmZpbmRNYW55KHtcbiAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICBzbHVnOiB7IGluOiByZWNvbW1lbmRlZFNsdWdzIH0sXG4gICAgICAgICAgaWQ6IHsgbm90SW46IGN1cnJlbnRDb21tdW5pdHlJZHMgfSxcbiAgICAgICAgfSxcbiAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgIF9jb3VudDoge1xuICAgICAgICAgICAgc2VsZWN0OiB7IG1lbWJlcnNoaXBzOiB0cnVlIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgZmluYWwgcmVjb21tZW5kYXRpb25zIHdpdGggcmVhbCBkYXRhXG4gICAgICBjb25zdCByZWNvbW1lbmRhdGlvbnM6IENvbW11bml0eVJlY29tbWVuZGF0aW9uW10gPSBbXTtcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG5cbiAgICAgIGZvciAoY29uc3QgY29tbXVuaXR5IG9mIGNvbW11bml0aWVzKSB7XG4gICAgICAgIGNvbnN0IGFpUmVjID0gYWlSZWNvbW1lbmRhdGlvbnMuZmluZChyZWMgPT4gcmVjLnNsdWcgPT09IGNvbW11bml0eS5zbHVnKTtcbiAgICAgICAgaWYgKGFpUmVjKSB7XG4gICAgICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgaWQ6IGNvbW11bml0eS5pZCxcbiAgICAgICAgICAgIG5hbWU6IGNvbW11bml0eS5uYW1lLFxuICAgICAgICAgICAgc2x1ZzogY29tbXVuaXR5LnNsdWcsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogY29tbXVuaXR5LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgaW1hZ2VVcmw6IGNvbW11bml0eS5pbWFnZVVybCB8fCAnL2ltYWdlcy9jb21tdW5pdGllcy9kZWZhdWx0LmpwZycsXG4gICAgICAgICAgICBtZW1iZXJDb3VudDogY29tbXVuaXR5Ll9jb3VudC5tZW1iZXJzaGlwcyxcbiAgICAgICAgICAgIGNvbXBhdGliaWxpdHlTY29yZTogYWlSZWMuc2NvcmUsXG4gICAgICAgICAgICBzY29yZTogYWlSZWMuc2NvcmUsXG4gICAgICAgICAgICByZWFzb246IHRoaXMuZ2VuZXJhdGVBSUJhc2VkUmVhc29uKGRpc29yZGVyUHJlZGljdGlvbnMsIGFpUmVjLnNsdWcpLFxuICAgICAgICAgICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IG5vdyxcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogbm93LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNvcnQgYnkgQUkgY29tcGF0aWJpbGl0eSBzY29yZSBhbmQgcmV0dXJuXG4gICAgICBjb25zdCBzb3J0ZWRSZWNvbW1lbmRhdGlvbnMgPSByZWNvbW1lbmRhdGlvbnNcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIuY29tcGF0aWJpbGl0eVNjb3JlIC0gYS5jb21wYXRpYmlsaXR5U2NvcmUpXG4gICAgICAgIC5zbGljZSgwLCA4KTsgLy8gTGltaXQgdG8gdG9wIDggcmVjb21tZW5kYXRpb25zXG5cbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhgR2VuZXJhdGVkICR7c29ydGVkUmVjb21tZW5kYXRpb25zLmxlbmd0aH0gQUktYmFzZWQgY29tbXVuaXR5IHJlY29tbWVuZGF0aW9ucyBmb3IgdXNlciAke3VzZXJJZH1gKTtcbiAgICAgIHJldHVybiBzb3J0ZWRSZWNvbW1lbmRhdGlvbnM7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgIGBFcnJvciBnZXR0aW5nIHJlY29tbWVuZGF0aW9ucyBmb3IgdXNlciAke3VzZXJJZH06YCxcbiAgICAgICAgZXJyb3IsXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RmFsbGJhY2tSZWNvbW1lbmRhdGlvbnModXNlcklkKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNhbGN1bGF0ZUNvbXBhdGliaWxpdHlTY29yZShcbiAgICBhc3Nlc3NtZW50UmVzcG9uc2VzOiBhbnlbXSxcbiAgICBjb21tdW5pdHk6IGFueSxcbiAgKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICAvLyBTaW1wbGlmaWVkIGNvbXBhdGliaWxpdHkgY2FsY3VsYXRpb25cbiAgICAvLyBJbiBhIHJlYWwgc3lzdGVtLCB0aGlzIHdvdWxkIHVzZSB0aGUgYXNzZXNzbWVudCByZXNwb25zZXMgdG8gbWF0Y2ggd2l0aCBjb21tdW5pdHkgY2hhcmFjdGVyaXN0aWNzXG4gICAgY29uc3QgYmFzZVNjb3JlID0gTWF0aC5yYW5kb20oKSAqIDAuOCArIDAuMjsgLy8gMC4yLTEuMCBmb3IgZGVtb1xuXG4gICAgLy8gRmFjdG9yIGluIGNvbW11bml0eSBzaXplIChzbWFsbGVyIGNvbW11bml0aWVzIG1pZ2h0IGJlIGJldHRlciBtYXRjaGVzKVxuICAgIGNvbnN0IHNpemVCb251cyA9IGNvbW11bml0eS5fY291bnQubWVtYmVyc2hpcHMgPCA1MCA/IDAuMSA6IDA7XG5cbiAgICByZXR1cm4gTWF0aC5taW4oYmFzZVNjb3JlICsgc2l6ZUJvbnVzLCAxLjApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZVJlY29tbWVuZGF0aW9uUmVhc29uKHNjb3JlOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGlmIChzY29yZSA+IDAuOClcbiAgICAgIHJldHVybiAnRXhjZWxsZW50IG1hdGNoIGJhc2VkIG9uIHlvdXIgYXNzZXNzbWVudCByZXNwb25zZXMnO1xuICAgIGlmIChzY29yZSA+IDAuNikgcmV0dXJuICdHb29kIGNvbXBhdGliaWxpdHkgd2l0aCB5b3VyIGludGVyZXN0cyc7XG4gICAgaWYgKHNjb3JlID4gMC40KSByZXR1cm4gJ1BvdGVudGlhbCBnb29kIGZpdCBmb3IgeW91ciBuZWVkcyc7XG4gICAgcmV0dXJuICdNb2RlcmF0ZSBjb21wYXRpYmlsaXR5JztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBBSS1iYXNlZCByZWNvbW1lbmRhdGlvbiByZWFzb25cbiAgICovXG4gIHByaXZhdGUgZ2VuZXJhdGVBSUJhc2VkUmVhc29uKGRpc29yZGVyUHJlZGljdGlvbnM6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+LCBjb21tdW5pdHlTbHVnOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGFjdGl2ZURpc29yZGVycyA9IE9iamVjdC5rZXlzKGRpc29yZGVyUHJlZGljdGlvbnMpLmZpbHRlcihkaXNvcmRlciA9PiBkaXNvcmRlclByZWRpY3Rpb25zW2Rpc29yZGVyXSk7XG4gICAgY29uc3QgY29tbXVuaXR5ID0gZ2V0Q29tbXVuaXR5QnlTbHVnKGNvbW11bml0eVNsdWcpO1xuICAgIFxuICAgIGlmICghY29tbXVuaXR5KSB7XG4gICAgICByZXR1cm4gJ1JlY29tbWVuZGVkIGJhc2VkIG9uIHlvdXIgYXNzZXNzbWVudCByZXNwb25zZXMnO1xuICAgIH1cblxuICAgIC8vIE1hcCBjb21tb24gZGlzb3JkZXJzIHRvIHVzZXItZnJpZW5kbHkgdGVybXNcbiAgICBjb25zdCBkaXNvcmRlck5hbWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgSGFzX0RlcHJlc3Npb246ICdkZXByZXNzaW9uJyxcbiAgICAgIEhhc19BbnhpZXR5OiAnYW54aWV0eScsXG4gICAgICBIYXNfU29jaWFsX0FueGlldHk6ICdzb2NpYWwgYW54aWV0eScsXG4gICAgICBIYXNfUFRTRDogJ1BUU0QnLFxuICAgICAgSGFzX1BhbmljX0Rpc29yZGVyOiAncGFuaWMgZGlzb3JkZXInLFxuICAgICAgSGFzX0JpcG9sYXI6ICdiaXBvbGFyIGRpc29yZGVyJyxcbiAgICAgIEhhc19PQ0Q6ICdPQ0QnLFxuICAgICAgSGFzX0luc29tbmlhOiAnc2xlZXAgaXNzdWVzJyxcbiAgICAgIEhhc19IaWdoX1N0cmVzczogJ3N0cmVzcycsXG4gICAgICBIYXNfQnVybm91dDogJ2J1cm5vdXQnLFxuICAgICAgSGFzX0JpbmdlX0VhdGluZzogJ2VhdGluZyBjb25jZXJucycsXG4gICAgICBIYXNfQURIRDogJ0FESEQnLFxuICAgICAgSGFzX0FsY29ob2xfUHJvYmxlbTogJ2FsY29ob2wgY29uY2VybnMnLFxuICAgICAgSGFzX0RydWdfUHJvYmxlbTogJ3N1YnN0YW5jZSBjb25jZXJucycsXG4gICAgICBIYXNfUGhvYmlhOiAncGhvYmlhcycsXG4gICAgICBIYXNfQWdvcmFwaG9iaWE6ICdhZ29yYXBob2JpYScsXG4gICAgICBIYXNfQmxvb2RQaG9iaWE6ICdibG9vZCBwaG9iaWEnLFxuICAgICAgSGFzX1NvY2lhbFBob2JpYTogJ3NvY2lhbCBwaG9iaWEnLFxuICAgICAgSGFzX0hvYXJkaW5nOiAnaG9hcmRpbmcgdGVuZGVuY2llcycsXG4gICAgfTtcblxuICAgIGNvbnN0IHJlbGV2YW50RGlzb3JkZXJzID0gYWN0aXZlRGlzb3JkZXJzXG4gICAgICAuZmlsdGVyKGRpc29yZGVyID0+IGRpc29yZGVyTmFtZXNbZGlzb3JkZXJdKVxuICAgICAgLm1hcChkaXNvcmRlciA9PiBkaXNvcmRlck5hbWVzW2Rpc29yZGVyXSk7XG5cbiAgICBpZiAocmVsZXZhbnREaXNvcmRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZGlzb3JkZXJMaXN0ID0gcmVsZXZhbnREaXNvcmRlcnMubGVuZ3RoID09PSAxIFxuICAgICAgICA/IHJlbGV2YW50RGlzb3JkZXJzWzBdXG4gICAgICAgIDogcmVsZXZhbnREaXNvcmRlcnMuc2xpY2UoMCwgLTEpLmpvaW4oJywgJykgKyAnIGFuZCAnICsgcmVsZXZhbnREaXNvcmRlcnNbcmVsZXZhbnREaXNvcmRlcnMubGVuZ3RoIC0gMV07XG4gICAgICBcbiAgICAgIHJldHVybiBgUmVjb21tZW5kZWQgYmFzZWQgb24geW91ciAke2Rpc29yZGVyTGlzdH0gYXNzZXNzbWVudCByZXN1bHRzYDtcbiAgICB9XG5cbiAgICByZXR1cm4gJ1JlY29tbWVuZGVkIGJhc2VkIG9uIHlvdXIgbWVudGFsIGhlYWx0aCBhc3Nlc3NtZW50JztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZmFsbGJhY2sgY29tbXVuaXR5IHJlY29tbWVuZGF0aW9ucyB3aGVuIEFJIHByZWRpY3Rpb25zIGFyZSBub3QgYXZhaWxhYmxlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldEZhbGxiYWNrUmVjb21tZW5kYXRpb25zKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxDb21tdW5pdHlSZWNvbW1lbmRhdGlvbltdPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCB1c2VyJ3MgY3VycmVudCBjb21tdW5pdGllcyB0byBleGNsdWRlXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5wcmlzbWEudXNlci5maW5kVW5pcXVlKHtcbiAgICAgICAgd2hlcmU6IHsgaWQ6IHVzZXJJZCB9LFxuICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgbWVtYmVyc2hpcHM6IHtcbiAgICAgICAgICAgIHNlbGVjdDogeyBjb21tdW5pdHlJZDogdHJ1ZSB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY3VycmVudENvbW11bml0eUlkcyA9IHVzZXI/Lm1lbWJlcnNoaXBzLm1hcCgobSkgPT4gbS5jb21tdW5pdHlJZCkgfHwgW107XG5cbiAgICAgIC8vIEdldCBwb3B1bGFyIGNvbW11bml0aWVzIChieSBtZW1iZXIgY291bnQpIGFzIGZhbGxiYWNrXG4gICAgICBjb25zdCBjb21tdW5pdGllcyA9IGF3YWl0IHRoaXMucHJpc21hLmNvbW11bml0eS5maW5kTWFueSh7XG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgaWQ6IHsgbm90SW46IGN1cnJlbnRDb21tdW5pdHlJZHMgfSxcbiAgICAgICAgfSxcbiAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgIF9jb3VudDoge1xuICAgICAgICAgICAgc2VsZWN0OiB7IG1lbWJlcnNoaXBzOiB0cnVlIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgb3JkZXJCeToge1xuICAgICAgICAgIG1lbWJlcnNoaXBzOiB7XG4gICAgICAgICAgICBfY291bnQ6ICdkZXNjJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB0YWtlOiA2LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICByZXR1cm4gY29tbXVuaXRpZXMubWFwKChjb21tdW5pdHksIGluZGV4KSA9PiAoe1xuICAgICAgICBpZDogY29tbXVuaXR5LmlkLFxuICAgICAgICBuYW1lOiBjb21tdW5pdHkubmFtZSxcbiAgICAgICAgc2x1ZzogY29tbXVuaXR5LnNsdWcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBjb21tdW5pdHkuZGVzY3JpcHRpb24sXG4gICAgICAgIGltYWdlVXJsOiBjb21tdW5pdHkuaW1hZ2VVcmwgfHwgJy9pbWFnZXMvY29tbXVuaXRpZXMvZGVmYXVsdC5qcGcnLFxuICAgICAgICBtZW1iZXJDb3VudDogY29tbXVuaXR5Ll9jb3VudC5tZW1iZXJzaGlwcyxcbiAgICAgICAgY29tcGF0aWJpbGl0eVNjb3JlOiAwLjYgLSAoaW5kZXggKiAwLjA1KSwgLy8gRGVjcmVhc2luZyBzY29yZSBiYXNlZCBvbiBwb3B1bGFyaXR5XG4gICAgICAgIHNjb3JlOiAwLjYgLSAoaW5kZXggKiAwLjA1KSxcbiAgICAgICAgcmVhc29uOiAnUG9wdWxhciBjb21tdW5pdHkgdGhhdCBtaWdodCBpbnRlcmVzdCB5b3UnLFxuICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgICAgY3JlYXRlZEF0OiBub3csXG4gICAgICAgIHVwZGF0ZWRBdDogbm93LFxuICAgICAgfSkpO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBFcnJvciBnZXR0aW5nIGZhbGxiYWNrIHJlY29tbWVuZGF0aW9ucyBmb3IgdXNlciAke3VzZXJJZH06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSByZWNvbW1lbmRhdGlvbnMgZm9yIGEgdXNlciAoanVzdCByZXR1cm5zIHRoZSBjYWxjdWxhdGVkIG9uZXMpXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZVJlY29tbWVuZGF0aW9uc0ZvclVzZXIoXG4gICAgdXNlcklkOiBzdHJpbmcsXG4gICAgZm9yY2UgPSBmYWxzZSxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gTm8tb3Agc2luY2Ugd2UgY2FsY3VsYXRlIG9uLWRlbWFuZFxuICAgIHRoaXMubG9nZ2VyLmxvZyhcbiAgICAgIGBHZW5lcmF0ZWQgcmVjb21tZW5kYXRpb25zIGZvciB1c2VyICR7dXNlcklkfSAoY2FsY3VsYXRlZCBvbi1kZW1hbmQpYCxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHNwZWNpZmljIHJlY29tbWVuZGF0aW9uIGJ5IElEIChzaW1wbGlmaWVkKVxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjb21tZW5kYXRpb25CeUlkKFxuICAgIHJlY29tbWVuZGF0aW9uSWQ6IHN0cmluZyxcbiAgKTogUHJvbWlzZTxDb21tdW5pdHlSZWNvbW1lbmRhdGlvbiB8IG51bGw+IHtcbiAgICAvLyBTaW5jZSB3ZSBkb24ndCBzdG9yZSByZWNvbW1lbmRhdGlvbnMsIHdlIGNhbid0IGZldGNoIGJ5IElEXG4gICAgLy8gSW4gYSByZWFsIHNjZW5hcmlvLCB5b3UnZCBuZWVkIHRvIHJlY2FsY3VsYXRlIG9yIHJldHVybiBudWxsXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHJlY29tbWVuZGF0aW9uIGludGVyYWN0aW9uIChzaW1wbGlmaWVkKVxuICAgKi9cbiAgYXN5bmMgaGFuZGxlUmVjb21tZW5kYXRpb25JbnRlcmFjdGlvbihkYXRhOiB7XG4gICAgcmVjb21tZW5kYXRpb25JZDogc3RyaW5nO1xuICAgIGFjdGlvbjogc3RyaW5nO1xuICAgIHVzZXJJZDogc3RyaW5nO1xuICB9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gTm8tb3Agc2luY2Ugd2UgZG9uJ3Qgc3RvcmUgaW50ZXJhY3Rpb25zXG4gICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgYFVzZXIgJHtkYXRhLnVzZXJJZH0gJHtkYXRhLmFjdGlvbn1lZCByZWNvbW1lbmRhdGlvbiAke2RhdGEucmVjb21tZW5kYXRpb25JZH1gLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU3R1YiBtZXRob2QgZm9yIHN0YXRzIC0gc2ltcGxpZmllZCBzaW5jZSBubyB0YWJsZSB0byBxdWVyeVxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjb21tZW5kYXRpb25TdGF0cygpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0b3RhbFJlY29tbWVuZGF0aW9uczogMCxcbiAgICAgIGFjY2VwdGVkUmVjb21tZW5kYXRpb25zOiAwLFxuICAgICAgcmVqZWN0ZWRSZWNvbW1lbmRhdGlvbnM6IDAsXG4gICAgICBwZW5kaW5nUmVjb21tZW5kYXRpb25zOiAwLFxuICAgICAgYXZlcmFnZUNvbXBhdGliaWxpdHlTY29yZTogMCxcbiAgICAgIHRvcENvbW11bml0aWVzOiBbXSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEpvaW4gbXVsdGlwbGUgcmVjb21tZW5kZWQgY29tbXVuaXRpZXMgaW1tZWRpYXRlbHlcbiAgICovXG4gIGFzeW5jIGpvaW5SZWNvbW1lbmRlZENvbW11bml0aWVzKFxuICAgIHVzZXJJZDogc3RyaW5nLFxuICAgIGNvbW11bml0eVNsdWdzOiBzdHJpbmdbXVxuICApOiBQcm9taXNlPHtcbiAgICBzdWNjZXNzZnVsSm9pbnM6IEFycmF5PHsgY29tbXVuaXR5SWQ6IHN0cmluZzsgY29tbXVuaXR5TmFtZTogc3RyaW5nOyBzbHVnOiBzdHJpbmcgfT47XG4gICAgZmFpbGVkSm9pbnM6IEFycmF5PHsgc2x1Zzogc3RyaW5nOyByZWFzb246IHN0cmluZyB9PjtcbiAgfT4ge1xuICAgIGNvbnN0IHN1Y2Nlc3NmdWxKb2luczogQXJyYXk8eyBjb21tdW5pdHlJZDogc3RyaW5nOyBjb21tdW5pdHlOYW1lOiBzdHJpbmc7IHNsdWc6IHN0cmluZyB9PiA9IFtdO1xuICAgIGNvbnN0IGZhaWxlZEpvaW5zOiBBcnJheTx7IHNsdWc6IHN0cmluZzsgcmVhc29uOiBzdHJpbmcgfT4gPSBbXTtcblxuICAgIGZvciAoY29uc3Qgc2x1ZyBvZiBjb21tdW5pdHlTbHVncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRmluZCB0aGUgY29tbXVuaXR5IGJ5IHNsdWdcbiAgICAgICAgY29uc3QgY29tbXVuaXR5ID0gYXdhaXQgdGhpcy5wcmlzbWEuY29tbXVuaXR5LmZpbmRVbmlxdWUoe1xuICAgICAgICAgIHdoZXJlOiB7IHNsdWcgfSxcbiAgICAgICAgICBzZWxlY3Q6IHsgaWQ6IHRydWUsIG5hbWU6IHRydWUsIHNsdWc6IHRydWUgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWNvbW11bml0eSkge1xuICAgICAgICAgIGZhaWxlZEpvaW5zLnB1c2goeyBzbHVnLCByZWFzb246ICdDb21tdW5pdHkgbm90IGZvdW5kJyB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHVzZXIgaXMgYWxyZWFkeSBhIG1lbWJlclxuICAgICAgICBjb25zdCBleGlzdGluZ01lbWJlcnNoaXAgPSBhd2FpdCB0aGlzLnByaXNtYS5tZW1iZXJzaGlwLmZpbmRVbmlxdWUoe1xuICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICB1c2VySWRfY29tbXVuaXR5SWQ6IHtcbiAgICAgICAgICAgICAgdXNlcklkLFxuICAgICAgICAgICAgICBjb21tdW5pdHlJZDogY29tbXVuaXR5LmlkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZXhpc3RpbmdNZW1iZXJzaGlwKSB7XG4gICAgICAgICAgZmFpbGVkSm9pbnMucHVzaCh7IHNsdWcsIHJlYXNvbjogJ0FscmVhZHkgYSBtZW1iZXInIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIG1lbWJlcnNoaXBcbiAgICAgICAgYXdhaXQgdGhpcy5wcmlzbWEubWVtYmVyc2hpcC5jcmVhdGUoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICAgIGNvbW11bml0eUlkOiBjb21tdW5pdHkuaWQsXG4gICAgICAgICAgICBqb2luZWRBdDogbmV3IERhdGUoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3VjY2Vzc2Z1bEpvaW5zLnB1c2goe1xuICAgICAgICAgIGNvbW11bml0eUlkOiBjb21tdW5pdHkuaWQsXG4gICAgICAgICAgY29tbXVuaXR5TmFtZTogY29tbXVuaXR5Lm5hbWUsXG4gICAgICAgICAgc2x1ZzogY29tbXVuaXR5LnNsdWdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKGBVc2VyICR7dXNlcklkfSBzdWNjZXNzZnVsbHkgam9pbmVkIGNvbW11bml0eSAke2NvbW11bml0eS5uYW1lfSAoJHtzbHVnfSlgKTtcblxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm9yIGpvaW5pbmcgY29tbXVuaXR5ICR7c2x1Z30gZm9yIHVzZXIgJHt1c2VySWR9OmAsIGVycm9yKTtcbiAgICAgICAgZmFpbGVkSm9pbnMucHVzaCh7IFxuICAgICAgICAgIHNsdWcsIFxuICAgICAgICAgIHJlYXNvbjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicgXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmxvZyhcbiAgICAgIGBDb21tdW5pdHkgam9pbiByZXN1bHRzIGZvciB1c2VyICR7dXNlcklkfTogJHtzdWNjZXNzZnVsSm9pbnMubGVuZ3RofSBzdWNjZXNzZnVsLCAke2ZhaWxlZEpvaW5zLmxlbmd0aH0gZmFpbGVkYFxuICAgICk7XG5cbiAgICByZXR1cm4geyBzdWNjZXNzZnVsSm9pbnMsIGZhaWxlZEpvaW5zIH07XG4gIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==