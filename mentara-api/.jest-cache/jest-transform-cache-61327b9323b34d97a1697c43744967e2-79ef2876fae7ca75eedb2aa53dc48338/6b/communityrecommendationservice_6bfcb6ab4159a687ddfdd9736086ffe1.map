{"file":"/home/wetooa/Documents/code/projects/mentara/mentara-api/src/communities/services/community-recommendation.service.ts","mappings":"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","names":[],"sources":["/home/wetooa/Documents/code/projects/mentara/mentara-api/src/communities/services/community-recommendation.service.ts"],"sourcesContent":["import { Injectable, Logger, NotFoundException } from '@nestjs/common';\nimport { PrismaService } from '../../providers/prisma-client.provider';\nimport { CommunityMatchingService } from './community-matching.service';\nimport { \n  getCommunityRecommendationsWithScores,\n  getCommunityBySlug,\n  ILLNESS_COMMUNITIES \n} from '../../config/community-configs';\nimport { AiServiceClient } from '../../pre-assessment/services/ai-service.client';\n\nexport interface CommunityRecommendation {\n  id: string;\n  name: string;\n  slug: string;\n  description: string;\n  imageUrl: string;\n  memberCount: number;\n  compatibilityScore: number;\n  score: number; // alias for compatibility\n  reason: string;\n  status: string; // calculated on-demand\n  createdAt: Date; // dummy values for compatibility\n  updatedAt: Date; // dummy values for compatibility\n}\n\n@Injectable()\nexport class CommunityRecommendationService {\n  private readonly logger = new Logger(CommunityRecommendationService.name);\n\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly communityMatching: CommunityMatchingService,\n    private readonly aiServiceClient: AiServiceClient,\n  ) {}\n\n  /**\n   * Calculate community recommendations based on AI disorder predictions from user's assessment\n   */\n  async getUserRecommendations(\n    userId: string,\n  ): Promise<CommunityRecommendation[]> {\n    try {\n      // Get user's data including preassessment and current memberships\n      const user = await this.prisma.user.findUnique({\n        where: { id: userId },\n        include: {\n          client: {\n            include: {\n              preAssessment: true,\n            },\n          },\n          memberships: {\n            select: { communityId: true },\n          },\n        },\n      });\n\n      if (!user || !user.client) {\n        throw new NotFoundException(`User ${userId} not found or not a client`);\n      }\n\n      // Check if user has completed preassessment\n      if (!user.client.preAssessment) {\n        this.logger.warn(`No preassessment found for user ${userId}`);\n        return this.getFallbackRecommendations(userId);\n      }\n\n      // Get AI disorder predictions from preassessment data\n      let disorderPredictions: Record<string, boolean> = {};\n      try {\n        const assessmentAnswers = user.client.preAssessment.answers as any;\n        if (assessmentAnswers?.questionnaires && Array.isArray(assessmentAnswers.questionnaires)) {\n          const aiResult = await this.aiServiceClient.predict(assessmentAnswers.questionnaires);\n          disorderPredictions = aiResult.predictions || {};\n          this.logger.log(`AI predictions obtained for user ${userId}: ${Object.keys(disorderPredictions).filter(k => disorderPredictions[k]).join(', ')}`);\n        } else {\n          this.logger.warn(`Invalid preassessment data format for user ${userId}`);\n          return this.getFallbackRecommendations(userId);\n        }\n      } catch (error) {\n        this.logger.error(`Failed to get AI predictions for user ${userId}:`, error);\n        return this.getFallbackRecommendations(userId);\n      }\n\n      // Get user's current communities to exclude from recommendations\n      const currentCommunityIds = user.memberships.map((m) => m.communityId);\n\n      // Get community recommendations based on AI predictions\n      const aiRecommendations = getCommunityRecommendationsWithScores(disorderPredictions);\n      \n      if (aiRecommendations.length === 0) {\n        this.logger.log(`No AI-based recommendations for user ${userId}, using fallback`);\n        return this.getFallbackRecommendations(userId);\n      }\n\n      // Get database communities that match recommendations\n      const recommendedSlugs = aiRecommendations.map(rec => rec.slug);\n      const communities = await this.prisma.community.findMany({\n        where: {\n          slug: { in: recommendedSlugs },\n          id: { notIn: currentCommunityIds },\n        },\n        include: {\n          _count: {\n            select: { memberships: true },\n          },\n        },\n      });\n\n      // Create final recommendations with real data\n      const recommendations: CommunityRecommendation[] = [];\n      const now = new Date();\n\n      for (const community of communities) {\n        const aiRec = aiRecommendations.find(rec => rec.slug === community.slug);\n        if (aiRec) {\n          recommendations.push({\n            id: community.id,\n            name: community.name,\n            slug: community.slug,\n            description: community.description,\n            imageUrl: community.imageUrl || '/images/communities/default.jpg',\n            memberCount: community._count.memberships,\n            compatibilityScore: aiRec.score,\n            score: aiRec.score,\n            reason: this.generateAIBasedReason(disorderPredictions, aiRec.slug),\n            status: 'pending',\n            createdAt: now,\n            updatedAt: now,\n          });\n        }\n      }\n\n      // Sort by AI compatibility score and return\n      const sortedRecommendations = recommendations\n        .sort((a, b) => b.compatibilityScore - a.compatibilityScore)\n        .slice(0, 8); // Limit to top 8 recommendations\n\n      this.logger.log(`Generated ${sortedRecommendations.length} AI-based community recommendations for user ${userId}`);\n      return sortedRecommendations;\n\n    } catch (error) {\n      this.logger.error(\n        `Error getting recommendations for user ${userId}:`,\n        error,\n      );\n      return this.getFallbackRecommendations(userId);\n    }\n  }\n\n  private async calculateCompatibilityScore(\n    assessmentResponses: any[],\n    community: any,\n  ): Promise<number> {\n    // Simplified compatibility calculation\n    // In a real system, this would use the assessment responses to match with community characteristics\n    const baseScore = Math.random() * 0.8 + 0.2; // 0.2-1.0 for demo\n\n    // Factor in community size (smaller communities might be better matches)\n    const sizeBonus = community._count.memberships < 50 ? 0.1 : 0;\n\n    return Math.min(baseScore + sizeBonus, 1.0);\n  }\n\n  private generateRecommendationReason(score: number): string {\n    if (score > 0.8)\n      return 'Excellent match based on your assessment responses';\n    if (score > 0.6) return 'Good compatibility with your interests';\n    if (score > 0.4) return 'Potential good fit for your needs';\n    return 'Moderate compatibility';\n  }\n\n  /**\n   * Generate AI-based recommendation reason\n   */\n  private generateAIBasedReason(disorderPredictions: Record<string, boolean>, communitySlug: string): string {\n    const activeDisorders = Object.keys(disorderPredictions).filter(disorder => disorderPredictions[disorder]);\n    const community = getCommunityBySlug(communitySlug);\n    \n    if (!community) {\n      return 'Recommended based on your assessment responses';\n    }\n\n    // Map common disorders to user-friendly terms\n    const disorderNames: Record<string, string> = {\n      Has_Depression: 'depression',\n      Has_Anxiety: 'anxiety',\n      Has_Social_Anxiety: 'social anxiety',\n      Has_PTSD: 'PTSD',\n      Has_Panic_Disorder: 'panic disorder',\n      Has_Bipolar: 'bipolar disorder',\n      Has_OCD: 'OCD',\n      Has_Insomnia: 'sleep issues',\n      Has_High_Stress: 'stress',\n      Has_Burnout: 'burnout',\n      Has_Binge_Eating: 'eating concerns',\n      Has_ADHD: 'ADHD',\n      Has_Alcohol_Problem: 'alcohol concerns',\n      Has_Drug_Problem: 'substance concerns',\n      Has_Phobia: 'phobias',\n      Has_Agoraphobia: 'agoraphobia',\n      Has_BloodPhobia: 'blood phobia',\n      Has_SocialPhobia: 'social phobia',\n      Has_Hoarding: 'hoarding tendencies',\n    };\n\n    const relevantDisorders = activeDisorders\n      .filter(disorder => disorderNames[disorder])\n      .map(disorder => disorderNames[disorder]);\n\n    if (relevantDisorders.length > 0) {\n      const disorderList = relevantDisorders.length === 1 \n        ? relevantDisorders[0]\n        : relevantDisorders.slice(0, -1).join(', ') + ' and ' + relevantDisorders[relevantDisorders.length - 1];\n      \n      return `Recommended based on your ${disorderList} assessment results`;\n    }\n\n    return 'Recommended based on your mental health assessment';\n  }\n\n  /**\n   * Get fallback community recommendations when AI predictions are not available\n   */\n  private async getFallbackRecommendations(userId: string): Promise<CommunityRecommendation[]> {\n    try {\n      // Get user's current communities to exclude\n      const user = await this.prisma.user.findUnique({\n        where: { id: userId },\n        include: {\n          memberships: {\n            select: { communityId: true },\n          },\n        },\n      });\n\n      const currentCommunityIds = user?.memberships.map((m) => m.communityId) || [];\n\n      // Get popular communities (by member count) as fallback\n      const communities = await this.prisma.community.findMany({\n        where: {\n          id: { notIn: currentCommunityIds },\n        },\n        include: {\n          _count: {\n            select: { memberships: true },\n          },\n        },\n        orderBy: {\n          memberships: {\n            _count: 'desc',\n          },\n        },\n        take: 6,\n      });\n\n      const now = new Date();\n      return communities.map((community, index) => ({\n        id: community.id,\n        name: community.name,\n        slug: community.slug,\n        description: community.description,\n        imageUrl: community.imageUrl || '/images/communities/default.jpg',\n        memberCount: community._count.memberships,\n        compatibilityScore: 0.6 - (index * 0.05), // Decreasing score based on popularity\n        score: 0.6 - (index * 0.05),\n        reason: 'Popular community that might interest you',\n        status: 'pending',\n        createdAt: now,\n        updatedAt: now,\n      }));\n\n    } catch (error) {\n      this.logger.error(`Error getting fallback recommendations for user ${userId}:`, error);\n      return [];\n    }\n  }\n\n  /**\n   * Generate recommendations for a user (just returns the calculated ones)\n   */\n  async generateRecommendationsForUser(\n    userId: string,\n    force = false,\n  ): Promise<void> {\n    // No-op since we calculate on-demand\n    this.logger.log(\n      `Generated recommendations for user ${userId} (calculated on-demand)`,\n    );\n  }\n\n  /**\n   * Get a specific recommendation by ID (simplified)\n   */\n  async getRecommendationById(\n    recommendationId: string,\n  ): Promise<CommunityRecommendation | null> {\n    // Since we don't store recommendations, we can't fetch by ID\n    // In a real scenario, you'd need to recalculate or return null\n    return null;\n  }\n\n  /**\n   * Handle recommendation interaction (simplified)\n   */\n  async handleRecommendationInteraction(data: {\n    recommendationId: string;\n    action: string;\n    userId: string;\n  }): Promise<void> {\n    // No-op since we don't store interactions\n    this.logger.log(\n      `User ${data.userId} ${data.action}ed recommendation ${data.recommendationId}`,\n    );\n  }\n\n  /**\n   * Stub method for stats - simplified since no table to query\n   */\n  async getRecommendationStats(): Promise<any> {\n    return {\n      totalRecommendations: 0,\n      acceptedRecommendations: 0,\n      rejectedRecommendations: 0,\n      pendingRecommendations: 0,\n      averageCompatibilityScore: 0,\n      topCommunities: [],\n    };\n  }\n\n  /**\n   * Join multiple recommended communities immediately\n   */\n  async joinRecommendedCommunities(\n    userId: string,\n    communitySlugs: string[]\n  ): Promise<{\n    successfulJoins: Array<{ communityId: string; communityName: string; slug: string }>;\n    failedJoins: Array<{ slug: string; reason: string }>;\n  }> {\n    const successfulJoins: Array<{ communityId: string; communityName: string; slug: string }> = [];\n    const failedJoins: Array<{ slug: string; reason: string }> = [];\n\n    for (const slug of communitySlugs) {\n      try {\n        // Find the community by slug\n        const community = await this.prisma.community.findUnique({\n          where: { slug },\n          select: { id: true, name: true, slug: true }\n        });\n\n        if (!community) {\n          failedJoins.push({ slug, reason: 'Community not found' });\n          continue;\n        }\n\n        // Check if user is already a member\n        const existingMembership = await this.prisma.membership.findUnique({\n          where: {\n            userId_communityId: {\n              userId,\n              communityId: community.id\n            }\n          }\n        });\n\n        if (existingMembership) {\n          failedJoins.push({ slug, reason: 'Already a member' });\n          continue;\n        }\n\n        // Create membership\n        await this.prisma.membership.create({\n          data: {\n            userId,\n            communityId: community.id,\n            joinedAt: new Date()\n          }\n        });\n\n        successfulJoins.push({\n          communityId: community.id,\n          communityName: community.name,\n          slug: community.slug\n        });\n\n        this.logger.log(`User ${userId} successfully joined community ${community.name} (${slug})`);\n\n      } catch (error) {\n        this.logger.error(`Error joining community ${slug} for user ${userId}:`, error);\n        failedJoins.push({ \n          slug, \n          reason: error instanceof Error ? error.message : 'Unknown error' \n        });\n      }\n    }\n\n    this.logger.log(\n      `Community join results for user ${userId}: ${successfulJoins.length} successful, ${failedJoins.length} failed`\n    );\n\n    return { successfulJoins, failedJoins };\n  }\n}\n"],"version":3}