{"file":"/home/wetooa/Documents/code/projects/mentara/mentara-api/src/auth/services/token.service.ts","mappings":"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","names":[],"sources":["/home/wetooa/Documents/code/projects/mentara/mentara-api/src/auth/services/token.service.ts"],"sourcesContent":["import { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { PrismaService } from '../../providers/prisma-client.provider';\nimport { JwtPayload } from '../strategies/jwt.strategy';\nimport * as crypto from 'crypto';\nimport * as bcrypt from 'bcrypt';\n\nexport interface SimpleToken {\n  token: string;\n}\n\n@Injectable()\nexport class TokenService {\n  constructor(\n    private readonly jwtService: JwtService,\n    private readonly prisma: PrismaService,\n  ) {}\n\n  async generateToken(\n    userId: string,\n    email: string,\n    role: string,\n  ): Promise<SimpleToken> {\n    const payload: JwtPayload = {\n      sub: userId,\n      email,\n      role,\n    };\n\n    // Generate non-expiring token for simplicity\n    const token = this.jwtService.sign(payload);\n\n    return { token };\n  }\n\n  // Removed refresh token generation - no longer needed\n\n  // Removed refresh token functionality - no longer needed\n\n  // Simple logout - no complex token management needed\n  async logout(userId: string): Promise<void> {\n    // With non-expiring tokens, we could implement a blacklist if needed\n    // For now, just update last login to track activity\n    await this.prisma.user.update({\n      where: { id: userId },\n      data: { lastLoginAt: new Date() },\n    });\n  }\n\n  // Password hashing utilities\n  async hashPassword(password: string): Promise<string> {\n    const saltRounds = parseInt(process.env.BCRYPT_SALT_ROUNDS || '12');\n    return bcrypt.hash(password, saltRounds);\n  }\n\n  async comparePassword(\n    password: string,\n    hashedPassword: string,\n  ): Promise<boolean> {\n    return bcrypt.compare(password, hashedPassword);\n  }\n\n  // Email verification token generation\n  async generateEmailVerificationToken(): Promise<{\n    token: string;\n    hashedToken: string;\n    expiresAt: Date;\n  }> {\n    const token = crypto.randomBytes(32).toString('hex');\n    const hashedToken = crypto.createHash('sha256').update(token).digest('hex');\n\n    const expiresAt = new Date();\n    expiresAt.setHours(expiresAt.getHours() + 24); // 24 hours expiry\n\n    return { token, hashedToken, expiresAt };\n  }\n\n  // Password reset token generation\n  async generatePasswordResetToken(): Promise<{\n    token: string;\n    hashedToken: string;\n    expiresAt: Date;\n  }> {\n    const token = crypto.randomBytes(32).toString('hex');\n    const hashedToken = crypto.createHash('sha256').update(token).digest('hex');\n\n    const expiresAt = new Date();\n    expiresAt.setHours(expiresAt.getHours() + 1); // 1 hour expiry for security\n\n    return { token, hashedToken, expiresAt };\n  }\n\n  // Account lockout utilities\n  async checkAccountLockout(userId: string): Promise<boolean> {\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n      select: { lockoutUntil: true, failedLoginCount: true },\n    });\n\n    if (!user) return false;\n\n    // Check if account is currently locked\n    if (user.lockoutUntil && user.lockoutUntil > new Date()) {\n      return true;\n    }\n\n    // Clear lockout if time has passed\n    if (user.lockoutUntil && user.lockoutUntil <= new Date()) {\n      await this.prisma.user.update({\n        where: { id: userId },\n        data: {\n          lockoutUntil: null,\n          failedLoginCount: 0,\n        },\n      });\n    }\n\n    return false;\n  }\n\n  async handleFailedLogin(userId: string): Promise<void> {\n    const maxAttempts = parseInt(process.env.MAX_LOGIN_ATTEMPTS || '5');\n    const lockoutDuration = parseInt(\n      process.env.LOCKOUT_DURATION_MINUTES || '15',\n    );\n\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n      select: { failedLoginCount: true },\n    });\n\n    if (!user) return;\n\n    const newFailedCount = user.failedLoginCount + 1;\n    const updateData: any = { failedLoginCount: newFailedCount };\n\n    // Lock account if max attempts reached\n    if (newFailedCount >= maxAttempts) {\n      const lockoutUntil = new Date();\n      lockoutUntil.setMinutes(lockoutUntil.getMinutes() + lockoutDuration);\n      updateData.lockoutUntil = lockoutUntil;\n    }\n\n    await this.prisma.user.update({\n      where: { id: userId },\n      data: updateData,\n    });\n  }\n\n  async resetFailedLoginCount(userId: string): Promise<void> {\n    await this.prisma.user.update({\n      where: { id: userId },\n      data: {\n        failedLoginCount: 0,\n        lockoutUntil: null,\n        lastLoginAt: new Date(),\n      },\n    });\n  }\n\n  /**\n   * Validates a JWT token and returns the payload (simplified - no expiration)\n   * @param token - The JWT token to validate\n   * @returns Promise with validation result\n   */\n  async validateToken(token: string): Promise<{\n    valid: boolean;\n    payload?: any;\n    error?: string;\n  }> {\n    try {\n      // Verify and decode the token (no expiration check since we're using non-expiring tokens)\n      const payload = this.jwtService.verify(token);\n\n      return {\n        valid: true,\n        payload,\n      };\n    } catch (error) {\n      return {\n        valid: false,\n        error: error instanceof Error ? error.message : 'Invalid token',\n      };\n    }\n  }\n\n  // Removed all session management - no longer needed with single tokens\n\n  // Removed helper methods - no longer needed with simplified approach\n}\n"],"version":3}