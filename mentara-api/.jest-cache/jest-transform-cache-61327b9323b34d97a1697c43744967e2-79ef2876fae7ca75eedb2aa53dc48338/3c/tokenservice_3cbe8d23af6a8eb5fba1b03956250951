a0883dac742ca7feaa5ad3c78d87a1ff
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenService = void 0;
const common_1 = require("@nestjs/common");
const jwt_1 = require("@nestjs/jwt");
const prisma_client_provider_1 = require("../../providers/prisma-client.provider");
const crypto = require("crypto");
const bcrypt = require("bcrypt");
let TokenService = class TokenService {
    jwtService;
    prisma;
    constructor(jwtService, prisma) {
        this.jwtService = jwtService;
        this.prisma = prisma;
    }
    async generateToken(userId, email, role) {
        const payload = {
            sub: userId,
            email,
            role,
        };
        // Generate non-expiring token for simplicity
        const token = this.jwtService.sign(payload);
        return { token };
    }
    // Removed refresh token generation - no longer needed
    // Removed refresh token functionality - no longer needed
    // Simple logout - no complex token management needed
    async logout(userId) {
        // With non-expiring tokens, we could implement a blacklist if needed
        // For now, just update last login to track activity
        await this.prisma.user.update({
            where: { id: userId },
            data: { lastLoginAt: new Date() },
        });
    }
    // Password hashing utilities
    async hashPassword(password) {
        const saltRounds = parseInt(process.env.BCRYPT_SALT_ROUNDS || '12');
        return bcrypt.hash(password, saltRounds);
    }
    async comparePassword(password, hashedPassword) {
        return bcrypt.compare(password, hashedPassword);
    }
    // Email verification token generation
    async generateEmailVerificationToken() {
        const token = crypto.randomBytes(32).toString('hex');
        const hashedToken = crypto.createHash('sha256').update(token).digest('hex');
        const expiresAt = new Date();
        expiresAt.setHours(expiresAt.getHours() + 24); // 24 hours expiry
        return { token, hashedToken, expiresAt };
    }
    // Password reset token generation
    async generatePasswordResetToken() {
        const token = crypto.randomBytes(32).toString('hex');
        const hashedToken = crypto.createHash('sha256').update(token).digest('hex');
        const expiresAt = new Date();
        expiresAt.setHours(expiresAt.getHours() + 1); // 1 hour expiry for security
        return { token, hashedToken, expiresAt };
    }
    // Account lockout utilities
    async checkAccountLockout(userId) {
        const user = await this.prisma.user.findUnique({
            where: { id: userId },
            select: { lockoutUntil: true, failedLoginCount: true },
        });
        if (!user)
            return false;
        // Check if account is currently locked
        if (user.lockoutUntil && user.lockoutUntil > new Date()) {
            return true;
        }
        // Clear lockout if time has passed
        if (user.lockoutUntil && user.lockoutUntil <= new Date()) {
            await this.prisma.user.update({
                where: { id: userId },
                data: {
                    lockoutUntil: null,
                    failedLoginCount: 0,
                },
            });
        }
        return false;
    }
    async handleFailedLogin(userId) {
        const maxAttempts = parseInt(process.env.MAX_LOGIN_ATTEMPTS || '5');
        const lockoutDuration = parseInt(process.env.LOCKOUT_DURATION_MINUTES || '15');
        const user = await this.prisma.user.findUnique({
            where: { id: userId },
            select: { failedLoginCount: true },
        });
        if (!user)
            return;
        const newFailedCount = user.failedLoginCount + 1;
        const updateData = { failedLoginCount: newFailedCount };
        // Lock account if max attempts reached
        if (newFailedCount >= maxAttempts) {
            const lockoutUntil = new Date();
            lockoutUntil.setMinutes(lockoutUntil.getMinutes() + lockoutDuration);
            updateData.lockoutUntil = lockoutUntil;
        }
        await this.prisma.user.update({
            where: { id: userId },
            data: updateData,
        });
    }
    async resetFailedLoginCount(userId) {
        await this.prisma.user.update({
            where: { id: userId },
            data: {
                failedLoginCount: 0,
                lockoutUntil: null,
                lastLoginAt: new Date(),
            },
        });
    }
    /**
     * Validates a JWT token and returns the payload (simplified - no expiration)
     * @param token - The JWT token to validate
     * @returns Promise with validation result
     */
    async validateToken(token) {
        try {
            // Verify and decode the token (no expiration check since we're using non-expiring tokens)
            const payload = this.jwtService.verify(token);
            return {
                valid: true,
                payload,
            };
        }
        catch (error) {
            return {
                valid: false,
                error: error instanceof Error ? error.message : 'Invalid token',
            };
        }
    }
};
exports.TokenService = TokenService;
exports.TokenService = TokenService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof jwt_1.JwtService !== "undefined" && jwt_1.JwtService) === "function" ? _a : Object, typeof (_b = typeof prisma_client_provider_1.PrismaService !== "undefined" && prisma_client_provider_1.PrismaService) === "function" ? _b : Object])
], TokenService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvd2V0b29hL0RvY3VtZW50cy9jb2RlL3Byb2plY3RzL21lbnRhcmEvbWVudGFyYS1hcGkvc3JjL2F1dGgvc2VydmljZXMvdG9rZW4uc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQW1FO0FBQ25FLHFDQUF5QztBQUN6QyxtRkFBdUU7QUFFdkUsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQU8xQixJQUFNLFlBQVksR0FBbEIsTUFBTSxZQUFZO0lBRUo7SUFDQTtJQUZuQixZQUNtQixVQUFzQixFQUN0QixNQUFxQjtRQURyQixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQ3RCLFdBQU0sR0FBTixNQUFNLENBQWU7SUFDckMsQ0FBQztJQUVKLEtBQUssQ0FBQyxhQUFhLENBQ2pCLE1BQWMsRUFDZCxLQUFhLEVBQ2IsSUFBWTtRQUVaLE1BQU0sT0FBTyxHQUFlO1lBQzFCLEdBQUcsRUFBRSxNQUFNO1lBQ1gsS0FBSztZQUNMLElBQUk7U0FDTCxDQUFDO1FBRUYsNkNBQTZDO1FBQzdDLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRTVDLE9BQU8sRUFBRSxLQUFLLEVBQUUsQ0FBQztJQUNuQixDQUFDO0lBRUQsc0RBQXNEO0lBRXRELHlEQUF5RDtJQUV6RCxxREFBcUQ7SUFDckQsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFjO1FBQ3pCLHFFQUFxRTtRQUNyRSxvREFBb0Q7UUFDcEQsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7WUFDNUIsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRTtZQUNyQixJQUFJLEVBQUUsRUFBRSxXQUFXLEVBQUUsSUFBSSxJQUFJLEVBQUUsRUFBRTtTQUNsQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsNkJBQTZCO0lBQzdCLEtBQUssQ0FBQyxZQUFZLENBQUMsUUFBZ0I7UUFDakMsTUFBTSxVQUFVLEdBQUcsUUFB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LEVBQUU7Z0JBQ0osZ0JBQWdCLEVBQUUsQ0FBQztnQkFDbkIsWUFBWSxFQUFFLElBQUk7Z0JBQ2xCLFdBQVcsRUFBRSxJQUFJLElBQUksRUFBRTthQUN4QjtTQUNGLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLGFBQWEsQ0FBQyxLQUFhO1FBSy9CLElBQUksQ0FBQztZQUNILDBGQUEwRjtZQUMxRixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUU5QyxPQUFPO2dCQUNMLEtBQUssRUFBRSxJQUFJO2dCQUNYLE9BQU87YUFDUixDQUFDO1FBQ0osQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPO2dCQUNMLEtBQUssRUFBRSxLQUFLO2dCQUNaLEtBQUssRUFBRSxLQUFLLFlBQVksS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxlQUFlO2FBQ2hFLENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQztDQUtGLENBQUE7QUFqTFksb0NBQVk7dUJBQVosWUFBWTtJQUR4QixJQUFBLG1CQUFVLEdBQUU7eURBR29CLGdCQUFVLG9CQUFWLGdCQUFVLG9EQUNkLHNDQUFhLG9CQUFiLHNDQUFhO0dBSDdCLFlBQVksQ0FpTHhCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9ob21lL3dldG9vYS9Eb2N1bWVudHMvY29kZS9wcm9qZWN0cy9tZW50YXJhL21lbnRhcmEtYXBpL3NyYy9hdXRoL3NlcnZpY2VzL3Rva2VuLnNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgVW5hdXRob3JpemVkRXhjZXB0aW9uIH0gZnJvbSAnQG5lc3Rqcy9jb21tb24nO1xuaW1wb3J0IHsgSnd0U2VydmljZSB9IGZyb20gJ0BuZXN0anMvand0JztcbmltcG9ydCB7IFByaXNtYVNlcnZpY2UgfSBmcm9tICcuLi8uLi9wcm92aWRlcnMvcHJpc21hLWNsaWVudC5wcm92aWRlcic7XG5pbXBvcnQgeyBKd3RQYXlsb2FkIH0gZnJvbSAnLi4vc3RyYXRlZ2llcy9qd3Quc3RyYXRlZ3knO1xuaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgKiBhcyBiY3J5cHQgZnJvbSAnYmNyeXB0JztcblxuZXhwb3J0IGludGVyZmFjZSBTaW1wbGVUb2tlbiB7XG4gIHRva2VuOiBzdHJpbmc7XG59XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUb2tlblNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGp3dFNlcnZpY2U6IEp3dFNlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBwcmlzbWE6IFByaXNtYVNlcnZpY2UsXG4gICkge31cblxuICBhc3luYyBnZW5lcmF0ZVRva2VuKFxuICAgIHVzZXJJZDogc3RyaW5nLFxuICAgIGVtYWlsOiBzdHJpbmcsXG4gICAgcm9sZTogc3RyaW5nLFxuICApOiBQcm9taXNlPFNpbXBsZVRva2VuPiB7XG4gICAgY29uc3QgcGF5bG9hZDogSnd0UGF5bG9hZCA9IHtcbiAgICAgIHN1YjogdXNlcklkLFxuICAgICAgZW1haWwsXG4gICAgICByb2xlLFxuICAgIH07XG5cbiAgICAvLyBHZW5lcmF0ZSBub24tZXhwaXJpbmcgdG9rZW4gZm9yIHNpbXBsaWNpdHlcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMuand0U2VydmljZS5zaWduKHBheWxvYWQpO1xuXG4gICAgcmV0dXJuIHsgdG9rZW4gfTtcbiAgfVxuXG4gIC8vIFJlbW92ZWQgcmVmcmVzaCB0b2tlbiBnZW5lcmF0aW9uIC0gbm8gbG9uZ2VyIG5lZWRlZFxuXG4gIC8vIFJlbW92ZWQgcmVmcmVzaCB0b2tlbiBmdW5jdGlvbmFsaXR5IC0gbm8gbG9uZ2VyIG5lZWRlZFxuXG4gIC8vIFNpbXBsZSBsb2dvdXQgLSBubyBjb21wbGV4IHRva2VuIG1hbmFnZW1lbnQgbmVlZGVkXG4gIGFzeW5jIGxvZ291dCh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIFdpdGggbm9uLWV4cGlyaW5nIHRva2Vucywgd2UgY291bGQgaW1wbGVtZW50IGEgYmxhY2tsaXN0IGlmIG5lZWRlZFxuICAgIC8vIEZvciBub3csIGp1c3QgdXBkYXRlIGxhc3QgbG9naW4gdG8gdHJhY2sgYWN0aXZpdHlcbiAgICBhd2FpdCB0aGlzLnByaXNtYS51c2VyLnVwZGF0ZSh7XG4gICAgICB3aGVyZTogeyBpZDogdXNlcklkIH0sXG4gICAgICBkYXRhOiB7IGxhc3RMb2dpbkF0OiBuZXcgRGF0ZSgpIH0sXG4gICAgfSk7XG4gIH1cblxuICAvLyBQYXNzd29yZCBoYXNoaW5nIHV0aWxpdGllc1xuICBhc3luYyBoYXNoUGFzc3dvcmQocGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3Qgc2FsdFJvdW5kcyA9IHBhcnNlSW50KHByb2Nlc3MuZW52LkJDUllQVF9TQUxUX1JPVU5EUyB8fCAnMTInKTtcbiAgICByZXR1cm4gYmNyeXB0Lmhhc2gocGFzc3dvcmQsIHNhbHRSb3VuZHMpO1xuICB9XG5cbiAgYXN5bmMgY29tcGFyZVBhc3N3b3JkKFxuICAgIHBhc3N3b3JkOiBzdHJpbmcsXG4gICAgaGFzaGVkUGFzc3dvcmQ6IHN0cmluZyxcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIGJjcnlwdC5jb21wYXJlKHBhc3N3b3JkLCBoYXNoZWRQYXNzd29yZCk7XG4gIH1cblxuICAvLyBFbWFpbCB2ZXJpZmljYXRpb24gdG9rZW4gZ2VuZXJhdGlvblxuICBhc3luYyBnZW5lcmF0ZUVtYWlsVmVyaWZpY2F0aW9uVG9rZW4oKTogUHJvbWlzZTx7XG4gICAgdG9rZW46IHN0cmluZztcbiAgICBoYXNoZWRUb2tlbjogc3RyaW5nO1xuICAgIGV4cGlyZXNBdDogRGF0ZTtcbiAgfT4ge1xuICAgIGNvbnN0IHRva2VuID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDMyKS50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3QgaGFzaGVkVG9rZW4gPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKHRva2VuKS5kaWdlc3QoJ2hleCcpO1xuXG4gICAgY29uc3QgZXhwaXJlc0F0ID0gbmV3IERhdGUoKTtcbiAgICBleHBpcmVzQXQuc2V0SG91cnMoZXhwaXJlc0F0LmdldEhvdXJzKCkgKyAyNCk7IC8vIDI0IGhvdXJzIGV4cGlyeVxuXG4gICAgcmV0dXJuIHsgdG9rZW4sIGhhc2hlZFRva2VuLCBleHBpcmVzQXQgfTtcbiAgfVxuXG4gIC8vIFBhc3N3b3JkIHJlc2V0IHRva2VuIGdlbmVyYXRpb25cbiAgYXN5bmMgZ2VuZXJhdGVQYXNzd29yZFJlc2V0VG9rZW4oKTogUHJvbWlzZTx7XG4gICAgdG9rZW46IHN0cmluZztcbiAgICBoYXNoZWRUb2tlbjogc3RyaW5nO1xuICAgIGV4cGlyZXNBdDogRGF0ZTtcbiAgfT4ge1xuICAgIGNvbnN0IHRva2VuID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDMyKS50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3QgaGFzaGVkVG9rZW4gPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKHRva2VuKS5kaWdlc3QoJ2hleCcpO1xuXG4gICAgY29uc3QgZXhwaXJlc0F0ID0gbmV3IERhdGUoKTtcbiAgICBleHBpcmVzQXQuc2V0SG91cnMoZXhwaXJlc0F0LmdldEhvdXJzKCkgKyAxKTsgLy8gMSBob3VyIGV4cGlyeSBmb3Igc2VjdXJpdHlcblxuICAgIHJldHVybiB7IHRva2VuLCBoYXNoZWRUb2tlbiwgZXhwaXJlc0F0IH07XG4gIH1cblxuICAvLyBBY2NvdW50IGxvY2tvdXQgdXRpbGl0aWVzXG4gIGFzeW5jIGNoZWNrQWNjb3VudExvY2tvdXQodXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5wcmlzbWEudXNlci5maW5kVW5pcXVlKHtcbiAgICAgIHdoZXJlOiB7IGlkOiB1c2VySWQgfSxcbiAgICAgIHNlbGVjdDogeyBsb2Nrb3V0VW50aWw6IHRydWUsIGZhaWxlZExvZ2luQ291bnQ6IHRydWUgfSxcbiAgICB9KTtcblxuICAgIGlmICghdXNlcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgaWYgYWNjb3VudCBpcyBjdXJyZW50bHkgbG9ja2VkXG4gICAgaWYgKHVzZXIubG9ja291dFVudGlsICYmIHVzZXIubG9ja291dFVudGlsID4gbmV3IERhdGUoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgbG9ja291dCBpZiB0aW1lIGhhcyBwYXNzZWRcbiAgICBpZiAodXNlci5sb2Nrb3V0VW50aWwgJiYgdXNlci5sb2Nrb3V0VW50aWwgPD0gbmV3IERhdGUoKSkge1xuICAgICAgYXdhaXQgdGhpcy5wcmlzbWEudXNlci51cGRhdGUoe1xuICAgICAgICB3aGVyZTogeyBpZDogdXNlcklkIH0sXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBsb2Nrb3V0VW50aWw6IG51bGwsXG4gICAgICAgICAgZmFpbGVkTG9naW5Db3VudDogMCxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGFzeW5jIGhhbmRsZUZhaWxlZExvZ2luKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgbWF4QXR0ZW1wdHMgPSBwYXJzZUludChwcm9jZXNzLmVudi5NQVhfTE9HSU5fQVRURU1QVFMgfHwgJzUnKTtcbiAgICBjb25zdCBsb2Nrb3V0RHVyYXRpb24gPSBwYXJzZUludChcbiAgICAgIHByb2Nlc3MuZW52LkxPQ0tPVVRfRFVSQVRJT05fTUlOVVRFUyB8fCAnMTUnLFxuICAgICk7XG5cbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5wcmlzbWEudXNlci5maW5kVW5pcXVlKHtcbiAgICAgIHdoZXJlOiB7IGlkOiB1c2VySWQgfSxcbiAgICAgIHNlbGVjdDogeyBmYWlsZWRMb2dpbkNvdW50OiB0cnVlIH0sXG4gICAgfSk7XG5cbiAgICBpZiAoIXVzZXIpIHJldHVybjtcblxuICAgIGNvbnN0IG5ld0ZhaWxlZENvdW50ID0gdXNlci5mYWlsZWRMb2dpbkNvdW50ICsgMTtcbiAgICBjb25zdCB1cGRhdGVEYXRhOiBhbnkgPSB7IGZhaWxlZExvZ2luQ291bnQ6IG5ld0ZhaWxlZENvdW50IH07XG5cbiAgICAvLyBMb2NrIGFjY291bnQgaWYgbWF4IGF0dGVtcHRzIHJlYWNoZWRcbiAgICBpZiAobmV3RmFpbGVkQ291bnQgPj0gbWF4QXR0ZW1wdHMpIHtcbiAgICAgIGNvbnN0IGxvY2tvdXRVbnRpbCA9IG5ldyBEYXRlKCk7XG4gICAgICBsb2Nrb3V0VW50aWwuc2V0TWludXRlcyhsb2Nrb3V0VW50aWwuZ2V0TWludXRlcygpICsgbG9ja291dER1cmF0aW9uKTtcbiAgICAgIHVwZGF0ZURhdGEubG9ja291dFVudGlsID0gbG9ja291dFVudGlsO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMucHJpc21hLnVzZXIudXBkYXRlKHtcbiAgICAgIHdoZXJlOiB7IGlkOiB1c2VySWQgfSxcbiAgICAgIGRhdGE6IHVwZGF0ZURhdGEsXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyByZXNldEZhaWxlZExvZ2luQ291bnQodXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLnByaXNtYS51c2VyLnVwZGF0ZSh7XG4gICAgICB3aGVyZTogeyBpZDogdXNlcklkIH0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGZhaWxlZExvZ2luQ291bnQ6IDAsXG4gICAgICAgIGxvY2tvdXRVbnRpbDogbnVsbCxcbiAgICAgICAgbGFzdExvZ2luQXQ6IG5ldyBEYXRlKCksXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBhIEpXVCB0b2tlbiBhbmQgcmV0dXJucyB0aGUgcGF5bG9hZCAoc2ltcGxpZmllZCAtIG5vIGV4cGlyYXRpb24pXG4gICAqIEBwYXJhbSB0b2tlbiAtIFRoZSBKV1QgdG9rZW4gdG8gdmFsaWRhdGVcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHZhbGlkYXRpb24gcmVzdWx0XG4gICAqL1xuICBhc3luYyB2YWxpZGF0ZVRva2VuKHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPHtcbiAgICB2YWxpZDogYm9vbGVhbjtcbiAgICBwYXlsb2FkPzogYW55O1xuICAgIGVycm9yPzogc3RyaW5nO1xuICB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFZlcmlmeSBhbmQgZGVjb2RlIHRoZSB0b2tlbiAobm8gZXhwaXJhdGlvbiBjaGVjayBzaW5jZSB3ZSdyZSB1c2luZyBub24tZXhwaXJpbmcgdG9rZW5zKVxuICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuand0U2VydmljZS52ZXJpZnkodG9rZW4pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgcGF5bG9hZCxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0ludmFsaWQgdG9rZW4nLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmVkIGFsbCBzZXNzaW9uIG1hbmFnZW1lbnQgLSBubyBsb25nZXIgbmVlZGVkIHdpdGggc2luZ2xlIHRva2Vuc1xuXG4gIC8vIFJlbW92ZWQgaGVscGVyIG1ldGhvZHMgLSBubyBsb25nZXIgbmVlZGVkIHdpdGggc2ltcGxpZmllZCBhcHByb2FjaFxufVxuIl0sInZlcnNpb24iOjN9