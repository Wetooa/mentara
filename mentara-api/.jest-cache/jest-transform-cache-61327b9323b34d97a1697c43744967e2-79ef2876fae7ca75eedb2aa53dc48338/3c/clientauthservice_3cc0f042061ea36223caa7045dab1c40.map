{"file":"/home/wetooa/Documents/code/projects/mentara/mentara-api/src/auth/services/client-auth.service.ts","mappings":"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","names":[],"sources":["/home/wetooa/Documents/code/projects/mentara/mentara-api/src/auth/services/client-auth.service.ts"],"sourcesContent":["import {\n  Injectable,\n  UnauthorizedException,\n  BadRequestException,\n} from '@nestjs/common';\nimport { RegisterClientDto } from 'mentara-commons';\nimport { PrismaService } from '../../providers/prisma-client.provider';\nimport { TokenService } from './token.service';\nimport { EmailVerificationService } from './email-verification.service';\nimport * as bcrypt from 'bcrypt';\n\n@Injectable()\nexport class ClientAuthService {\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly tokenService: TokenService,\n    private readonly emailVerificationService: EmailVerificationService,\n  ) {}\n\n  async registerClient(registerDto: RegisterClientDto) {\n    // Check if user already exists\n    const existingUser = await this.prisma.user.findUnique({\n      where: { email: registerDto.email },\n    });\n\n    if (existingUser) {\n      throw new BadRequestException('User with this email already exists');\n    }\n\n    // Hash password\n    const hashedPassword = await bcrypt.hash(registerDto.password, 12);\n\n    // Create user and client profile in transaction\n    const result = await this.prisma.$transaction(async (tx) => {\n      const user = await tx.user.create({\n        data: {\n          email: registerDto.email,\n          password: hashedPassword,\n          firstName: registerDto.firstName,\n          lastName: registerDto.lastName,\n          middleName: registerDto.middleName || undefined,\n          birthDate: registerDto.birthDate ? new Date(registerDto.birthDate) : undefined,\n          address: registerDto.address || undefined,\n          avatarUrl: registerDto.avatarUrl || undefined,\n          role: 'client',\n          emailVerified: false,\n        },\n      });\n\n      const client = await tx.client.create({\n        data: {\n          userId: user.id,\n          hasSeenTherapistRecommendations: registerDto.hasSeenTherapistRecommendations || false,\n        },\n      });\n\n      return { user, client };\n    });\n\n    // Generate tokens\n    const tokens = await this.tokenService.generateTokenPair(\n      result.user.id,\n      result.user.email,\n      result.user.role,\n    );\n\n    // Send verification email\n    await this.emailVerificationService.sendVerificationEmail(result.user.id);\n\n    return {\n      user: result.user,\n      tokens,\n      message:\n        'Client registration successful. Please check your email for verification.',\n    };\n  }\n\n  async loginClient(\n    email: string,\n    password: string,\n    ipAddress?: string,\n    userAgent?: string,\n  ) {\n    // Find user with client role\n    const user = await this.prisma.user.findFirst({\n      where: {\n        email,\n        role: 'client',\n      },\n      include: {\n        client: true,\n      },\n    });\n\n    if (!user) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    // Check if account is locked\n    if (user.lockoutUntil && user.lockoutUntil > new Date()) {\n      throw new UnauthorizedException(\n        'Account is temporarily locked due to failed login attempts',\n      );\n    }\n\n    // Verify password\n    if (!user.password) {\n      throw new UnauthorizedException('Account setup incomplete');\n    }\n    const isPasswordValid = await bcrypt.compare(password, user.password);\n    if (!isPasswordValid) {\n      // Increment failed login count\n      await this.handleFailedLogin(user.id);\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    // Reset failed login count and update last login\n    await this.prisma.user.update({\n      where: { id: user.id },\n      data: {\n        failedLoginCount: 0,\n        lockoutUntil: null,\n        lastLoginAt: new Date(),\n      },\n    });\n\n    // Generate tokens\n    const tokens = await this.tokenService.generateTokenPair(\n      user.id,\n      user.email,\n      user.role,\n      ipAddress,\n      userAgent,\n    );\n\n    return {\n      user,\n      tokens,\n    };\n  }\n\n  async getClientProfile(userId: string) {\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n      include: {\n        client: {\n          include: {\n            assignedTherapists: {\n              include: {\n                therapist: {\n                  include: {\n                    user: {\n                      select: {\n                        id: true,\n                        firstName: true,\n                        lastName: true,\n                        email: true,\n                        avatarUrl: true,\n                      },\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    });\n\n    if (!user || user.role !== 'client') {\n      throw new UnauthorizedException('Client not found');\n    }\n\n    return user;\n  }\n\n  async getFirstSignInStatus(userId: string) {\n    const client = await this.prisma.client.findUnique({\n      where: { userId },\n      select: {\n        hasSeenTherapistRecommendations: true,\n      },\n    });\n\n    if (!client) {\n      throw new UnauthorizedException('Client not found');\n    }\n\n    return {\n      hasSeenTherapistRecommendations: client.hasSeenTherapistRecommendations,\n    };\n  }\n\n  async markRecommendationsSeen(userId: string) {\n    const client = await this.prisma.client.findUnique({\n      where: { userId },\n    });\n\n    if (!client) {\n      throw new UnauthorizedException('Client not found');\n    }\n\n    await this.prisma.client.update({\n      where: { userId },\n      data: {\n        hasSeenTherapistRecommendations: true,\n      },\n    });\n\n    return {\n      message: 'Recommendations marked as seen',\n    };\n  }\n\n  private async handleFailedLogin(userId: string) {\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n      select: { failedLoginCount: true },\n    });\n\n    const newFailedCount = (user?.failedLoginCount || 0) + 1;\n    const maxAttempts = 5;\n    const lockoutDuration = 30 * 60 * 1000; // 30 minutes\n\n    const updateData: any = {\n      failedLoginCount: newFailedCount,\n    };\n\n    if (newFailedCount >= maxAttempts) {\n      updateData.lockoutUntil = new Date(Date.now() + lockoutDuration);\n    }\n\n    await this.prisma.user.update({\n      where: { id: userId },\n      data: updateData,\n    });\n  }\n}\n"],"version":3}