{"file":"/home/wetooa/Documents/code/projects/mentara/mentara-api/src/booking/booking.service.ts","mappings":"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","names":[],"sources":["/home/wetooa/Documents/code/projects/mentara/mentara-api/src/booking/booking.service.ts"],"sourcesContent":["import {\n  Injectable,\n  BadRequestException,\n  NotFoundException,\n  ForbiddenException,\n  Logger,\n} from '@nestjs/common';\nimport { PrismaService } from '../providers/prisma-client.provider';\nimport { MeetingStatus } from '@prisma/client';\nimport { ACTIVE_MEETING_STATUSES_ARRAY } from './constants/meeting-status.constants';\nimport type {\n  MeetingCreateDto,\n  MeetingUpdateDto,\n  TherapistAvailabilityCreateDto,\n  TherapistAvailabilityUpdateDto,\n} from './types';\nimport { EventBusService } from '../common/events/event-bus.service';\nimport { SlotGeneratorService } from './services/slot-generator.service';\nimport { ConflictDetectionService } from './services/conflict-detection.service';\nimport { AvailabilityValidatorService } from './services/availability-validator.service';\nimport { BillingService } from '../billing/billing.service';\nimport {\n  AppointmentBookedEvent,\n  AppointmentCancelledEvent,\n  AppointmentCompletedEvent,\n  AppointmentRescheduledEvent,\n} from '../common/events/booking-events';\n\n@Injectable()\nexport class BookingService {\n  private readonly logger = new Logger(BookingService.name);\n\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly eventBus: EventBusService,\n    private readonly slotGenerator: SlotGeneratorService,\n    private readonly conflictDetection: ConflictDetectionService,\n    private readonly availabilityValidator: AvailabilityValidatorService,\n    private readonly billingService: BillingService,\n  ) {}\n\n  // Meeting Management\n  async createMeeting(createMeetingDto: MeetingCreateDto, clientId: string) {\n    const { startTime, therapistId, duration } = createMeetingDto;\n    \n    const startTimeDate = new Date(startTime || createMeetingDto.dateTime);\n    const endTimeDate = new Date(startTimeDate.getTime() + duration * 60000);\n\n    // Use database transaction to prevent race conditions\n    const result = await this.prisma.$transaction(\n      async (tx) => {\n        // First, acquire locks on both therapist and client schedules\n        // This prevents concurrent bookings from interfering\n        const [therapistLock, clientLock] = await Promise.all([\n          tx.user.findUnique({\n            where: { id: therapistId },\n            select: { id: true },\n          }),\n          tx.user.findUnique({\n            where: { id: clientId },\n            select: { id: true },\n          }),\n        ]);\n\n        if (!therapistLock || !clientLock) {\n          throw new BadRequestException('Therapist or client not found');\n        }\n\n        // Check for conflicts within transaction (atomic operation)\n        const conflictingMeetings = await tx.meeting.findMany({\n          where: {\n            OR: [\n              {\n                therapistId,\n                startTime: { lt: endTimeDate },\n                endTime: { gt: startTimeDate },\n                status: { in: ACTIVE_MEETING_STATUSES_ARRAY },\n              },\n              {\n                clientId,\n                startTime: { lt: endTimeDate },\n                endTime: { gt: startTimeDate },\n                status: { in: ACTIVE_MEETING_STATUSES_ARRAY },\n              },\n            ],\n          },\n        });\n\n        if (conflictingMeetings.length > 0) {\n          throw new BadRequestException(\n            `Schedule conflict detected: ${conflictingMeetings.length} conflicting meetings found`,\n          );\n        }\n\n        // Validate therapist availability using the validator service\n        await this.availabilityValidator.validateTherapistAvailabilityWithTransaction(\n          therapistId,\n          startTimeDate,\n          duration,\n          tx, // Pass transaction client\n        );\n\n        // Create the meeting within the transaction\n        const meeting = await tx.meeting.create({\n          data: {\n            ...createMeetingDto,\n            startTime: startTimeDate,\n            endTime: endTimeDate,\n            status: 'SCHEDULED',\n            clientId,\n          },\n          include: {\n            client: {\n              select: {\n                user: {\n                  select: {\n                    firstName: true,\n                    lastName: true,\n                    email: true,\n                  },\n                },\n              },\n            },\n            therapist: {\n              select: {\n                user: {\n                  select: {\n                    firstName: true,\n                    lastName: true,\n                    email: true,\n                  },\n                },\n              },\n            },\n          },\n        });\n\n        // Create automatic mock payment for the meeting\n        const sessionPrice = 100; // Mock session price - should come from therapist rates or duration\n        await this.billingService.createAutomaticMockPayment({\n          clientId: meeting.clientId,\n          therapistId: meeting.therapistId,\n          meetingId: meeting.id,\n          amount: sessionPrice,\n          currency: 'USD',\n          description: `Payment for therapy session: ${meeting.title || 'Therapy Session'}`,\n        }, tx);\n\n        // Publish appointment booked event\n        await this.eventBus.emit(\n          new AppointmentBookedEvent({\n            appointmentId: meeting.id,\n            clientId: meeting.clientId,\n            therapistId: meeting.therapistId,\n            startTime: meeting.startTime,\n            meetingType: meeting.meetingType as\n              | 'video'\n              | 'audio'\n              | 'in_person'\n              | 'chat',\n            duration: meeting.duration,\n            title: meeting.title || 'Therapy Session',\n            description: meeting.description || undefined,\n            isInitialConsultation: false,\n          }),\n        );\n\n        // Transform the response to match frontend expectations\n        return {\n          ...meeting,\n          dateTime: meeting.startTime, // Map startTime to dateTime for frontend compatibility\n          therapistName: meeting.therapist?.user\n            ? `${meeting.therapist.user.firstName} ${meeting.therapist.user.lastName}`\n            : 'Unknown Therapist',\n        };\n      },\n      {\n        isolationLevel: 'Serializable', // Highest isolation level to prevent race conditions\n        timeout: 10000, // 10 second timeout\n        maxWait: 5000, // Max wait time for transaction lock\n      },\n    );\n\n    return result;\n  }\n\n  async getMeetings(\n    userId: string,\n    role: string,\n    queryOptions?: {\n      status?: string;\n      limit?: number;\n      offset?: number;\n    },\n  ) {\n    try {\n      const where: any =\n        role === 'therapist' ? { therapistId: userId } : { clientId: userId };\n\n      // Handle status filtering\n      if (queryOptions?.status) {\n        const statusValues = queryOptions.status\n          .split(',')\n          .map((s) => s.trim().toUpperCase());\n        where.status = { in: statusValues };\n      }\n\n      const meetings = await this.prisma.meeting.findMany({\n        where,\n        include: {\n          client: {\n            select: {\n              user: {\n                select: {\n                  firstName: true,\n                  lastName: true,\n                  email: true,\n                },\n              },\n            },\n          },\n          therapist: {\n            select: {\n              user: {\n                select: {\n                  firstName: true,\n                  lastName: true,\n                  email: true,\n                },\n              },\n            },\n          },\n        },\n        orderBy: { startTime: 'desc' },\n        take: queryOptions?.limit,\n        skip: queryOptions?.offset,\n      });\n\n      // Transform the response to match frontend expectations\n      return meetings.map((meeting) => ({\n        ...meeting,\n        dateTime: meeting.startTime, // Map startTime to dateTime for frontend compatibility\n        therapistName: meeting.therapist?.user\n          ? `${meeting.therapist.user.firstName} ${meeting.therapist.user.lastName}`\n          : 'Unknown Therapist',\n      }));\n    } catch (error) {\n      throw new BadRequestException(\n        error instanceof Error ? error.message : String(error),\n      );\n    }\n  }\n\n  async getMeeting(id: string, userId: string, role: string) {\n    try {\n      const meeting = await this.prisma.meeting.findUnique({\n        where: { id },\n        include: {\n          client: {\n            select: {\n              user: {\n                select: {\n                  firstName: true,\n                  lastName: true,\n                  email: true,\n                },\n              },\n            },\n          },\n          therapist: {\n            select: {\n              user: {\n                select: {\n                  firstName: true,\n                  lastName: true,\n                  email: true,\n                },\n              },\n            },\n          },\n        },\n      });\n\n      if (!meeting) {\n        throw new NotFoundException('Meeting not found');\n      }\n\n      // Verify user has access to this meeting\n      if (role === 'therapist' && meeting.therapistId !== userId) {\n        throw new ForbiddenException('Access denied');\n      }\n      if (role === 'client' && meeting.clientId !== userId) {\n        throw new ForbiddenException('Access denied');\n      }\n\n      // Transform the response to match frontend expectations\n      return {\n        ...meeting,\n        dateTime: meeting.startTime, // Map startTime to dateTime for frontend compatibility\n        therapistName: meeting.therapist?.user\n          ? `${meeting.therapist.user.firstName} ${meeting.therapist.user.lastName}`\n          : 'Unknown Therapist',\n      };\n    } catch (error) {\n      throw new BadRequestException(\n        error instanceof Error ? error.message : String(error),\n      );\n    }\n  }\n\n  async updateMeeting(\n    id: string,\n    updateMeetingDto: MeetingUpdateDto,\n    userId: string,\n    role: string,\n  ) {\n    try {\n      const meeting = await this.getMeeting(id, userId, role);\n\n      // Only allow updates if meeting is not completed or cancelled\n      if (['COMPLETED', 'CANCELLED'].includes(meeting.status)) {\n        throw new BadRequestException(\n          'Cannot update completed or cancelled meetings',\n        );\n      }\n\n      // If updating time, validate the new schedule\n      if (updateMeetingDto.startTime || updateMeetingDto.duration) {\n        const newStartTime = updateMeetingDto.startTime\n          ? new Date(updateMeetingDto.startTime)\n          : meeting.startTime;\n        const newDuration = updateMeetingDto.duration || meeting.duration;\n\n        // Check for conflicts with the update\n        const conflicts = await this.conflictDetection.checkUpdateConflicts(\n          id,\n          meeting.therapistId,\n          meeting.clientId,\n          newStartTime,\n          newDuration,\n        );\n\n        if (conflicts.hasConflict) {\n          throw new BadRequestException(\n            `Schedule update would cause conflicts: ${conflicts.conflictingMeetings.length} conflicting meetings found`,\n          );\n        }\n\n        // Validate therapist availability for new time\n        if (updateMeetingDto.startTime) {\n          await this.availabilityValidator.validateTherapistAvailability(\n            meeting.therapistId,\n            newStartTime,\n            newDuration,\n          );\n        }\n      }\n\n      const updatedMeeting = await this.prisma.meeting.update({\n        where: { id },\n        data: {\n          title: updateMeetingDto.title,\n          description: updateMeetingDto.description,\n          startTime: updateMeetingDto.startTime,\n          duration: updateMeetingDto.duration,\n          meetingType: updateMeetingDto.meetingType,\n          meetingUrl: updateMeetingDto.meetingUrl,\n          ...(updateMeetingDto.status && {\n            status: updateMeetingDto.status as MeetingStatus,\n          }),\n        },\n        include: {\n          client: {\n            select: {\n              user: {\n                select: {\n                  firstName: true,\n                  lastName: true,\n                  email: true,\n                },\n              },\n            },\n          },\n          therapist: {\n            select: {\n              user: {\n                select: {\n                  firstName: true,\n                  lastName: true,\n                  email: true,\n                },\n              },\n            },\n          },\n        },\n      });\n\n      // Publish appropriate events\n      if (updateMeetingDto.status === 'completed') {\n        await this.eventBus.emit(\n          new AppointmentCompletedEvent({\n            appointmentId: updatedMeeting.id,\n            clientId: updatedMeeting.clientId,\n            therapistId: updatedMeeting.therapistId,\n            completedAt: new Date(),\n            duration: updatedMeeting.duration,\n            sessionNotes: updateMeetingDto.description || '',\n            attendanceStatus: 'ATTENDED',\n          }),\n        );\n      } else if (\n        updateMeetingDto.startTime &&\n        new Date(updateMeetingDto.startTime).getTime() !==\n          meeting.startTime.getTime()\n      ) {\n        await this.eventBus.emit(\n          new AppointmentRescheduledEvent({\n            appointmentId: updatedMeeting.id,\n            clientId: updatedMeeting.clientId,\n            therapistId: updatedMeeting.therapistId,\n            rescheduledBy: userId,\n            originalStartTime: meeting.startTime,\n            newStartTime: new Date(updateMeetingDto.startTime),\n            rescheduleReason: `Rescheduled by ${role}`,\n          }),\n        );\n      }\n\n      return updatedMeeting;\n    } catch (error) {\n      throw new BadRequestException(\n        error instanceof Error ? error.message : String(error),\n      );\n    }\n  }\n\n  async cancelMeeting(id: string, userId: string, role: string) {\n    try {\n      const meeting = await this.getMeeting(id, userId, role);\n\n      if (meeting.status === 'CANCELLED') {\n        throw new BadRequestException('Meeting is already cancelled');\n      }\n\n      if (meeting.status === 'COMPLETED') {\n        throw new BadRequestException('Cannot cancel completed meetings');\n      }\n\n      const cancelledMeeting = await this.prisma.meeting.update({\n        where: { id },\n        data: { status: 'CANCELLED' },\n        include: {\n          client: {\n            select: {\n              user: {\n                select: {\n                  firstName: true,\n                  lastName: true,\n                  email: true,\n                },\n              },\n            },\n          },\n          therapist: {\n            select: {\n              user: {\n                select: {\n                  firstName: true,\n                  lastName: true,\n                  email: true,\n                },\n              },\n            },\n          },\n        },\n      });\n\n      // Calculate cancellation notice\n      const cancellationNotice = Math.floor(\n        (meeting.startTime.getTime() - Date.now()) / (1000 * 60 * 60),\n      );\n\n      // Handle payment refund for cancelled sessions\n      try {\n        // Find payment record associated with this meeting using the updated API\n        const payments = await this.billingService.getUserPayments(userId, {\n          limit: 100,\n        });\n        const meetingPayment = payments.find((p) => p.meetingId === meeting.id);\n\n        if (meetingPayment && cancellationNotice >= 24) {\n          // 24-hour cancellation policy\n          // NOTE: Refund logic would need to be implemented in billing service\n          // For now, we'll emit an event that a refund is needed\n          this.logger.log(\n            `Refund needed for cancelled session ${meeting.id} - ${cancellationNotice}h notice`,\n          );\n          // TODO: Implement refund processing in billing service\n        }\n      } catch (refundError) {\n        // Log refund error but don't fail the cancellation\n        console.error(\n          'Failed to process refund for cancelled meeting:',\n          refundError,\n        );\n      }\n\n      // Publish cancellation event\n      await this.eventBus.emit(\n        new AppointmentCancelledEvent({\n          appointmentId: cancelledMeeting.id,\n          clientId: cancelledMeeting.clientId,\n          therapistId: cancelledMeeting.therapistId,\n          cancelledBy: userId,\n          cancellationReason:\n            role === 'client'\n              ? 'Cancelled by client'\n              : 'Cancelled by therapist',\n          originalStartTime: meeting.startTime,\n          cancelledAt: new Date(),\n          cancellationNotice: Math.max(0, cancellationNotice),\n        }),\n      );\n\n      return cancelledMeeting;\n    } catch (error) {\n      throw new BadRequestException(\n        error instanceof Error ? error.message : String(error),\n      );\n    }\n  }\n\n  // Availability Management\n  async createAvailability(\n    createAvailabilityDto: TherapistAvailabilityCreateDto,\n    therapistId: string,\n  ) {\n    try {\n      const { dayOfWeek, startTime, endTime, notes } = createAvailabilityDto;\n\n      // Validate using our new service\n      await this.availabilityValidator.validateAvailabilityCreation({\n        therapistId,\n        dayOfWeek,\n        startTime,\n        endTime,\n      });\n\n      return this.prisma.therapistAvailability.create({\n        data: {\n          therapistId,\n          dayOfWeek: dayOfWeek.toString(),\n          startTime,\n          endTime,\n          notes,\n        },\n      });\n    } catch (error) {\n      throw new BadRequestException(\n        error instanceof Error ? error.message : String(error),\n      );\n    }\n  }\n\n  async getAvailability(therapistId: string) {\n    try {\n      return await this.prisma.therapistAvailability.findMany({\n        where: { therapistId },\n        orderBy: [{ dayOfWeek: 'asc' }, { startTime: 'asc' }],\n      });\n    } catch (error) {\n      throw new BadRequestException(\n        error instanceof Error ? error.message : String(error),\n      );\n    }\n  }\n\n  async updateAvailability(\n    id: string,\n    updateAvailabilityDto: TherapistAvailabilityUpdateDto,\n    therapistId: string,\n  ) {\n    try {\n      const availability = await this.prisma.therapistAvailability.findFirst({\n        where: { id, therapistId },\n      });\n\n      if (!availability) {\n        throw new NotFoundException('Availability slot not found');\n      }\n\n      // Convert dayOfWeek to string if present\n      const { dayOfWeek, ...rest } = updateAvailabilityDto;\n      const updateData = {\n        ...rest,\n        ...(dayOfWeek !== undefined && {\n          dayOfWeek: dayOfWeek.toString(),\n        }),\n      };\n\n      return this.prisma.therapistAvailability.update({\n        where: { id },\n        data: updateData,\n      });\n    } catch (error) {\n      throw new BadRequestException(\n        error instanceof Error ? error.message : String(error),\n      );\n    }\n  }\n\n  async deleteAvailability(id: string, therapistId: string) {\n    try {\n      const availability = await this.prisma.therapistAvailability.findFirst({\n        where: { id, therapistId },\n      });\n\n      if (!availability) {\n        throw new NotFoundException('Availability slot not found');\n      }\n\n      return this.prisma.therapistAvailability.delete({\n        where: { id },\n      });\n    } catch (error) {\n      throw new BadRequestException(\n        error instanceof Error ? error.message : String(error),\n      );\n    }\n  }\n\n  // Simplified slot generation using our new service\n  async getAvailableSlots(therapistId: string, date: string) {\n    try {\n      return await this.slotGenerator.generateAvailableSlots(therapistId, date);\n    } catch (error) {\n      throw new BadRequestException(\n        error instanceof Error ? error.message : String(error),\n      );\n    }\n  }\n\n  // Duration management\n  getDurations() {\n    return [\n      { id: '30', name: '30 minutes', duration: 30 },\n      { id: '60', name: '60 minutes', duration: 60 },\n      { id: '90', name: '90 minutes', duration: 90 },\n      { id: '120', name: '120 minutes', duration: 120 },\n    ];\n  }\n\n  // Enhanced validation method using our services\n  async validateMeetingTime(\n    therapistId: string,\n    clientId: string,\n    startTime: string | Date,\n    duration: number,\n  ) {\n    const startTimeDate = new Date(startTime);\n\n    await this.availabilityValidator.validateMeetingCreation({\n      therapistId,\n      clientId,\n      startTime: startTimeDate,\n      duration,\n    });\n\n    await this.conflictDetection.validateNoConflicts(\n      therapistId,\n      clientId,\n      startTimeDate,\n      duration,\n    );\n\n    return true;\n  }\n}\n"],"version":3}