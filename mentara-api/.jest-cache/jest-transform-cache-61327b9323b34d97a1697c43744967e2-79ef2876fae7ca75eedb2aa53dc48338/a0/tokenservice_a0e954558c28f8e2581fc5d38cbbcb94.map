{"file":"/home/wetooa/Documents/code/projects/mentara/mentara-api/src/auth/services/token.service.ts","mappings":"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","names":[],"sources":["/home/wetooa/Documents/code/projects/mentara/mentara-api/src/auth/services/token.service.ts"],"sourcesContent":["import { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { PrismaService } from '../../providers/prisma-client.provider';\nimport { JwtPayload } from '../strategies/jwt.strategy';\nimport * as crypto from 'crypto';\nimport * as bcrypt from 'bcrypt';\n\nexport interface TokenPair {\n  accessToken: string;\n  refreshToken: string;\n  expiresIn: string;\n}\n\nexport interface RefreshTokenData {\n  token: string;\n  userId: string;\n  expiresAt: Date;\n  ipAddress?: string;\n  userAgent?: string;\n}\n\n@Injectable()\nexport class TokenService {\n  constructor(\n    private readonly jwtService: JwtService,\n    private readonly prisma: PrismaService,\n  ) {}\n\n  async generateTokenPair(\n    userId: string,\n    email: string,\n    role: string,\n    ipAddress?: string,\n    userAgent?: string,\n  ): Promise<TokenPair> {\n    const payload: JwtPayload = {\n      sub: userId,\n      email,\n      role,\n    };\n\n    const accessToken = this.jwtService.sign(payload, {\n      expiresIn: process.env.JWT_EXPIRES_IN || '1h',\n    });\n\n    const refreshToken = await this.generateRefreshToken(\n      userId,\n      ipAddress,\n      userAgent,\n    );\n\n    return {\n      accessToken,\n      refreshToken: refreshToken.token,\n      expiresIn: process.env.JWT_EXPIRES_IN || '1h',\n    };\n  }\n\n  private async generateRefreshToken(\n    userId: string,\n    ipAddress?: string,\n    userAgent?: string,\n  ): Promise<RefreshTokenData> {\n    // Generate cryptographically secure random token\n    const token = crypto.randomBytes(64).toString('hex');\n    const hashedToken = crypto.createHash('sha256').update(token).digest('hex');\n\n    const expiresAt = new Date();\n    expiresAt.setDate(\n      expiresAt.getDate() +\n        parseInt(process.env.JWT_REFRESH_EXPIRES_IN?.replace('d', '') || '7'),\n    );\n\n    // Extract device information from userAgent\n    const deviceName = this.extractDeviceInfo(userAgent);\n\n    // Store hashed token in database with enhanced session tracking\n    await this.prisma.refreshToken.create({\n      data: {\n        token: hashedToken,\n        userId,\n        expiresAt,\n        ipAddress,\n        userAgent,\n        deviceName,\n        location: await this.getLocationFromIP(ipAddress),\n        lastActivity: new Date(),\n      },\n    });\n\n    return {\n      token,\n      userId,\n      expiresAt,\n      ipAddress,\n      userAgent,\n    };\n  }\n\n  async refreshAccessToken(\n    refreshToken: string,\n    ipAddress?: string,\n    userAgent?: string,\n  ): Promise<TokenPair> {\n    const hashedToken = crypto\n      .createHash('sha256')\n      .update(refreshToken)\n      .digest('hex');\n\n    const storedToken = await this.prisma.refreshToken.findUnique({\n      where: { token: hashedToken },\n      include: { user: true },\n    });\n\n    if (!storedToken) {\n      throw new UnauthorizedException('Invalid refresh token');\n    }\n\n    if (storedToken.expiresAt < new Date()) {\n      // Clean up expired token\n      await this.prisma.refreshToken.delete({\n        where: { id: storedToken.id },\n      });\n      throw new UnauthorizedException('Refresh token expired');\n    }\n\n    if (storedToken.revokedAt) {\n      throw new UnauthorizedException('Refresh token revoked');\n    }\n\n    if (storedToken.user.deactivatedAt) {\n      throw new UnauthorizedException('User account deactivated');\n    }\n\n    // Update session activity before revoking\n    await this.prisma.refreshToken.update({\n      where: { id: storedToken.id },\n      data: { lastActivity: new Date() },\n    });\n\n    // Revoke old refresh token\n    await this.prisma.refreshToken.update({\n      where: { id: storedToken.id },\n      data: { revokedAt: new Date() },\n    });\n\n    // Generate new token pair\n    return this.generateTokenPair(\n      storedToken.userId,\n      storedToken.user.email,\n      storedToken.user.role,\n      ipAddress,\n      userAgent,\n    );\n  }\n\n  async revokeRefreshToken(refreshToken: string): Promise<void> {\n    const hashedToken = crypto\n      .createHash('sha256')\n      .update(refreshToken)\n      .digest('hex');\n\n    await this.prisma.refreshToken.updateMany({\n      where: {\n        token: hashedToken,\n        revokedAt: null,\n      },\n      data: { revokedAt: new Date() },\n    });\n  }\n\n  async revokeAllUserTokens(userId: string): Promise<void> {\n    await this.prisma.refreshToken.updateMany({\n      where: {\n        userId,\n        revokedAt: null,\n      },\n      data: { revokedAt: new Date() },\n    });\n  }\n\n  async cleanupExpiredTokens(): Promise<void> {\n    await this.prisma.refreshToken.deleteMany({\n      where: {\n        OR: [{ expiresAt: { lt: new Date() } }, { revokedAt: { not: null } }],\n      },\n    });\n  }\n\n  // Password hashing utilities\n  async hashPassword(password: string): Promise<string> {\n    const saltRounds = parseInt(process.env.BCRYPT_SALT_ROUNDS || '12');\n    return bcrypt.hash(password, saltRounds);\n  }\n\n  async comparePassword(\n    password: string,\n    hashedPassword: string,\n  ): Promise<boolean> {\n    return bcrypt.compare(password, hashedPassword);\n  }\n\n  // Email verification token generation\n  async generateEmailVerificationToken(): Promise<{\n    token: string;\n    hashedToken: string;\n    expiresAt: Date;\n  }> {\n    const token = crypto.randomBytes(32).toString('hex');\n    const hashedToken = crypto.createHash('sha256').update(token).digest('hex');\n\n    const expiresAt = new Date();\n    expiresAt.setHours(expiresAt.getHours() + 24); // 24 hours expiry\n\n    return { token, hashedToken, expiresAt };\n  }\n\n  // Password reset token generation\n  async generatePasswordResetToken(): Promise<{\n    token: string;\n    hashedToken: string;\n    expiresAt: Date;\n  }> {\n    const token = crypto.randomBytes(32).toString('hex');\n    const hashedToken = crypto.createHash('sha256').update(token).digest('hex');\n\n    const expiresAt = new Date();\n    expiresAt.setHours(expiresAt.getHours() + 1); // 1 hour expiry for security\n\n    return { token, hashedToken, expiresAt };\n  }\n\n  // Account lockout utilities\n  async checkAccountLockout(userId: string): Promise<boolean> {\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n      select: { lockoutUntil: true, failedLoginCount: true },\n    });\n\n    if (!user) return false;\n\n    // Check if account is currently locked\n    if (user.lockoutUntil && user.lockoutUntil > new Date()) {\n      return true;\n    }\n\n    // Clear lockout if time has passed\n    if (user.lockoutUntil && user.lockoutUntil <= new Date()) {\n      await this.prisma.user.update({\n        where: { id: userId },\n        data: {\n          lockoutUntil: null,\n          failedLoginCount: 0,\n        },\n      });\n    }\n\n    return false;\n  }\n\n  async handleFailedLogin(userId: string): Promise<void> {\n    const maxAttempts = parseInt(process.env.MAX_LOGIN_ATTEMPTS || '5');\n    const lockoutDuration = parseInt(\n      process.env.LOCKOUT_DURATION_MINUTES || '15',\n    );\n\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n      select: { failedLoginCount: true },\n    });\n\n    if (!user) return;\n\n    const newFailedCount = user.failedLoginCount + 1;\n    const updateData: any = { failedLoginCount: newFailedCount };\n\n    // Lock account if max attempts reached\n    if (newFailedCount >= maxAttempts) {\n      const lockoutUntil = new Date();\n      lockoutUntil.setMinutes(lockoutUntil.getMinutes() + lockoutDuration);\n      updateData.lockoutUntil = lockoutUntil;\n    }\n\n    await this.prisma.user.update({\n      where: { id: userId },\n      data: updateData,\n    });\n  }\n\n  async resetFailedLoginCount(userId: string): Promise<void> {\n    await this.prisma.user.update({\n      where: { id: userId },\n      data: {\n        failedLoginCount: 0,\n        lockoutUntil: null,\n        lastLoginAt: new Date(),\n      },\n    });\n  }\n\n  /**\n   * Validates a JWT token and returns the payload and expiration info\n   * @param token - The JWT token to validate\n   * @returns Promise with validation result\n   */\n  async validateToken(token: string): Promise<{\n    valid: boolean;\n    payload?: any;\n    expires?: string;\n    error?: string;\n  }> {\n    try {\n      // Verify and decode the token\n      const payload = this.jwtService.verify(token);\n\n      // Check if token has expired\n      const now = Math.floor(Date.now() / 1000);\n      if (payload.exp && payload.exp < now) {\n        return {\n          valid: false,\n          error: 'Token has expired',\n        };\n      }\n\n      // Convert expiration timestamp to ISO string\n      const expiresAt = payload.exp\n        ? new Date(payload.exp * 1000).toISOString()\n        : undefined;\n\n      return {\n        valid: true,\n        payload,\n        expires: expiresAt,\n      };\n    } catch (error) {\n      return {\n        valid: false,\n        error: error instanceof Error ? error.message : 'Invalid token',\n      };\n    }\n  }\n\n  // Session Management Methods\n\n  /**\n   * Get current session information based on refresh token\n   */\n  async getSessionInfo(refreshToken: string): Promise<{\n    sessionId: string;\n    createdAt: string;\n    lastActivity: string;\n    device: string;\n    location: string;\n    ipAddress: string;\n    userAgent: string;\n  } | null> {\n    const hashedToken = crypto\n      .createHash('sha256')\n      .update(refreshToken)\n      .digest('hex');\n\n    const session = await this.prisma.refreshToken.findUnique({\n      where: {\n        token: hashedToken,\n        revokedAt: null,\n      },\n    });\n\n    if (!session || session.expiresAt < new Date()) {\n      return null;\n    }\n\n    return {\n      sessionId: session.id,\n      createdAt: session.createdAt.toISOString(),\n      lastActivity: session.lastActivity.toISOString(),\n      device: session.deviceName || 'Unknown Device',\n      location: session.location || 'Unknown Location',\n      ipAddress: session.ipAddress || 'Unknown IP',\n      userAgent: session.userAgent || 'Unknown User Agent',\n    };\n  }\n\n  /**\n   * Get all active sessions for a user\n   */\n  async getActiveSessions(\n    userId: string,\n    currentRefreshToken?: string,\n  ): Promise<{\n    sessions: Array<{\n      id: string;\n      device: string;\n      location: string;\n      lastActivity: string;\n      isCurrent: boolean;\n      ipAddress: string;\n      userAgent: string;\n      createdAt: string;\n    }>;\n  }> {\n    const sessions = await this.prisma.refreshToken.findMany({\n      where: {\n        userId,\n        revokedAt: null,\n        expiresAt: { gt: new Date() },\n      },\n      orderBy: {\n        lastActivity: 'desc',\n      },\n    });\n\n    let currentHashedToken: string | null = null;\n    if (currentRefreshToken) {\n      currentHashedToken = crypto\n        .createHash('sha256')\n        .update(currentRefreshToken)\n        .digest('hex');\n    }\n\n    return {\n      sessions: sessions.map((session) => ({\n        id: session.id,\n        device: session.deviceName || 'Unknown Device',\n        location: session.location || 'Unknown Location',\n        lastActivity: session.lastActivity.toISOString(),\n        isCurrent: currentHashedToken === session.token,\n        ipAddress: session.ipAddress || 'Unknown IP',\n        userAgent: session.userAgent || 'Unknown User Agent',\n        createdAt: session.createdAt.toISOString(),\n      })),\n    };\n  }\n\n  /**\n   * Terminate a specific session by session ID\n   */\n  async terminateSession(\n    sessionId: string,\n    userId: string,\n  ): Promise<{\n    success: boolean;\n    message: string;\n  }> {\n    const session = await this.prisma.refreshToken.findFirst({\n      where: {\n        id: sessionId,\n        userId,\n        revokedAt: null,\n      },\n    });\n\n    if (!session) {\n      return {\n        success: false,\n        message: 'Session not found or already terminated',\n      };\n    }\n\n    await this.prisma.refreshToken.update({\n      where: { id: sessionId },\n      data: { revokedAt: new Date() },\n    });\n\n    return {\n      success: true,\n      message: 'Session terminated successfully',\n    };\n  }\n\n  /**\n   * Terminate all other sessions except the current one\n   */\n  async terminateOtherSessions(\n    userId: string,\n    currentRefreshToken?: string,\n  ): Promise<{\n    success: boolean;\n    terminatedCount: number;\n    message: string;\n  }> {\n    let currentHashedToken: string | null = null;\n    if (currentRefreshToken) {\n      currentHashedToken = crypto\n        .createHash('sha256')\n        .update(currentRefreshToken)\n        .digest('hex');\n    }\n\n    const whereClause: any = {\n      userId,\n      revokedAt: null,\n    };\n\n    if (currentHashedToken) {\n      whereClause.token = { not: currentHashedToken };\n    }\n\n    const result = await this.prisma.refreshToken.updateMany({\n      where: whereClause,\n      data: { revokedAt: new Date() },\n    });\n\n    return {\n      success: true,\n      terminatedCount: result.count,\n      message: `${result.count} sessions terminated successfully`,\n    };\n  }\n\n  /**\n   * Update session activity (called when tokens are used)\n   */\n  async updateSessionActivity(refreshToken: string): Promise<void> {\n    const hashedToken = crypto\n      .createHash('sha256')\n      .update(refreshToken)\n      .digest('hex');\n\n    await this.prisma.refreshToken.updateMany({\n      where: {\n        token: hashedToken,\n        revokedAt: null,\n      },\n      data: {\n        lastActivity: new Date(),\n      },\n    });\n  }\n\n  /**\n   * Helper method to extract device information from user agent\n   */\n  private extractDeviceInfo(userAgent?: string): string {\n    if (!userAgent) return 'Unknown Device';\n\n    const ua = userAgent.toLowerCase();\n\n    // Mobile devices\n    if (ua.includes('mobile') || ua.includes('android')) {\n      if (ua.includes('android')) return 'Android Device';\n      if (ua.includes('iphone')) return 'iPhone';\n      if (ua.includes('ipad')) return 'iPad';\n      return 'Mobile Device';\n    }\n\n    // Desktop browsers\n    if (ua.includes('windows')) return 'Windows PC';\n    if (ua.includes('macintosh') || ua.includes('mac os')) return 'Mac';\n    if (ua.includes('linux')) return 'Linux PC';\n    if (ua.includes('chrome')) return 'Chrome Browser';\n    if (ua.includes('firefox')) return 'Firefox Browser';\n    if (ua.includes('safari')) return 'Safari Browser';\n    if (ua.includes('edge')) return 'Edge Browser';\n\n    return 'Unknown Device';\n  }\n\n  /**\n   * Helper method to get approximate location from IP address\n   * This is a simple implementation - in production, you might want to use a proper geolocation service\n   */\n  private async getLocationFromIP(ipAddress?: string): Promise<string> {\n    if (!ipAddress || ipAddress === '127.0.0.1' || ipAddress === '::1') {\n      return 'Local';\n    }\n\n    // This is a placeholder - in production, you'd integrate with a geolocation service\n    // like MaxMind GeoIP, IP2Location, or a similar service\n    return 'Unknown Location';\n  }\n}\n"],"version":3}