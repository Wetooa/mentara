{"file":"/home/wetooa/Documents/code/projects/mentara/mentara-api/src/common/events/event-bus.service.ts","mappings":"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","names":[],"sources":["/home/wetooa/Documents/code/projects/mentara/mentara-api/src/common/events/event-bus.service.ts"],"sourcesContent":["import { Injectable, Logger } from '@nestjs/common';\nimport { EventEmitter2 } from '@nestjs/event-emitter';\nimport {\n  DomainEvent,\n  IEventBus,\n  EventHandlerOptions,\n} from './interfaces/domain-event.interface';\n\n@Injectable()\nexport class EventBusService implements IEventBus {\n  private readonly logger = new Logger(EventBusService.name);\n\n  constructor(private readonly eventEmitter: EventEmitter2) {}\n\n  async emit<T = any>(event: DomainEvent<T>): Promise<void> {\n    try {\n      this.logger.debug(`Emitting event: ${event.eventType}`, {\n        eventId: event.eventId,\n        aggregateId: event.aggregateId,\n        aggregateType: event.aggregateType,\n        correlationId: event.metadata.correlationId,\n      });\n\n      // Emit the specific event type\n      await this.eventEmitter.emitAsync(event.eventType, event);\n\n      // Emit a wildcard event for global listeners\n      await this.eventEmitter.emitAsync('*', event);\n\n      // Emit aggregate-specific events for aggregate listeners\n      await this.eventEmitter.emitAsync(`${event.aggregateType}.*`, event);\n\n      this.logger.debug(`Event emitted successfully: ${event.eventType}`);\n    } catch (error) {\n      this.logger.error(`Failed to emit event: ${event.eventType}`, {\n        eventId: event.eventId,\n        error: error instanceof Error ? error.message : String(error),\n        stack: error instanceof Error ? error.stack : undefined,\n      });\n      throw error;\n    }\n  }\n\n  subscribe<T = any>(\n    eventType: string,\n    handler: (event: DomainEvent<T>) => Promise<void>,\n    options: EventHandlerOptions = {},\n  ): void {\n    this.logger.debug(`Subscribing to event: ${eventType}`, {\n      handlerName: handler.name,\n      options,\n    });\n\n    const wrappedHandler = async (event: DomainEvent<T>) => {\n      try {\n        this.logger.debug(`Handling event: ${event.eventType}`, {\n          eventId: event.eventId,\n          handlerName: handler.name,\n        });\n\n        await handler(event);\n\n        this.logger.debug(`Event handled successfully: ${event.eventType}`, {\n          eventId: event.eventId,\n          handlerName: handler.name,\n        });\n      } catch (error) {\n        this.logger.error(`Event handler failed: ${event.eventType}`, {\n          eventId: event.eventId,\n          handlerName: handler.name,\n          error: error instanceof Error ? error.message : String(error),\n          stack: error instanceof Error ? error.stack : undefined,\n        });\n\n        // Re-throw to allow EventEmitter2 to handle retry logic\n        throw error;\n      }\n    };\n\n    if (options.async !== false) {\n      this.eventEmitter.on(eventType, (event: DomainEvent<T>) => {\n        void wrappedHandler(event);\n      });\n    } else {\n      // For synchronous handlers, we still use async but without await\n      this.eventEmitter.on(eventType, (event: DomainEvent<T>) => {\n        void wrappedHandler(event).catch((error) => {\n          this.logger.error(\n            `Async event handler error: ${event.eventType}`,\n            error,\n          );\n        });\n      });\n    }\n  }\n\n  unsubscribe(eventType: string, handler: (...args: any[]) => any): void {\n    this.logger.debug(`Unsubscribing from event: ${eventType}`, {\n      handlerName: handler.name,\n    });\n\n    this.eventEmitter.off(eventType, handler);\n  }\n\n  // Additional utility methods\n\n  /**\n   * Subscribe to all events of a specific aggregate type\n   */\n  subscribeToAggregate<T = any>(\n    aggregateType: string,\n    handler: (event: DomainEvent<T>) => Promise<void>,\n    options: EventHandlerOptions = {},\n  ): void {\n    const eventPattern = `${aggregateType}.*`;\n    this.subscribe(eventPattern, handler, options);\n  }\n\n  /**\n   * Subscribe to all events (wildcard subscription)\n   */\n  subscribeToAll<T = any>(\n    handler: (event: DomainEvent<T>) => Promise<void>,\n    options: EventHandlerOptions = {},\n  ): void {\n    this.subscribe('*', handler, options);\n  }\n\n  /**\n   * Get event statistics\n   */\n  getEventStats(): {\n    totalListeners: number;\n    eventTypes: string[];\n  } {\n    const eventNames = this.eventEmitter.eventNames();\n    return {\n      totalListeners: eventNames.reduce(\n        (total, eventName) =>\n          total + this.eventEmitter.listenerCount(eventName),\n        0,\n      ),\n      eventTypes: eventNames as string[],\n    };\n  }\n\n  /**\n   * Check if there are listeners for a specific event type\n   */\n  hasListeners(eventType: string): boolean {\n    return this.eventEmitter.listenerCount(eventType) > 0;\n  }\n\n  /**\n   * Remove all listeners for a specific event type\n   */\n  removeAllListeners(eventType?: string): void {\n    if (eventType) {\n      this.logger.debug(`Removing all listeners for event: ${eventType}`);\n      this.eventEmitter.removeAllListeners(eventType);\n    } else {\n      this.logger.debug('Removing all event listeners');\n      this.eventEmitter.removeAllListeners();\n    }\n  }\n}\n"],"version":3}