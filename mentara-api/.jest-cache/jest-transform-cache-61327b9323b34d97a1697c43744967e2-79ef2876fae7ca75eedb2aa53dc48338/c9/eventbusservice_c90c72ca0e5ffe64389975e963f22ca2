25ffedc1982278a78af935a27b80c04f
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var EventBusService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventBusService = void 0;
const common_1 = require("@nestjs/common");
const event_emitter_1 = require("@nestjs/event-emitter");
let EventBusService = EventBusService_1 = class EventBusService {
    eventEmitter;
    logger = new common_1.Logger(EventBusService_1.name);
    constructor(eventEmitter) {
        this.eventEmitter = eventEmitter;
    }
    async emit(event) {
        try {
            this.logger.debug(`Emitting event: ${event.eventType}`, {
                eventId: event.eventId,
                aggregateId: event.aggregateId,
                aggregateType: event.aggregateType,
                correlationId: event.metadata.correlationId,
            });
            // Emit the specific event type
            await this.eventEmitter.emitAsync(event.eventType, event);
            // Emit a wildcard event for global listeners
            await this.eventEmitter.emitAsync('*', event);
            // Emit aggregate-specific events for aggregate listeners
            await this.eventEmitter.emitAsync(`${event.aggregateType}.*`, event);
            this.logger.debug(`Event emitted successfully: ${event.eventType}`);
        }
        catch (error) {
            this.logger.error(`Failed to emit event: ${event.eventType}`, {
                eventId: event.eventId,
                error: error instanceof Error ? error.message : String(error),
                stack: error instanceof Error ? error.stack : undefined,
            });
            throw error;
        }
    }
    subscribe(eventType, handler, options = {}) {
        this.logger.debug(`Subscribing to event: ${eventType}`, {
            handlerName: handler.name,
            options,
        });
        const wrappedHandler = async (event) => {
            try {
                this.logger.debug(`Handling event: ${event.eventType}`, {
                    eventId: event.eventId,
                    handlerName: handler.name,
                });
                await handler(event);
                this.logger.debug(`Event handled successfully: ${event.eventType}`, {
                    eventId: event.eventId,
                    handlerName: handler.name,
                });
            }
            catch (error) {
                this.logger.error(`Event handler failed: ${event.eventType}`, {
                    eventId: event.eventId,
                    handlerName: handler.name,
                    error: error instanceof Error ? error.message : String(error),
                    stack: error instanceof Error ? error.stack : undefined,
                });
                // Re-throw to allow EventEmitter2 to handle retry logic
                throw error;
            }
        };
        if (options.async !== false) {
            this.eventEmitter.on(eventType, (event) => {
                void wrappedHandler(event);
            });
        }
        else {
            // For synchronous handlers, we still use async but without await
            this.eventEmitter.on(eventType, (event) => {
                void wrappedHandler(event).catch((error) => {
                    this.logger.error(`Async event handler error: ${event.eventType}`, error);
                });
            });
        }
    }
    unsubscribe(eventType, handler) {
        this.logger.debug(`Unsubscribing from event: ${eventType}`, {
            handlerName: handler.name,
        });
        this.eventEmitter.off(eventType, handler);
    }
    // Additional utility methods
    /**
     * Subscribe to all events of a specific aggregate type
     */
    subscribeToAggregate(aggregateType, handler, options = {}) {
        const eventPattern = `${aggregateType}.*`;
        this.subscribe(eventPattern, handler, options);
    }
    /**
     * Subscribe to all events (wildcard subscription)
     */
    subscribeToAll(handler, options = {}) {
        this.subscribe('*', handler, options);
    }
    /**
     * Get event statistics
     */
    getEventStats() {
        const eventNames = this.eventEmitter.eventNames();
        return {
            totalListeners: eventNames.reduce((total, eventName) => total + this.eventEmitter.listenerCount(eventName), 0),
            eventTypes: eventNames,
        };
    }
    /**
     * Check if there are listeners for a specific event type
     */
    hasListeners(eventType) {
        return this.eventEmitter.listenerCount(eventType) > 0;
    }
    /**
     * Remove all listeners for a specific event type
     */
    removeAllListeners(eventType) {
        if (eventType) {
            this.logger.debug(`Removing all listeners for event: ${eventType}`);
            this.eventEmitter.removeAllListeners(eventType);
        }
        else {
            this.logger.debug('Removing all event listeners');
            this.eventEmitter.removeAllListeners();
        }
    }
};
exports.EventBusService = EventBusService;
exports.EventBusService = EventBusService = EventBusService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [event_emitter_1.EventEmitter2])
], EventBusService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvd2V0b29hL0RvY3VtZW50cy9jb2RlL3Byb2plY3RzL21lbnRhcmEvbWVudGFyYS1hcGkvc3JjL2NvbW1vbi9ldmVudHMvZXZlbnQtYnVzLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBLDJDQUFvRDtBQUNwRCx5REFBc0Q7QUFRL0MsSUFBTSxlQUFlLHVCQUFyQixNQUFNLGVBQWU7SUFHRztJQUZaLE1BQU0sR0FBRyxJQUFJLGVBQU0sQ0FBQyxpQkFBZSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRTNELFlBQTZCLFlBQTJCO1FBQTNCLGlCQUFZLEdBQVosWUFBWSxDQUFlO0lBQUcsQ0FBQztJQUU1RCxLQUFLLENBQUMsSUFBSSxDQUFVLEtBQXFCO1FBQ3ZDLElBQUksQ0FBQztZQUNILElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLG1CQUFtQixLQUFLLENBQUMsU0FBUyxFQUFFLEVBQUU7Z0JBQ3RELE9BQU8sRUFBRSxLQUFLLENBQUMsT0FBTztnQkFDdEIsV0FBVyxFQUFFLEtBQUssQ0FBQyxXQUFXO2dCQUM5QixhQUFhLEVBQUUsS0FBSyxDQUFDLGFBQWE7Z0JBQ2xDLGFBQWEsRUFBRSxLQUFLLENBQUMsUUFBUSxDQUFDLGFBQWE7YUFDNUMsQ0FBQyxDQUFDO1lBRUgsK0JBQStCO1lBQy9CLE1BQU0sSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUUxRCw2Q0FBNkM7WUFDN0MsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFFOUMseURBQXlEO1lBQ3pELE1BQU0sSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsR0FBRyxLQUFLLENBQUMsYUFBYSxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFFckUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsK0JBQStCLEtBQUssQ0FBQyxTQUFTLEVB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QUFhLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFRDs7T0FFRztJQUNILGtCQUFrQixDQUFDLFNBQWtCO1FBQ25DLElBQUksU0FBUyxFQUFFLENBQUM7WUFDZCxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxxQ0FBcUMsU0FBUyxFQUFFLENBQUMsQ0FBQztZQUNwRSxJQUFJLENBQUMsWUFBWSxDQUFDLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2xELENBQUM7YUFBTSxDQUFDO1lBQ04sSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsOEJBQThCLENBQUMsQ0FBQztZQUNsRCxJQUFJLENBQUMsWUFBWSxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFDekMsQ0FBQztJQUNILENBQUM7Q0FDRixDQUFBO0FBNUpZLDBDQUFlOzBCQUFmLGVBQWU7SUFEM0IsSUFBQSxtQkFBVSxHQUFFO3FDQUlnQyw2QkFBYTtHQUg3QyxlQUFlLENBNEozQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvaG9tZS93ZXRvb2EvRG9jdW1lbnRzL2NvZGUvcHJvamVjdHMvbWVudGFyYS9tZW50YXJhLWFwaS9zcmMvY29tbW9uL2V2ZW50cy9ldmVudC1idXMuc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBMb2dnZXIgfSBmcm9tICdAbmVzdGpzL2NvbW1vbic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIyIH0gZnJvbSAnQG5lc3Rqcy9ldmVudC1lbWl0dGVyJztcbmltcG9ydCB7XG4gIERvbWFpbkV2ZW50LFxuICBJRXZlbnRCdXMsXG4gIEV2ZW50SGFuZGxlck9wdGlvbnMsXG59IGZyb20gJy4vaW50ZXJmYWNlcy9kb21haW4tZXZlbnQuaW50ZXJmYWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEV2ZW50QnVzU2VydmljZSBpbXBsZW1lbnRzIElFdmVudEJ1cyB7XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9nZ2VyID0gbmV3IExvZ2dlcihFdmVudEJ1c1NlcnZpY2UubmFtZSk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBldmVudEVtaXR0ZXI6IEV2ZW50RW1pdHRlcjIpIHt9XG5cbiAgYXN5bmMgZW1pdDxUID0gYW55PihldmVudDogRG9tYWluRXZlbnQ8VD4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEVtaXR0aW5nIGV2ZW50OiAke2V2ZW50LmV2ZW50VHlwZX1gLCB7XG4gICAgICAgIGV2ZW50SWQ6IGV2ZW50LmV2ZW50SWQsXG4gICAgICAgIGFnZ3JlZ2F0ZUlkOiBldmVudC5hZ2dyZWdhdGVJZCxcbiAgICAgICAgYWdncmVnYXRlVHlwZTogZXZlbnQuYWdncmVnYXRlVHlwZSxcbiAgICAgICAgY29ycmVsYXRpb25JZDogZXZlbnQubWV0YWRhdGEuY29ycmVsYXRpb25JZCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFbWl0IHRoZSBzcGVjaWZpYyBldmVudCB0eXBlXG4gICAgICBhd2FpdCB0aGlzLmV2ZW50RW1pdHRlci5lbWl0QXN5bmMoZXZlbnQuZXZlbnRUeXBlLCBldmVudCk7XG5cbiAgICAgIC8vIEVtaXQgYSB3aWxkY2FyZCBldmVudCBmb3IgZ2xvYmFsIGxpc3RlbmVyc1xuICAgICAgYXdhaXQgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdEFzeW5jKCcqJywgZXZlbnQpO1xuXG4gICAgICAvLyBFbWl0IGFnZ3JlZ2F0ZS1zcGVjaWZpYyBldmVudHMgZm9yIGFnZ3JlZ2F0ZSBsaXN0ZW5lcnNcbiAgICAgIGF3YWl0IHRoaXMuZXZlbnRFbWl0dGVyLmVtaXRBc3luYyhgJHtldmVudC5hZ2dyZWdhdGVUeXBlfS4qYCwgZXZlbnQpO1xuXG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgRXZlbnQgZW1pdHRlZCBzdWNjZXNzZnVsbHk6ICR7ZXZlbnQuZXZlbnRUeXBlfWApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGVtaXQgZXZlbnQ6ICR7ZXZlbnQuZXZlbnRUeXBlfWAsIHtcbiAgICAgICAgZXZlbnRJZDogZXZlbnQuZXZlbnRJZCxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgc3RhY2s6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5zdGFjayA6IHVuZGVmaW5lZCxcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgc3Vic2NyaWJlPFQgPSBhbnk+KFxuICAgIGV2ZW50VHlwZTogc3RyaW5nLFxuICAgIGhhbmRsZXI6IChldmVudDogRG9tYWluRXZlbnQ8VD4pID0+IFByb21pc2U8dm9pZD4sXG4gICAgb3B0aW9uczogRXZlbnRIYW5kbGVyT3B0aW9ucyA9IHt9LFxuICApOiB2b2lkIHtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgU3Vic2NyaWJpbmcgdG8gZXZlbnQ6ICR7ZXZlbnRUeXBlfWAsIHtcbiAgICAgIGhhbmRsZXJOYW1lOiBoYW5kbGVyLm5hbWUsXG4gICAgICBvcHRpb25zLFxuICAgIH0pO1xuXG4gICAgY29uc3Qgd3JhcHBlZEhhbmRsZXIgPSBhc3luYyAoZXZlbnQ6IERvbWFpbkV2ZW50PFQ+KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgSGFuZGxpbmcgZXZlbnQ6ICR7ZXZlbnQuZXZlbnRUeXBlfWAsIHtcbiAgICAgICAgICBldmVudElkOiBldmVudC5ldmVudElkLFxuICAgICAgICAgIGhhbmRsZXJOYW1lOiBoYW5kbGVyLm5hbWUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IGhhbmRsZXIoZXZlbnQpO1xuXG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBFdmVudCBoYW5kbGVkIHN1Y2Nlc3NmdWxseTogJHtldmVudC5ldmVudFR5cGV9YCwge1xuICAgICAgICAgIGV2ZW50SWQ6IGV2ZW50LmV2ZW50SWQsXG4gICAgICAgICAgaGFuZGxlck5hbWU6IGhhbmRsZXIubmFtZSxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRXZlbnQgaGFuZGxlciBmYWlsZWQ6ICR7ZXZlbnQuZXZlbnRUeXBlfWAsIHtcbiAgICAgICAgICBldmVudElkOiBldmVudC5ldmVudElkLFxuICAgICAgICAgIGhhbmRsZXJOYW1lOiBoYW5kbGVyLm5hbWUsXG4gICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgICBzdGFjazogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZS10aHJvdyB0byBhbGxvdyBFdmVudEVtaXR0ZXIyIHRvIGhhbmRsZSByZXRyeSBsb2dpY1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMuYXN5bmMgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmV2ZW50RW1pdHRlci5vbihldmVudFR5cGUsIChldmVudDogRG9tYWluRXZlbnQ8VD4pID0+IHtcbiAgICAgICAgdm9pZCB3cmFwcGVkSGFuZGxlcihldmVudCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIHN5bmNocm9ub3VzIGhhbmRsZXJzLCB3ZSBzdGlsbCB1c2UgYXN5bmMgYnV0IHdpdGhvdXQgYXdhaXRcbiAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLm9uKGV2ZW50VHlwZSwgKGV2ZW50OiBEb21haW5FdmVudDxUPikgPT4ge1xuICAgICAgICB2b2lkIHdyYXBwZWRIYW5kbGVyKGV2ZW50KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgIGBBc3luYyBldmVudCBoYW5kbGVyIGVycm9yOiAke2V2ZW50LmV2ZW50VHlwZX1gLFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB1bnN1YnNjcmliZShldmVudFR5cGU6IHN0cmluZywgaGFuZGxlcjogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgVW5zdWJzY3JpYmluZyBmcm9tIGV2ZW50OiAke2V2ZW50VHlwZX1gLCB7XG4gICAgICBoYW5kbGVyTmFtZTogaGFuZGxlci5uYW1lLFxuICAgIH0pO1xuXG4gICAgdGhpcy5ldmVudEVtaXR0ZXIub2ZmKGV2ZW50VHlwZSwgaGFuZGxlcik7XG4gIH1cblxuICAvLyBBZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gYWxsIGV2ZW50cyBvZiBhIHNwZWNpZmljIGFnZ3JlZ2F0ZSB0eXBlXG4gICAqL1xuICBzdWJzY3JpYmVUb0FnZ3JlZ2F0ZTxUID0gYW55PihcbiAgICBhZ2dyZWdhdGVUeXBlOiBzdHJpbmcsXG4gICAgaGFuZGxlcjogKGV2ZW50OiBEb21haW5FdmVudDxUPikgPT4gUHJvbWlzZTx2b2lkPixcbiAgICBvcHRpb25zOiBFdmVudEhhbmRsZXJPcHRpb25zID0ge30sXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGV2ZW50UGF0dGVybiA9IGAke2FnZ3JlZ2F0ZVR5cGV9LipgO1xuICAgIHRoaXMuc3Vic2NyaWJlKGV2ZW50UGF0dGVybiwgaGFuZGxlciwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIGFsbCBldmVudHMgKHdpbGRjYXJkIHN1YnNjcmlwdGlvbilcbiAgICovXG4gIHN1YnNjcmliZVRvQWxsPFQgPSBhbnk+KFxuICAgIGhhbmRsZXI6IChldmVudDogRG9tYWluRXZlbnQ8VD4pID0+IFByb21pc2U8dm9pZD4sXG4gICAgb3B0aW9uczogRXZlbnRIYW5kbGVyT3B0aW9ucyA9IHt9LFxuICApOiB2b2lkIHtcbiAgICB0aGlzLnN1YnNjcmliZSgnKicsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBldmVudCBzdGF0aXN0aWNzXG4gICAqL1xuICBnZXRFdmVudFN0YXRzKCk6IHtcbiAgICB0b3RhbExpc3RlbmVyczogbnVtYmVyO1xuICAgIGV2ZW50VHlwZXM6IHN0cmluZ1tdO1xuICB9IHtcbiAgICBjb25zdCBldmVudE5hbWVzID0gdGhpcy5ldmVudEVtaXR0ZXIuZXZlbnROYW1lcygpO1xuICAgIHJldHVybiB7XG4gICAgICB0b3RhbExpc3RlbmVyczogZXZlbnROYW1lcy5yZWR1Y2UoXG4gICAgICAgICh0b3RhbCwgZXZlbnROYW1lKSA9PlxuICAgICAgICAgIHRvdGFsICsgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudChldmVudE5hbWUpLFxuICAgICAgICAwLFxuICAgICAgKSxcbiAgICAgIGV2ZW50VHlwZXM6IGV2ZW50TmFtZXMgYXMgc3RyaW5nW10sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGVyZSBhcmUgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmljIGV2ZW50IHR5cGVcbiAgICovXG4gIGhhc0xpc3RlbmVycyhldmVudFR5cGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50KGV2ZW50VHlwZSkgPiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmljIGV2ZW50IHR5cGVcbiAgICovXG4gIHJlbW92ZUFsbExpc3RlbmVycyhldmVudFR5cGU/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoZXZlbnRUeXBlKSB7XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgUmVtb3ZpbmcgYWxsIGxpc3RlbmVycyBmb3IgZXZlbnQ6ICR7ZXZlbnRUeXBlfWApO1xuICAgICAgdGhpcy5ldmVudEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50VHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdSZW1vdmluZyBhbGwgZXZlbnQgbGlzdGVuZXJzJyk7XG4gICAgICB0aGlzLmV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG4gIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==