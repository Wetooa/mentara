{"file":"/home/wetooa/Documents/code/projects/mentara/mentara-api/src/auth/services/email-verification.service.ts","mappings":"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","names":[],"sources":["/home/wetooa/Documents/code/projects/mentara/mentara-api/src/auth/services/email-verification.service.ts"],"sourcesContent":["import { Injectable, BadRequestException } from '@nestjs/common';\nimport { PrismaService } from '../../providers/prisma-client.provider';\nimport { EmailService } from '../../email/email.service';\nimport * as crypto from 'crypto';\n\n@Injectable()\nexport class EmailVerificationService {\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly emailService: EmailService,\n  ) {}\n\n  /**\n   * Send verification email to user\n   * @param userId - User ID to send verification email to\n   */\n  async sendVerificationEmail(userId: string): Promise<void> {\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n    });\n\n    if (!user) {\n      throw new BadRequestException('User not found');\n    }\n\n    if (user.emailVerified) {\n      throw new BadRequestException('Email is already verified');\n    }\n\n    // Generate raw OTP code\n    const otpCode = this.emailService.generateOtp(6);\n    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours\n\n    // Store raw OTP in database\n    await this.prisma.user.update({\n      where: { id: userId },\n      data: {\n        emailVerifyToken: otpCode, // Store raw OTP instead of crypto token\n        emailVerifyTokenExp: expiresAt,\n      },\n    });\n\n    // Send the same OTP code via email\n    await this.emailService.sendOTP(\n      user.email,\n      user.firstName || 'User',\n      'Verify Your Mentara Email Address',\n      otpCode, // Pass the generated OTP code\n      '24 hours',\n    );\n  }\n\n  /**\n   * Verify email with verification token\n   * @param token - Verification token\n   * @returns Verification result\n   */\n  async verifyEmail(\n    token: string,\n  ): Promise<{ success: boolean; message: string }> {\n    const user = await this.prisma.user.findFirst({\n      where: {\n        emailVerifyToken: token, // Direct comparison with raw OTP\n        emailVerifyTokenExp: {\n          gt: new Date(),\n        },\n      },\n    });\n\n    if (!user) {\n      return {\n        success: false,\n        message: 'Invalid or expired verification token',\n      };\n    }\n\n    // Mark email as verified and clear token\n    await this.prisma.user.update({\n      where: { id: user.id },\n      data: {\n        emailVerified: true,\n        emailVerifyToken: null,\n        emailVerifyTokenExp: null,\n      },\n    });\n\n    return {\n      success: true,\n      message: 'Email verified successfully',\n    };\n  }\n\n  /**\n   * Resend verification email\n   * @param email - User email to resend verification to\n   */\n  async resendVerificationEmail(email: string): Promise<void> {\n    const user = await this.prisma.user.findUnique({\n      where: { email },\n    });\n\n    if (!user) {\n      throw new BadRequestException('User not found');\n    }\n\n    if (user.emailVerified) {\n      throw new BadRequestException('Email is already verified');\n    }\n\n    // Reuse the sendVerificationEmail method\n    await this.sendVerificationEmail(user.id);\n  }\n}\n"],"version":3}