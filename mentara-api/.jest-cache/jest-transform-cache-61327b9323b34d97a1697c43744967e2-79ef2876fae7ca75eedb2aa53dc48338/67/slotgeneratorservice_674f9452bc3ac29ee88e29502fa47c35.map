{"file":"/home/wetooa/Documents/code/projects/mentara/mentara-api/src/booking/services/slot-generator.service.ts","mappings":";;;;;;;;;;;;;AAAA,2CAAiE;AACjE,mFAAuE;AAkBhE,IAAM,oBAAoB,GAA1B,MAAM,oBAAoB;IAOF;IANZ,aAAa,GAAyB;QACrD,YAAY,EAAE,EAAE;QAChB,iBAAiB,EAAE,EAAE;QACrB,iBAAiB,EAAE,CAAC;KACrB,CAAC;IAEF,YAA6B,MAAqB;QAArB,WAAM,GAAN,MAAM,CAAe;IAAG,CAAC;IAE9C,YAAY;QAClB,OAAO;YACL,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,YAAY,EAAE,QAAQ,EAAE,EAAE,EAAE;YAC9C,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,YAAY,EAAE,QAAQ,EAAE,EAAE,EAAE;YAC9C,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,YAAY,EAAE,QAAQ,EAAE,EAAE,EAAE;YAC9C,EAAE,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,aAAa,EAAE,QAAQ,EAAE,GAAG,EAAE;SAClD,CAAC;IACJ,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,sBAAsB,CAC1B,WAAmB,EACnB,IAAY,EACZ,SAAwC,EAAE;QAE1C,MAAM,WAAW,GAAG,EAAE,GAAG,IAAI,CAAC,aAAa,EAAE,GAAG,MAAM,EAAE,CAAC;QACzD,MAAM,UAAU,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC;QAClC,MAAM,SAAS,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC;QAEtC,yCAAyC;QACzC,IAAI,CAAC,mBAAmB,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;QAElD,0CAA0C;QAC1C,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,wBAAwB,CACtD,WAAW,EACX,SAAS,CACV,CAAC;QACF,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC9B,OAAO,EAAE,CAAC;QACZ,CAAC;QAED,sCAAsC;QACtC,MAAM,gBAAgB,GAAG,MAAM,IAAI,CAAC,mBAAmB,CACrD,WAAW,EACX,UAAU,CACX,CAAC;QAEF,8CAA8C;QAC9C,MAAM,QAAQ,GAAe,EAAE,CAAC;QAChC,KAAK,MAAM,KAAK,IAAI,YAAY,EAAE,CAAC;YACjC,MAAM,KAAK,GAAG,IAAI,CAAC,kCAAkC,CACnD,UAAU,EACV,KAAK,EACL,gBAAgB,EAChB,WAAW,CACZ,CAAC;YACF,QAAQ,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,CAAC;QAC1B,CAAC;QAED,OAAO,QAAQ,CAAC,IAAI,CAClB,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CACP,IAAI,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,OAAO,EAAE,GAAG,IAAI,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,OAAO,EAAE,CACpE,CAAC;IACJ,CAAC;IAEO,mBAAmB,CAAC,IAAU,EAAE,MAA4B;QAClE,MAAM,GAAG,GAAG,IAAI,IAAI,EAAE,CAAC;QACvB,MAAM,OAAO,GAAG,IAAI,IAAI,CACtB,GAAG,CAAC,OAAO,EAAE,GAAG,MAAM,CAAC,iBAAiB,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAC/D,CAAC;QACF,MAAM,OAAO,GAAG,IAAI,IAAI,CACtB,GAAG,CAAC,OAAO,EAAE,GAAG,MAAM,CAAC,iBAAiB,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAC1D,CAAC;QAEF,IAAI,IAAI,GAAG,OAAO,EAAE,CAAC;YACnB,MAAM,IAAI,4BAAmB,CAC3B,kCAAkC,MAAM,CAAC,iBAAiB,mBAAmB,CAC9E,CAAC;QACJ,CAAC;QAED,IAAI,IAAI,GAAG,OAAO,EAAE,CAAC;YACnB,MAAM,IAAI,4BAAmB,CAC3B,mCAAmC,MAAM,CAAC,iBAAiB,kBAAkB,CAC9E,CAAC;QACJ,CAAC;IACH,CAAC;IAEO,KAAK,CAAC,wBAAwB,CACpC,WAAmB,EACnB,SAAiB;QAEjB,OAAO,IAAI,CAAC,MAAM,CAAC,qBAAqB,CAAC,QAAQ,CAAC;YAChD,KAAK,EAAE;gBACL,WAAW;gBACX,SAAS;gBACT,WAAW,EAAE,IAAI;aAClB;YACD,OAAO,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE;SAC9B,CAAC,CAAC;IACL,CAAC;IAEO,KAAK,CAAC,mBAAmB,CAAC,WAAmB,EAAE,IAAU;QAC/D,MAAM,UAAU,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC;QAClC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAChC,MAAM,QAAQ,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC;QAChC,QAAQ,CAAC,QAAQ,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,CAAC,CAAC;QAEnC,OAAO,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;YAClC,KAAK,EAAE;gBACL,WAAW;gBACX,SAAS,EAAE,EAAE,GAAG,EAAE,UAAU,EAAE,GAAG,EAAE,QAAQ,EAAE;gBAC7C,MAAM,EAAE,EAAE,EAAE,EAAE,CAAC,WAAW,EAAE,WAAW,CAAC,EAAE;aAC3C;YACD,OAAO,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE;SAC9B,CAAC,CAAC;IACL,CAAC;IAEO,kCAAkC,CACxC,IAAU,EACV,YAAiB,EACjB,gBAAuB,EACvB,MAA4B;QAE5B,MAAM,KAAK,GAAe,EAAE,CAAC;QAC7B,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QAEtC,MAAM,SAAS,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,YAAY,CAAC,SAAS,CAAC,CAAC;QACpE,MAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,YAAY,CAAC,OAAO,CAAC,CAAC;QAEhE,IAAI,WAAW,GAAG,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC;QAEtC,OAAO,WAAW,GAAG,OAAO,EAAE,CAAC;YAC7B,MAAM,OAAO,GAAG,IAAI,IAAI,CACtB,WAAW,CAAC,OAAO,EAAE,GAAG,MAAM,CAAC,YAAY,GAAG,KAAK,CACpD,CAAC;YAEF,IAAI,OAAO,IAAI,OAAO,EAAE,CAAC;gBACvB,sDAAsD;gBACtD,IACE,CAAC,IAAI,CAAC,uBAAuB,CAAC,WAAW,EAAE,OAAO,EAAE,gBAAgB,CAAC,EACrE,CAAC;oBACD,wCAAwC;oBACxC,MAAM,kBAAkB,GAAG,IAAI,CAAC,qBAAqB,CACnD,WAAW,EACX,OAAO,EACP,gBAAgB,EAChB,SAAS,CACV,CAAC;oBAEF,IAAI,kBAAkB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;wBAClC,KAAK,CAAC,IAAI,CAAC;4BACT,SAAS,EAAE,WAAW,CAAC,WAAW,EAAE;4BACpC,kBAAkB;yBACnB,CAAC,CAAC;oBACL,CAAC;gBACH,CAAC;YACH,CAAC;YAED,WAAW,GAAG,IAAI,IAAI,CACpB,WAAW,CAAC,OAAO,EAAE,GAAG,MAAM,CAAC,YAAY,GAAG,KAAK,CACpD,CAAC;QACJ,CAAC;QAED,OAAO,KAAK,CAAC;IACf,CAAC;IAEO,cAAc,CAAC,IAAU,EAAE,UAAkB;QACnD,MAAM,CAAC,KAAK,EAAE,OAAO,CAAC,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAC3D,MAAM,QAAQ,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC;QAChC,QAAQ,CAAC,QAAQ,CAAC,KAAK,EAAE,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QACxC,OAAO,QAAQ,CAAC;IAClB,CAAC;IAEO,uBAAuB,CAC7B,SAAe,EACf,OAAa,EACb,QAAe;QAEf,OAAO,QAAQ,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,EAAE;YAC/B,MAAM,UAAU,GAAG,IAAI,IAAI,CACzB,OAAO,CAAC,SAAS,CAAC,OAAO,EAAE,GAAG,OAAO,CAAC,QAAQ,GAAG,KAAK,CACvD,CAAC;YACF,OAAO,IAAI,CAAC,cAAc,CACxB,SAAS,EACT,OAAO,EACP,OAAO,CAAC,SAAS,EACjB,UAAU,CACX,CAAC;QACJ,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,qBAAqB,CAC3B,SAAe,EACf,eAAqB,EACrB,gBAAuB,EACvB,SAAgB;QAEhB,OAAO,SAAS,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,EAAE;YACnC,MAAM,WAAW,GAAG,IAAI,IAAI,CAC1B,SAAS,CAAC,OAAO,EAAE,GAAG,QAAQ,CAAC,QAAQ,GAAG,KAAK,CAChD,CAAC;YAEF,oDAAoD;YACpD,IAAI,WAAW,GAAG,eAAe,EAAE,CAAC;gBAClC,OAAO,KAAK,CAAC;YACf,CAAC;YAED,qDAAqD;YACrD,OAAO,CAAC,IAAI,CAAC,uBAAuB,CAClC,SAAS,EACT,WAAW,EACX,gBAAgB,CACjB,CAAC;QACJ,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,cAAc,CACpB,MAAY,EACZ,IAAU,EACV,MAAY,EACZ,IAAU;QAEV,OAAO,MAAM,GAAG,IAAI,IAAI,IAAI,GAAG,MAAM,CAAC;IACxC,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,eAAe,CACnB,WAAmB,EACnB,SAAe,EACf,QAAgB;QAEhB,MAAM,OAAO,GAAG,IAAI,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,GAAG,QAAQ,GAAG,KAAK,CAAC,CAAC;QACjE,MAAM,SAAS,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC;QAErC,+BAA+B;QAC/B,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,qBAAqB,CAAC,SAAS,CAAC;YACrE,KAAK,EAAE;gBACL,WAAW;gBACX,SAAS;gBACT,WAAW,EAAE,IAAI;aAClB;SACF,CAAC,CAAC;QAEH,IAAI,CAAC,YAAY,EAAE,CAAC;YAClB,OAAO,KAAK,CAAC;QACf,CAAC;QAED,gDAAgD;QAChD,MAAM,UAAU,GAAG,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,YAAY,CAAC,SAAS,CAAC,CAAC;QAC1E,MAAM,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,YAAY,CAAC,OAAO,CAAC,CAAC;QAEtE,IAAI,SAAS,GAAG,UAAU,IAAI,OAAO,GAAG,QAAQ,EAAE,CAAC;YACjD,OAAO,KAAK,CAAC;QACf,CAAC;QAED,6CAA6C;QAC7C,MAAM,gBAAgB,GAAG,MAAM,IAAI,CAAC,mBAAmB,CACrD,WAAW,EACX,SAAS,CACV,CAAC;QAEF,OAAO,CAAC,IAAI,CAAC,uBAAuB,CAAC,SAAS,EAAE,OAAO,EAAE,gBAAgB,CAAC,CAAC;IAC7E,CAAC;CACF,CAAA;AA1QY,oDAAoB;+BAApB,oBAAoB;IADhC,IAAA,mBAAU,GAAE;yDAQ0B,sCAAa,oBAAb,sCAAa;GAPvC,oBAAoB,CA0QhC","names":[],"sources":["/home/wetooa/Documents/code/projects/mentara/mentara-api/src/booking/services/slot-generator.service.ts"],"sourcesContent":["import { Injectable, BadRequestException } from '@nestjs/common';\nimport { PrismaService } from '../../providers/prisma-client.provider';\n\nexport interface TimeSlot {\n  startTime: string;\n  availableDurations: {\n    id: string;\n    name: string;\n    duration: number;\n  }[];\n}\n\nexport interface SlotGenerationConfig {\n  slotInterval: number; // minutes\n  maxAdvanceBooking: number; // days\n  minAdvanceBooking: number; // hours\n}\n\n@Injectable()\nexport class SlotGeneratorService {\n  private readonly defaultConfig: SlotGenerationConfig = {\n    slotInterval: 30,\n    maxAdvanceBooking: 90,\n    minAdvanceBooking: 2,\n  };\n\n  constructor(private readonly prisma: PrismaService) {}\n\n  private getDurations() {\n    return [\n      { id: '30', name: '30 minutes', duration: 30 },\n      { id: '60', name: '60 minutes', duration: 60 },\n      { id: '90', name: '90 minutes', duration: 90 },\n      { id: '120', name: '120 minutes', duration: 120 },\n    ];\n  }\n\n  /**\n   * Generate available time slots for a therapist on a specific date\n   */\n  async generateAvailableSlots(\n    therapistId: string,\n    date: string,\n    config: Partial<SlotGenerationConfig> = {},\n  ): Promise<TimeSlot[]> {\n    const finalConfig = { ...this.defaultConfig, ...config };\n    const targetDate = new Date(date);\n    const dayOfWeek = targetDate.getDay();\n\n    // Validate date is within booking window\n    this.validateBookingDate(targetDate, finalConfig);\n\n    // Get therapist availability for this day\n    const availability = await this.getTherapistAvailability(\n      therapistId,\n      dayOfWeek,\n    );\n    if (availability.length === 0) {\n      return [];\n    }\n\n    // Get existing bookings for this date\n    const existingBookings = await this.getExistingBookings(\n      therapistId,\n      targetDate,\n    );\n\n    // Generate slots for each availability window\n    const allSlots: TimeSlot[] = [];\n    for (const avail of availability) {\n      const slots = this.generateSlotsForAvailabilityWindow(\n        targetDate,\n        avail,\n        existingBookings,\n        finalConfig,\n      );\n      allSlots.push(...slots);\n    }\n\n    return allSlots.sort(\n      (a, b) =>\n        new Date(a.startTime).getTime() - new Date(b.startTime).getTime(),\n    );\n  }\n\n  private validateBookingDate(date: Date, config: SlotGenerationConfig): void {\n    const now = new Date();\n    const maxDate = new Date(\n      now.getTime() + config.maxAdvanceBooking * 24 * 60 * 60 * 1000,\n    );\n    const minDate = new Date(\n      now.getTime() + config.minAdvanceBooking * 60 * 60 * 1000,\n    );\n\n    if (date < minDate) {\n      throw new BadRequestException(\n        `Bookings must be made at least ${config.minAdvanceBooking} hours in advance`,\n      );\n    }\n\n    if (date > maxDate) {\n      throw new BadRequestException(\n        `Bookings can only be made up to ${config.maxAdvanceBooking} days in advance`,\n      );\n    }\n  }\n\n  private async getTherapistAvailability(\n    therapistId: string,\n    dayOfWeek: number,\n  ) {\n    return this.prisma.therapistAvailability.findMany({\n      where: {\n        therapistId,\n        dayOfWeek,\n        isAvailable: true,\n      },\n      orderBy: { startTime: 'asc' },\n    });\n  }\n\n  private async getExistingBookings(therapistId: string, date: Date) {\n    const startOfDay = new Date(date);\n    startOfDay.setHours(0, 0, 0, 0);\n    const endOfDay = new Date(date);\n    endOfDay.setHours(23, 59, 59, 999);\n\n    return this.prisma.meeting.findMany({\n      where: {\n        therapistId,\n        startTime: { gte: startOfDay, lte: endOfDay },\n        status: { in: ['SCHEDULED', 'CONFIRMED'] },\n      },\n      orderBy: { startTime: 'asc' },\n    });\n  }\n\n  private generateSlotsForAvailabilityWindow(\n    date: Date,\n    availability: any,\n    existingBookings: any[],\n    config: SlotGenerationConfig,\n  ): TimeSlot[] {\n    const slots: TimeSlot[] = [];\n    const durations = this.getDurations();\n\n    const startTime = this.createDateTime(date, availability.startTime);\n    const endTime = this.createDateTime(date, availability.endTime);\n\n    let currentTime = new Date(startTime);\n\n    while (currentTime < endTime) {\n      const slotEnd = new Date(\n        currentTime.getTime() + config.slotInterval * 60000,\n      );\n\n      if (slotEnd <= endTime) {\n        // Check if this slot conflicts with existing bookings\n        if (\n          !this.hasConflictWithBookings(currentTime, slotEnd, existingBookings)\n        ) {\n          // Find which durations fit in this slot\n          const availableDurations = this.getAvailableDurations(\n            currentTime,\n            endTime,\n            existingBookings,\n            durations,\n          );\n\n          if (availableDurations.length > 0) {\n            slots.push({\n              startTime: currentTime.toISOString(),\n              availableDurations,\n            });\n          }\n        }\n      }\n\n      currentTime = new Date(\n        currentTime.getTime() + config.slotInterval * 60000,\n      );\n    }\n\n    return slots;\n  }\n\n  private createDateTime(date: Date, timeString: string): Date {\n    const [hours, minutes] = timeString.split(':').map(Number);\n    const dateTime = new Date(date);\n    dateTime.setHours(hours, minutes, 0, 0);\n    return dateTime;\n  }\n\n  private hasConflictWithBookings(\n    slotStart: Date,\n    slotEnd: Date,\n    bookings: any[],\n  ): boolean {\n    return bookings.some((booking) => {\n      const bookingEnd = new Date(\n        booking.startTime.getTime() + booking.duration * 60000,\n      );\n      return this.hasTimeOverlap(\n        slotStart,\n        slotEnd,\n        booking.startTime,\n        bookingEnd,\n      );\n    });\n  }\n\n  private getAvailableDurations(\n    slotStart: Date,\n    availabilityEnd: Date,\n    existingBookings: any[],\n    durations: any[],\n  ) {\n    return durations.filter((duration) => {\n      const durationEnd = new Date(\n        slotStart.getTime() + duration.duration * 60000,\n      );\n\n      // Check if duration fits within availability window\n      if (durationEnd > availabilityEnd) {\n        return false;\n      }\n\n      // Check if duration conflicts with existing bookings\n      return !this.hasConflictWithBookings(\n        slotStart,\n        durationEnd,\n        existingBookings,\n      );\n    });\n  }\n\n  private hasTimeOverlap(\n    start1: Date,\n    end1: Date,\n    start2: Date,\n    end2: Date,\n  ): boolean {\n    return start1 < end2 && end1 > start2;\n  }\n\n  /**\n   * Check if a specific time slot is available\n   */\n  async isSlotAvailable(\n    therapistId: string,\n    startTime: Date,\n    duration: number,\n  ): Promise<boolean> {\n    const endTime = new Date(startTime.getTime() + duration * 60000);\n    const dayOfWeek = startTime.getDay();\n\n    // Check therapist availability\n    const availability = await this.prisma.therapistAvailability.findFirst({\n      where: {\n        therapistId,\n        dayOfWeek,\n        isAvailable: true,\n      },\n    });\n\n    if (!availability) {\n      return false;\n    }\n\n    // Check if time fits within availability window\n    const availStart = this.createDateTime(startTime, availability.startTime);\n    const availEnd = this.createDateTime(startTime, availability.endTime);\n\n    if (startTime < availStart || endTime > availEnd) {\n      return false;\n    }\n\n    // Check for conflicts with existing bookings\n    const existingBookings = await this.getExistingBookings(\n      therapistId,\n      startTime,\n    );\n\n    return !this.hasConflictWithBookings(startTime, endTime, existingBookings);\n  }\n}\n"],"version":3}