{"file":"/home/wetooa/Documents/code/projects/mentara/mentara-api/src/client/services/client-request.service.ts","mappings":"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","names":[],"sources":["/home/wetooa/Documents/code/projects/mentara/mentara-api/src/client/services/client-request.service.ts"],"sourcesContent":["import {\n  Injectable,\n  Logger,\n  NotFoundException,\n  ConflictException,\n  BadRequestException,\n  ForbiddenException,\n} from '@nestjs/common';\nimport { PrismaService } from '../../providers/prisma-client.provider';\nimport { NotificationsService } from '../../notifications/notifications.service';\nimport { Prisma } from '@prisma/client';\nimport {\n  type SendTherapistRequestDto,\n  type ClientRequestFiltersDto,\n  type CancelClientRequestDto,\n} from 'mentara-commons';\n\n@Injectable()\nexport class ClientRequestService {\n  private readonly logger = new Logger(ClientRequestService.name);\n\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly notificationsService: NotificationsService,\n  ) {}\n\n  // ===== SENDING THERAPIST REQUESTS =====\n\n  async sendTherapistRequest(\n    clientId: string,\n    therapistId: string,\n    requestDto: SendTherapistRequestDto,\n  ) {\n    try {\n      return await this.prisma.$transaction(async (tx) => {\n        // 1. Verify client exists and is active\n        const client = await tx.client.findUnique({\n          where: { userId: clientId },\n          include: { user: true },\n        });\n\n        if (!client) {\n          throw new NotFoundException(`Client with ID ${clientId} not found`);\n        }\n\n        if (!client.user.isActive) {\n          throw new ForbiddenException('Client account is not active');\n        }\n\n        // 2. Verify therapist exists and is approved\n        const therapist = await tx.therapist.findUnique({\n          where: { userId: therapistId },\n          include: { user: true },\n        });\n\n        if (!therapist) {\n          throw new NotFoundException(\n            `Therapist with ID ${therapistId} not found`,\n          );\n        }\n\n        if (therapist.status !== 'approved') {\n          throw new BadRequestException(\n            'Cannot send request to unapproved therapist',\n          );\n        }\n\n        if (!therapist.user.isActive) {\n          throw new BadRequestException('Therapist is not currently active');\n        }\n\n        // 3. Check for existing active requests\n        const existingRequest = await tx.clientTherapistRequest.findFirst({\n          where: {\n            clientId,\n            therapistId,\n            status: { in: ['PENDING', 'ACCEPTED'] },\n          },\n        });\n\n        if (existingRequest) {\n          throw new ConflictException(\n            `An active request already exists between client ${clientId} and therapist ${therapistId}`,\n          );\n        }\n\n        // 4. Check for existing client-therapist relationship\n        const existingRelationship = await tx.clientTherapist.findFirst({\n          where: {\n            clientId,\n            therapistId,\n            status: 'active',\n          },\n        });\n\n        if (existingRelationship) {\n          throw new ConflictException(\n            'Client already has an active relationship with this therapist',\n          );\n        }\n\n        // 5. Create the request with auto-expiry (7 days)\n        const expiryDate = new Date();\n        expiryDate.setDate(expiryDate.getDate() + 7);\n\n        const request = await tx.clientTherapistRequest.create({\n          data: {\n            clientId,\n            therapistId,\n            status: 'PENDING',\n            priority: requestDto.priority || 'NORMAL',\n            clientMessage: requestDto.message,\n            recommendationRank: requestDto.recommendationRank,\n            matchScore: requestDto.matchScore,\n            expiresAt: expiryDate,\n          },\n          include: {\n            client: {\n              include: {\n                user: {\n                  select: {\n                    firstName: true,\n                    lastName: true,\n                    avatarUrl: true,\n                  },\n                },\n              },\n            },\n            therapist: {\n              include: {\n                user: {\n                  select: {\n                    firstName: true,\n                    lastName: true,\n                    avatarUrl: true,\n                  },\n                },\n              },\n            },\n          },\n        });\n\n        // 6. Send notification to therapist\n        await this.notificationsService.create({\n          userId: therapistId,\n          title: 'New Client Request',\n          message: `${client.user.firstName} ${client.user.lastName} has sent you a therapy request.`,\n          type: 'CLIENT_REQUEST_RECEIVED',\n          priority:\n            requestDto.priority === 'HIGH' || requestDto.priority === 'URGENT'\n              ? 'HIGH'\n              : 'NORMAL',\n          actionUrl: `/therapist/requests/${request.id}`,\n          data: {\n            requestId: request.id,\n            clientId,\n            clientName: `${client.user.firstName} ${client.user.lastName}`,\n          },\n        });\n\n        // 7. Create audit log\n        await tx.auditLog.create({\n          data: {\n            userId: clientId,\n            action: 'SEND_THERAPIST_REQUEST',\n            entity: 'client_therapist_request',\n            entityId: request.id,\n            metadata: {\n              clientId,\n              therapistId,\n              priority: requestDto.priority,\n              hasMessage: !!requestDto.message,\n              recommendationRank: requestDto.recommendationRank,\n              timestamp: new Date().toISOString(),\n            },\n          },\n        });\n\n        this.logger.log(\n          `Client ${clientId} sent request to therapist ${therapistId} with priority ${requestDto.priority}`,\n        );\n\n        return {\n          success: true,\n          request,\n          message: 'Therapist request sent successfully',\n          expiresAt: expiryDate,\n        };\n      });\n    } catch (error) {\n      this.logger.error(\n        `Failed to send therapist request from ${clientId} to ${therapistId}:`,\n        error,\n      );\n      throw error;\n    }\n  }\n\n  async sendMultipleTherapistRequests(\n    clientId: string,\n    requestData: {\n      therapistIds: string[];\n      message?: string;\n      priority?: string;\n    },\n  ) {\n    try {\n      const { therapistIds, message, priority = 'NORMAL' } = requestData;\n\n      // Validate therapist IDs limit\n      if (therapistIds.length > 10) {\n        throw new BadRequestException(\n          'Cannot send requests to more than 10 therapists at once',\n        );\n      }\n\n      const results: {\n        successful: Array<{\n          therapistId: string;\n          requestId: string;\n          status: string;\n        }>;\n        failed: Array<{ therapistId: string; error: string }>;\n        totalSent: number;\n      } = {\n        successful: [],\n        failed: [],\n        totalSent: 0,\n      };\n\n      // Process requests in parallel with controlled concurrency (max 3 concurrent)\n      // This avoids database lock contention while maintaining good performance\n      const concurrencyLimit = 3;\n      const chunks = this.chunkArray(therapistIds, concurrencyLimit);\n\n      for (const chunk of chunks) {\n        const chunkPromises = chunk.map(async (therapistId) => {\n          try {\n            const result = await this.sendTherapistRequest(\n              clientId,\n              therapistId,\n              {\n                message,\n                priority: priority as 'LOW' | 'NORMAL' | 'HIGH' | 'URGENT',\n              },\n            );\n\n            return {\n              success: true,\n              therapistId,\n              requestId: result.request.id,\n            };\n          } catch (error) {\n            this.logger.warn(\n              `Failed to send request to therapist ${therapistId}`,\n              {\n                error: error instanceof Error ? error.message : String(error),\n                clientId,\n                therapistId,\n              },\n            );\n\n            return {\n              success: false,\n              therapistId,\n              error: error instanceof Error ? error.message : 'Unknown error',\n            };\n          }\n        });\n\n        // Wait for all requests in this chunk to complete\n        const chunkResults = await Promise.all(chunkPromises);\n\n        // Process results\n        chunkResults.forEach((result) => {\n          if (result.success) {\n            results.successful.push({\n              therapistId: result.therapistId,\n              requestId: result.requestId!,\n              status: 'sent',\n            });\n            results.totalSent++;\n          } else {\n            results.failed.push({\n              therapistId: result.therapistId,\n              error: result.error!,\n            });\n          }\n        });\n\n        // Add small delay between chunks to prevent overwhelming the database\n        if (chunks.indexOf(chunk) < chunks.length - 1) {\n          await new Promise((resolve) => setTimeout(resolve, 100));\n        }\n      }\n\n      this.logger.log(\n        `Client ${clientId} sent bulk requests: ${results.totalSent} successful, ${results.failed.length} failed`,\n      );\n\n      return {\n        success: true,\n        results,\n        summary: {\n          totalRequested: therapistIds.length,\n          totalSent: results.totalSent,\n          totalFailed: results.failed.length,\n        },\n      };\n    } catch (error) {\n      this.logger.error(\n        `Failed to send multiple therapist requests for client ${clientId}:`,\n        error,\n      );\n      throw error;\n    }\n  }\n\n  // ===== RETRIEVING CLIENT REQUESTS =====\n\n  async getClientRequests(clientId: string, filters: ClientRequestFiltersDto) {\n    try {\n      const {\n        status,\n        priority,\n        therapistId,\n        requestedAfter,\n        requestedBefore,\n        page = 1,\n        limit = 20,\n        sortBy = 'requestedAt',\n        sortOrder = 'desc',\n      } = filters;\n\n      const skip = (page - 1) * limit;\n      const where: Prisma.ClientTherapistRequestWhereInput = {\n        clientId,\n      };\n\n      // Apply filters\n      if (status) where.status = status;\n      if (priority) where.priority = priority;\n      if (therapistId) where.therapistId = therapistId;\n      if (requestedAfter || requestedBefore) {\n        const requestedAtFilter: any = {};\n        if (requestedAfter) requestedAtFilter.gte = new Date(requestedAfter);\n        if (requestedBefore) requestedAtFilter.lte = new Date(requestedBefore);\n        where.requestedAt = requestedAtFilter;\n      }\n\n      const [requests, totalCount] = await Promise.all([\n        this.prisma.clientTherapistRequest.findMany({\n          where,\n          skip,\n          take: limit,\n          orderBy: { [sortBy]: sortOrder },\n          include: {\n            therapist: {\n              include: {\n                user: {\n                  select: {\n                    firstName: true,\n                    lastName: true,\n                    avatarUrl: true,\n                  },\n                },\n              },\n            },\n          },\n        }),\n        this.prisma.clientTherapistRequest.count({ where }),\n      ]);\n\n      this.logger.log(\n        `Retrieved ${requests.length} requests for client ${clientId}`,\n      );\n\n      return {\n        requests,\n        pagination: {\n          page,\n          limit,\n          totalCount,\n          totalPages: Math.ceil(totalCount / limit),\n        },\n        filters,\n      };\n    } catch (error) {\n      this.logger.error(\n        `Failed to retrieve requests for client ${clientId}:`,\n        error,\n      );\n      throw error;\n    }\n  }\n\n  // ===== REQUEST MANAGEMENT =====\n\n  async cancelRequest(requestId: string, clientId: string, reason?: string) {\n    try {\n      return await this.prisma.$transaction(async (tx) => {\n        // 1. Verify request exists and belongs to client\n        const existingRequest = await tx.clientTherapistRequest.findUnique({\n          where: { id: requestId },\n          include: {\n            therapist: {\n              include: {\n                user: {\n                  select: {\n                    firstName: true,\n                    lastName: true,\n                  },\n                },\n              },\n            },\n          },\n        });\n\n        if (!existingRequest) {\n          throw new NotFoundException(`Request with ID ${requestId} not found`);\n        }\n\n        if (existingRequest.clientId !== clientId) {\n          throw new ForbiddenException('You can only cancel your own requests');\n        }\n\n        if (existingRequest.status !== 'PENDING') {\n          throw new BadRequestException(\n            `Cannot cancel request with status ${existingRequest.status}`,\n          );\n        }\n\n        // 2. Update request status to cancelled\n        const cancelledRequest = await tx.clientTherapistRequest.update({\n          where: { id: requestId },\n          data: {\n            status: 'CANCELLED',\n            respondedAt: new Date(),\n          },\n        });\n\n        // 3. Notify therapist of cancellation\n        await this.notificationsService.create({\n          userId: existingRequest.therapistId,\n          title: 'Client Request Cancelled',\n          message: `A client request has been cancelled.${reason ? ` Reason: ${reason}` : ''}`,\n          type: 'CLIENT_REQUEST_CANCELLED',\n          priority: 'NORMAL',\n          actionUrl: '/therapist/requests',\n        });\n\n        // 4. Create audit log\n        await tx.auditLog.create({\n          data: {\n            userId: clientId,\n            action: 'CANCEL_THERAPIST_REQUEST',\n            entity: 'client_therapist_request',\n            entityId: requestId,\n            metadata: {\n              requestId,\n              therapistId: existingRequest.therapistId,\n              reason,\n              timestamp: new Date().toISOString(),\n            },\n          },\n        });\n\n        this.logger.log(`Client ${clientId} cancelled request ${requestId}`);\n\n        return {\n          success: true,\n          request: cancelledRequest,\n          message: 'Request cancelled successfully',\n        };\n      });\n    } catch (error) {\n      this.logger.error(\n        `Failed to cancel request ${requestId} for client ${clientId}:`,\n        error,\n      );\n      throw error;\n    }\n  }\n\n  // ===== STATISTICS AND ANALYTICS =====\n\n  async getClientRequestStatistics(clientId: string) {\n    try {\n      const [\n        totalSent,\n        pending,\n        accepted,\n        declined,\n        expired,\n        cancelled,\n        recentRequests,\n      ] = await Promise.all([\n        // Total requests sent\n        this.prisma.clientTherapistRequest.count({\n          where: { clientId },\n        }),\n        // Pending requests\n        this.prisma.clientTherapistRequest.count({\n          where: { clientId, status: 'PENDING' },\n        }),\n        // Accepted requests\n        this.prisma.clientTherapistRequest.count({\n          where: { clientId, status: 'ACCEPTED' },\n        }),\n        // Declined requests\n        this.prisma.clientTherapistRequest.count({\n          where: { clientId, status: 'DECLINED' },\n        }),\n        // Expired requests\n        this.prisma.clientTherapistRequest.count({\n          where: { clientId, status: 'EXPIRED' },\n        }),\n        // Cancelled requests\n        this.prisma.clientTherapistRequest.count({\n          where: { clientId, status: 'CANCELLED' },\n        }),\n        // Recent requests for response time calculation\n        this.prisma.clientTherapistRequest.findMany({\n          where: {\n            clientId,\n            respondedAt: { not: null },\n          },\n          select: {\n            requestedAt: true,\n            respondedAt: true,\n          },\n          orderBy: { respondedAt: 'desc' },\n          take: 10,\n        }),\n      ]);\n\n      // Calculate acceptance rate\n      const totalResponded = accepted + declined;\n      const acceptanceRate =\n        totalResponded > 0 ? (accepted / totalResponded) * 100 : 0;\n\n      // Calculate average response time\n      const responseTimes = recentRequests\n        .filter((req) => req.respondedAt)\n        .map((req) => {\n          const responseTime =\n            req.respondedAt!.getTime() - req.requestedAt.getTime();\n          return responseTime / (1000 * 60 * 60); // Convert to hours\n        });\n\n      const averageResponseTime =\n        responseTimes.length > 0\n          ? responseTimes.reduce((sum, time) => sum + time, 0) /\n            responseTimes.length\n          : 0;\n\n      // Get last request and response dates\n      const lastRequest = await this.prisma.clientTherapistRequest.findFirst({\n        where: { clientId },\n        orderBy: { requestedAt: 'desc' },\n        select: { requestedAt: true },\n      });\n\n      const lastResponse = await this.prisma.clientTherapistRequest.findFirst({\n        where: { clientId, respondedAt: { not: null } },\n        orderBy: { respondedAt: 'desc' },\n        select: { respondedAt: true },\n      });\n\n      this.logger.log(`Generated request statistics for client ${clientId}`);\n\n      return {\n        totalSent,\n        pending,\n        accepted,\n        declined,\n        expired,\n        cancelled,\n        acceptanceRate: Math.round(acceptanceRate * 100) / 100,\n        averageResponseTime: Math.round(averageResponseTime * 100) / 100,\n        lastRequestAt: lastRequest?.requestedAt || null,\n        lastResponseAt: lastResponse?.respondedAt || null,\n      };\n    } catch (error) {\n      this.logger.error(\n        `Failed to generate statistics for client ${clientId}:`,\n        error,\n      );\n      throw error;\n    }\n  }\n\n  // ===== UTILITY METHODS =====\n\n  async expireStaleRequests() {\n    try {\n      const now = new Date();\n\n      const expiredRequests =\n        await this.prisma.clientTherapistRequest.updateMany({\n          where: {\n            status: 'PENDING',\n            expiresAt: { lte: now },\n          },\n          data: {\n            status: 'EXPIRED',\n            respondedAt: now,\n          },\n        });\n\n      this.logger.log(`Expired ${expiredRequests.count} stale requests`);\n\n      return {\n        success: true,\n        expiredCount: expiredRequests.count,\n      };\n    } catch (error) {\n      this.logger.error('Failed to expire stale requests:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Helper method to split array into chunks for controlled parallel processing\n   */\n  private chunkArray<T>(array: T[], chunkSize: number): T[][] {\n    const chunks: T[][] = [];\n    for (let i = 0; i < array.length; i += chunkSize) {\n      chunks.push(array.slice(i, i + chunkSize));\n    }\n    return chunks;\n  }\n}\n"],"version":3}