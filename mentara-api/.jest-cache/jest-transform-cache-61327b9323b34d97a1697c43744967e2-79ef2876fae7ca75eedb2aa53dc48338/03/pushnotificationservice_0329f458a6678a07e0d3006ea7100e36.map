{"file":"/home/wetooa/Documents/code/projects/mentara/mentara-api/src/notifications/services/push-notification.service.ts","mappings":"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","names":[],"sources":["/home/wetooa/Documents/code/projects/mentara/mentara-api/src/notifications/services/push-notification.service.ts"],"sourcesContent":["import { Injectable, Logger, OnModuleInit } from '@nestjs/common';\nimport { PrismaService } from '../../providers/prisma-client.provider';\nimport { EventEmitter2 } from '@nestjs/event-emitter';\nimport { ConfigService } from '@nestjs/config';\nimport { NotificationType, NotificationPriority } from '@prisma/client';\n\ninterface PushNotificationPayload {\n  userId: string;\n  title: string;\n  body: string;\n  type: NotificationType;\n  priority: NotificationPriority;\n  data?: { [key: string]: string };\n  actionUrl?: string;\n  imageUrl?: string;\n  sound?: string;\n  badge?: number;\n}\n\ninterface DeviceToken {\n  id: string;\n  userId: string;\n  token: string;\n  platform: 'ios' | 'android' | 'web';\n  isActive: boolean;\n  lastUsedAt: Date;\n  deviceInfo?: {\n    model?: string;\n    os?: string;\n    appVersion?: string;\n    pushEnabled?: boolean;\n  };\n}\n\ninterface BatchPushResult {\n  successful: number;\n  failed: number;\n  invalidTokens: string[];\n  results: {\n    token: string;\n    success: boolean;\n    error?: string;\n  }[];\n}\n\n@Injectable()\nexport class PushNotificationService implements OnModuleInit {\n  private readonly logger = new Logger(PushNotificationService.name);\n  private isInitialized = false;\n\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly eventEmitter: EventEmitter2,\n    private readonly configService: ConfigService,\n  ) {}\n\n  async onModuleInit() {\n    // Using WebSocket-based real-time notifications instead of push notifications\n    // This service handles device token management for potential future push notification integration\n    this.isInitialized = true;\n    this.logger.log(\n      'Push notification service initialized (WebSocket-based notifications)',\n    );\n  }\n\n  async registerDeviceToken(\n    userId: string,\n    token: string,\n    platform: 'ios' | 'android' | 'web',\n    deviceInfo?: {\n      model?: string;\n      os?: string;\n      appVersion?: string;\n      pushEnabled?: boolean;\n    },\n  ): Promise<void> {\n    try {\n      // Convert lowercase platform to uppercase for Prisma enum\n      const prismaPlatform = platform.toUpperCase() as\n        | 'IOS'\n        | 'ANDROID'\n        | 'WEB';\n\n      // Check if token already exists\n      const existingToken = await this.prisma.deviceToken.findFirst({\n        where: { token },\n      });\n\n      if (existingToken) {\n        // Update existing token\n        await this.prisma.deviceToken.update({\n          where: { id: existingToken.id },\n          data: {\n            userId,\n            platform: prismaPlatform,\n            isActive: true,\n            lastUsedAt: new Date(),\n            deviceInfo,\n          },\n        });\n      } else {\n        // Create new token\n        await this.prisma.deviceToken.create({\n          data: {\n            userId,\n            token,\n            platform: prismaPlatform,\n            isActive: true,\n            lastUsedAt: new Date(),\n            deviceInfo,\n          },\n        });\n      }\n\n      this.logger.log(\n        `Device token registered for user ${userId} on ${platform}`,\n      );\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : 'Unknown error';\n      this.logger.error(`Failed to register device token: ${errorMessage}`);\n      throw error;\n    }\n  }\n\n  async unregisterDeviceToken(token: string): Promise<void> {\n    try {\n      await this.prisma.deviceToken.updateMany({\n        where: { token },\n        data: { isActive: false },\n      });\n\n      this.logger.log(`Device token unregistered: ${token}`);\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : 'Unknown error';\n      this.logger.error(`Failed to unregister device token: ${errorMessage}`);\n      throw error;\n    }\n  }\n\n  async sendPushNotification(payload: PushNotificationPayload): Promise<void> {\n    // Using WebSocket-based real-time notifications instead of push notifications\n    // Emit event that WebSocket gateway can listen to for real-time delivery\n    this.eventEmitter.emit('notification.send', {\n      userId: payload.userId,\n      type: payload.type,\n      title: payload.title,\n      body: payload.body,\n      data: payload.data,\n      priority: payload.priority,\n      actionUrl: payload.actionUrl,\n    });\n\n    this.logger.log(\n      `Real-time notification emitted for user ${payload.userId}: ${payload.title}`,\n    );\n  }\n\n  async sendPushNotificationToMultipleUsers(\n    userIds: string[],\n    payload: Omit<PushNotificationPayload, 'userId'>,\n  ): Promise<BatchPushResult> {\n    // Using WebSocket-based real-time notifications instead of push notifications\n    const results: BatchPushResult = {\n      successful: userIds.length,\n      failed: 0,\n      invalidTokens: [],\n      results: userIds.map((userId) => ({\n        token: userId,\n        success: true,\n      })),\n    };\n\n    // Emit bulk notification event for WebSocket delivery\n    this.eventEmitter.emit('notification.broadcast', {\n      userIds,\n      type: payload.type,\n      title: payload.title,\n      body: payload.body,\n      data: payload.data,\n      priority: payload.priority,\n      actionUrl: payload.actionUrl,\n    });\n\n    this.logger.log(\n      `Bulk real-time notification emitted for ${userIds.length} users: ${payload.title}`,\n    );\n    return results;\n  }\n\n  async sendTestNotification(userId: string, message: string): Promise<void> {\n    await this.sendPushNotification({\n      userId,\n      title: 'Test Notification',\n      body: message,\n      type: 'SYSTEM' as NotificationType,\n      priority: 'NORMAL' as NotificationPriority,\n      data: {\n        test: 'true',\n        timestamp: new Date().toISOString(),\n      },\n    });\n\n    this.logger.log(\n      `Test real-time notification sent to user ${userId}: ${message}`,\n    );\n  }\n\n  async getUserDeviceTokens(userId: string): Promise<DeviceToken[]> {\n    try {\n      const tokens = await this.prisma.deviceToken.findMany({\n        where: {\n          userId,\n          isActive: true,\n        },\n        orderBy: { lastUsedAt: 'desc' },\n      });\n\n      return tokens.map((token) => ({\n        id: token.id,\n        userId: token.userId,\n        token: token.token,\n        platform: token.platform.toLowerCase() as 'ios' | 'android' | 'web',\n        isActive: token.isActive,\n        lastUsedAt: token.lastUsedAt,\n        deviceInfo: token.deviceInfo as any,\n      }));\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : 'Unknown error';\n      this.logger.error(`Failed to get user device tokens: ${errorMessage}`);\n      return [];\n    }\n  }\n\n  async cleanupInactiveTokens(daysInactive = 30): Promise<number> {\n    try {\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - daysInactive);\n\n      const result = await this.prisma.deviceToken.deleteMany({\n        where: {\n          OR: [\n            {\n              lastUsedAt: {\n                lt: cutoffDate,\n              },\n            },\n            {\n              isActive: false,\n            },\n          ],\n        },\n      });\n\n      this.logger.log(\n        `Cleaned up ${result.count} inactive device tokens older than ${daysInactive} days`,\n      );\n\n      return result.count;\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : 'Unknown error';\n      this.logger.error(`Failed to cleanup inactive tokens: ${errorMessage}`);\n      return 0;\n    }\n  }\n\n  async getStatistics(userId?: string) {\n    // Stub implementation\n    return {\n      totalTokens: 0,\n      activeTokens: 0,\n      platforms: { ios: 0, android: 0, web: 0 },\n      recentActivity: [],\n    };\n  }\n\n  async processScheduledNotifications() {\n    // Stub implementation\n    this.logger.log('Stub: Would process scheduled notifications');\n    return { processed: 0, failed: 0 };\n  }\n}\n"],"version":3}