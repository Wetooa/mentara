e7a3214303e51b685c3ea102b34c0276
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const testing_1 = require("@nestjs/testing");
const common_1 = require("@nestjs/common");
const booking_service_1 = require("./booking.service");
const prisma_client_provider_1 = require("../providers/prisma-client.provider");
const test_utils_1 = require("../test-utils");
describe('BookingService', () => {
    let service;
    let prismaService;
    let testFactory;
    beforeEach(async () => {
        const mockPrisma = (0, test_utils_1.createMockPrismaService)();
        const module = await testing_1.Test.createTestingModule({
            providers: [
                booking_service_1.BookingService,
                {
                    provide: prisma_client_provider_1.PrismaService,
                    useValue: mockPrisma,
                },
            ],
        }).compile();
        service = module.get(booking_service_1.BookingService);
        prismaService = module.get(prisma_client_provider_1.PrismaService);
        testFactory = new test_utils_1.TestDataFactory(prismaService);
    });
    afterEach(() => {
        jest.clearAllMocks();
    });
    describe('createMeeting', () => {
        const mockCreateMeetingDto = {
            startTime: '2024-01-15T14:00:00Z',
            duration: 60,
            therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
            title: 'Therapy Session',
            description: 'Regular therapy session',
            meetingType: 'followup',
        };
        const mockTherapist = {
            id: 'therapist-db-id',
            userId: test_utils_1.TEST_USER_IDS.THERAPIST,
        };
        const mockRelationship = {
            id: 'relationship-id',
            clientId: test_utils_1.TEST_USER_IDS.CLIENT,
            therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
        };
        const mockAvailability = {
            id: 'availability-id',
            therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
            dayOfWeek: 1, // Monday
            startTime: '09:00',
            endTime: '17:00',
            isAvailable: true,
        };
        it('should successfully create a meeting', async () => {
            const expectedMeeting = {
                id: 'meeting-id',
                ...mockCreateMeetingDto,
                status: 'SCHEDULED',
                clientId: test_utils_1.TEST_USER_IDS.CLIENT,
                client: {
                    user: {
                        firstName: 'John',
                        lastName: 'Doe',
                        email: 'john@example.com',
                    },
                },
                therapist: {
                    user: {
                        firstName: 'Dr. Jane',
                        lastName: 'Smith',
                        email: 'jane@example.com',
                    },
                },
            };
            prismaService.therapist.findFirst.mockResolvedValue(mockTherapist);
            prismaService.clientTherapist.findFirst.mockResolvedValue(mockRelationship);
            prismaService.meeting.findMany.mockResolvedValue([]); // No conflicts
            prismaService.therapistAvailability.findFirst.mockResolvedValue(mockAvailability);
            prismaService.meeting.create.mockResolvedValue(expectedMeeting);
            const result = await service.createMeeting(mockCreateMeetingDto, test_utils_1.TEST_USER_IDS.CLIENT);
            expect(result).toEqual(expectedMeeting);
            expect(prismaService.meeting.create).toHaveBeenCalledWith({
                data: {
                    ...mockCreateMeetingDto,
                    status: 'SCHEDULED',
                    clientId: test_utils_1.TEST_USER_IDS.CLIENT,
                },
                include: {
                    client: {
                        select: {
                            user: {
                                select: {
                                    firstName: true,
                                    lastName: true,
                                    email: true,
                                },
                            },
                        },
                    },
                    therapist: {
                        select: {
                            user: {
                                select: {
                                    firstName: true,
                                    lastName: true,
                                    email: true,
                                },
                            },
                        },
                    },
                },
            });
        });
        it('should throw NotFoundException when therapist not found', async () => {
            prismaService.therapist.findFirst.mockResolvedValue(null);
            await expect(service.createMeeting(mockCreateMeetingDto, test_utils_1.TEST_USER_IDS.CLIENT)).rejects.toThrow(common_1.NotFoundException);
            expect(prismaService.clientTherapist.findFirst).not.toHaveBeenCalled();
        });
        it('should throw ForbiddenException when no client-therapist relationship exists', async () => {
            prismaService.therapist.findFirst.mockResolvedValue(mockTherapist);
            prismaService.clientTherapist.findFirst.mockResolvedValue(null);
            await expect(service.createMeeting(mockCreateMeetingDto, test_utils_1.TEST_USER_IDS.CLIENT)).rejects.toThrow(common_1.ForbiddenException);
            expect(prismaService.meeting.findMany).not.toHaveBeenCalled();
        });
        it('should throw BadRequestException when there are scheduling conflicts', async () => {
            const conflictingMeeting = {
                id: 'conflict-id',
                startTime: new Date('2024-01-15T14:30:00Z'),
                duration: 60,
                status: 'SCHEDULED',
            };
            prismaService.therapist.findFirst.mockResolvedValue(mockTherapist);
            prismaService.clientTherapist.findFirst.mockResolvedValue(mockRelationship);
            prismaService.meeting.findMany.mockResolvedValue([
                conflictingMeeting,
            ]);
            await expect(service.createMeeting(mockCreateMeetingDto, test_utils_1.TEST_USER_IDS.CLIENT)).rejects.toThrow(common_1.BadRequestException);
            expect(prismaService.therapistAvailability.findFirst).not.toHaveBeenCalled();
        });
        it('should throw BadRequestException when therapist is not available', async () => {
            prismaService.therapist.findFirst.mockResolvedValue(mockTherapist);
            prismaService.clientTherapist.findFirst.mockResolvedValue(mockRelationship);
            prismaService.meeting.findMany.mockResolvedValue([]);
            prismaService.therapistAvailability.findFirst.mockResolvedValue(null);
            await expect(service.createMeeting(mockCreateMeetingDto, test_utils_1.TEST_USER_IDS.CLIENT)).rejects.toThrow(common_1.BadRequestException);
            expect(prismaService.meeting.create).not.toHaveBeenCalled();
        });
        it('should validate time format and throw BadRequestException for invalid format', async () => {
            const invalidTimeDto = {
                ...mockCreateMeetingDto,
                startTime: new Date('invalid-date'),
            };
            prismaService.therapist.findFirst.mockResolvedValue(mockTherapist);
            prismaService.clientTherapist.findFirst.mockResolvedValue(mockRelationship);
            prismaService.meeting.findMany.mockResolvedValue([]);
            prismaService.therapistAvailability.findFirst.mockResolvedValue(mockAvailability);
            await expect(service.createMeeting(invalidTimeDto, test_utils_1.TEST_USER_IDS.CLIENT)).rejects.toThrow(common_1.BadRequestException);
        });
    });
    describe('getMeetings', () => {
        const mockMeetings = [
            {
                id: 'meeting-1',
                startTime: new Date('2024-01-15T14:00:00Z'),
                duration: 60,
                status: 'SCHEDULED',
                client: {
                    user: {
                        firstName: 'John',
                        lastName: 'Doe',
                        email: 'john@example.com',
                    },
                },
                therapist: {
                    user: {
                        firstName: 'Dr. Jane',
                        lastName: 'Smith',
                        email: 'jane@example.com',
                    },
                },
            },
        ];
        it('should return meetings for therapist', async () => {
            prismaService.meeting.findMany.mockResolvedValue(mockMeetings);
            const result = await service.getMeetings(test_utils_1.TEST_USER_IDS.THERAPIST, 'therapist');
            expect(result).toEqual(mockMeetings);
            expect(prismaService.meeting.findMany).toHaveBeenCalledWith({
                where: { therapistId: test_utils_1.TEST_USER_IDS.THERAPIST },
                include: {
                    client: {
                        select: {
                            user: {
                                select: {
                                    firstName: true,
                                    lastName: true,
                                    email: true,
                                },
                            },
                        },
                    },
                    therapist: {
                        select: {
                            user: {
                                select: {
                                    firstName: true,
                                    lastName: true,
                                    email: true,
                                },
                            },
                        },
                    },
                },
                orderBy: { startTime: 'desc' },
            });
        });
        it('should return meetings for client', async () => {
            prismaService.meeting.findMany.mockResolvedValue(mockMeetings);
            const result = await service.getMeetings(test_utils_1.TEST_USER_IDS.CLIENT, 'client');
            expect(result).toEqual(mockMeetings);
            expect(prismaService.meeting.findMany).toHaveBeenCalledWith({
                where: { clientId: test_utils_1.TEST_USER_IDS.CLIENT },
                include: expect.any(Object),
                orderBy: { startTime: 'desc' },
            });
        });
        it('should handle database errors gracefully', async () => {
            prismaService.meeting.findMany.mockRejectedValue(new Error('Database error'));
            await expect(service.getMeetings(test_utils_1.TEST_USER_IDS.CLIENT, 'client')).rejects.toThrow(common_1.BadRequestException);
        });
    });
    describe('getMeeting', () => {
        const mockMeeting = {
            id: 'meeting-id',
            clientId: test_utils_1.TEST_USER_IDS.CLIENT,
            therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
            startTime: new Date('2024-01-15T14:00:00Z'),
            status: 'SCHEDULED',
            client: {
                user: {
                    firstName: 'John',
                    lastName: 'Doe',
                    email: 'john@example.com',
                },
            },
            therapist: {
                user: {
                    firstName: 'Dr. Jane',
                    lastName: 'Smith',
                    email: 'jane@example.com',
                },
            },
        };
        it('should return meeting for valid therapist access', async () => {
            prismaService.meeting.findUnique.mockResolvedValue(mockMeeting);
            const result = await service.getMeeting('meeting-id', test_utils_1.TEST_USER_IDS.THERAPIST, 'therapist');
            expect(result).toEqual(mockMeeting);
            expect(prismaService.meeting.findUnique).toHaveBeenCalledWith({
                where: { id: 'meeting-id' },
                include: expect.any(Object),
            });
        });
        it('should return meeting for valid client access', async () => {
            prismaService.meeting.findUnique.mockResolvedValue(mockMeeting);
            const result = await service.getMeeting('meeting-id', test_utils_1.TEST_USER_IDS.CLIENT, 'client');
            expect(result).toEqual(mockMeeting);
        });
        it('should throw NotFoundException when meeting does not exist', async () => {
            prismaService.meeting.findUnique.mockResolvedValue(null);
            await expect(service.getMeeting('non-existent-id', test_utils_1.TEST_USER_IDS.CLIENT, 'client')).rejects.toThrow(common_1.NotFoundException);
        });
        it('should throw ForbiddenException when therapist accesses wrong meeting', async () => {
            const wrongMeeting = {
                ...mockMeeting,
                therapistId: 'different-therapist-id',
            };
            prismaService.meeting.findUnique.mockResolvedValue(wrongMeeting);
            await expect(service.getMeeting('meeting-id', test_utils_1.TEST_USER_IDS.THERAPIST, 'therapist')).rejects.toThrow(common_1.ForbiddenException);
        });
        it('should throw ForbiddenException when client accesses wrong meeting', async () => {
            const wrongMeeting = {
                ...mockMeeting,
                clientId: 'different-client-id',
            };
            prismaService.meeting.findUnique.mockResolvedValue(wrongMeeting);
            await expect(service.getMeeting('meeting-id', test_utils_1.TEST_USER_IDS.CLIENT, 'client')).rejects.toThrow(common_1.ForbiddenException);
        });
    });
    describe('updateMeeting', () => {
        const mockUpdateDto = {
            startTime: '2024-01-15T14:00:00Z',
            duration: 60,
            therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
            title: 'Updated Session',
            description: 'Updated description',
            status: 'CONFIRMED',
        };
        const mockMeeting = {
            id: 'meeting-id',
            clientId: test_utils_1.TEST_USER_IDS.CLIENT,
            therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
            status: 'SCHEDULED',
        };
        it('should successfully update a meeting', async () => {
            const updatedMeeting = {
                ...mockMeeting,
                ...mockUpdateDto,
            };
            jest.spyOn(service, 'getMeeting').mockResolvedValue(mockMeeting);
            prismaService.meeting.update.mockResolvedValue(updatedMeeting);
            const result = await service.updateMeeting('meeting-id', mockUpdateDto, test_utils_1.TEST_USER_IDS.CLIENT, 'client');
            expect(result).toEqual(updatedMeeting);
            expect(prismaService.meeting.update).toHaveBeenCalledWith({
                where: { id: 'meeting-id' },
                data: {
                    title: mockUpdateDto.title,
                    description: mockUpdateDto.description,
                    startTime: undefined,
                    duration: undefined,
                    meetingType: undefined,
                    therapistId: undefined,
                    status: mockUpdateDto.status,
                },
                include: expect.any(Object),
            });
        });
        it('should throw BadRequestException when trying to update completed meeting', async () => {
            const completedMeeting = {
                ...mockMeeting,
                status: 'COMPLETED',
            };
            jest
                .spyOn(service, 'getMeeting')
                .mockResolvedValue(completedMeeting);
            await expect(service.updateMeeting('meeting-id', mockUpdateDto, test_utils_1.TEST_USER_IDS.CLIENT, 'client')).rejects.toThrow(common_1.BadRequestException);
            expect(prismaService.meeting.update).not.toHaveBeenCalled();
        });
        it('should throw BadRequestException when trying to update cancelled meeting', async () => {
            const cancelledMeeting = {
                ...mockMeeting,
                status: 'CANCELLED',
            };
            jest
                .spyOn(service, 'getMeeting')
                .mockResolvedValue(cancelledMeeting);
            await expect(service.updateMeeting('meeting-id', mockUpdateDto, test_utils_1.TEST_USER_IDS.CLIENT, 'client')).rejects.toThrow(common_1.BadRequestException);
        });
    });
    describe('cancelMeeting', () => {
        const mockMeeting = {
            id: 'meeting-id',
            clientId: test_utils_1.TEST_USER_IDS.CLIENT,
            therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
            status: 'SCHEDULED',
        };
        it('should successfully cancel a meeting', async () => {
            const cancelledMeeting = {
                ...mockMeeting,
                status: 'CANCELLED',
            };
            jest.spyOn(service, 'getMeeting').mockResolvedValue(mockMeeting);
            prismaService.meeting.update.mockResolvedValue(cancelledMeeting);
            const result = await service.cancelMeeting('meeting-id', test_utils_1.TEST_USER_IDS.CLIENT, 'client');
            expect(result).toEqual(cancelledMeeting);
            expect(prismaService.meeting.update).toHaveBeenCalledWith({
                where: { id: 'meeting-id' },
                data: { status: 'CANCELLED' },
                include: expect.any(Object),
            });
        });
        it('should throw BadRequestException when meeting is already cancelled', async () => {
            const cancelledMeeting = {
                ...mockMeeting,
                status: 'CANCELLED',
            };
            jest
                .spyOn(service, 'getMeeting')
                .mockResolvedValue(cancelledMeeting);
            await expect(service.cancelMeeting('meeting-id', test_utils_1.TEST_USER_IDS.CLIENT, 'client')).rejects.toThrow(common_1.BadRequestException);
            expect(prismaService.meeting.update).not.toHaveBeenCalled();
        });
        it('should throw BadRequestException when trying to cancel completed meeting', async () => {
            const completedMeeting = {
                ...mockMeeting,
                status: 'COMPLETED',
            };
            jest
                .spyOn(service, 'getMeeting')
                .mockResolvedValue(completedMeeting);
            await expect(service.cancelMeeting('meeting-id', test_utils_1.TEST_USER_IDS.CLIENT, 'client')).rejects.toThrow(common_1.BadRequestException);
        });
    });
    describe('createAvailability', () => {
        const mockCreateAvailabilityDto = {
            dayOfWeek: 1, // Monday
            startTime: '09:00',
            endTime: '17:00',
            notes: 'Regular availability',
        };
        it('should successfully create availability', async () => {
            const expectedAvailability = {
                id: 'availability-id',
                therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
                ...mockCreateAvailabilityDto,
            };
            prismaService.therapistAvailability.findFirst.mockResolvedValue(null); // No overlap
            prismaService.therapistAvailability.create.mockResolvedValue(expectedAvailability);
            const result = await service.createAvailability(mockCreateAvailabilityDto, test_utils_1.TEST_USER_IDS.THERAPIST);
            expect(result).toEqual(expectedAvailability);
            expect(prismaService.therapistAvailability.create).toHaveBeenCalledWith({
                data: {
                    therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
                    ...mockCreateAvailabilityDto,
                },
            });
        });
        it('should throw BadRequestException for invalid time format', async () => {
            const invalidDto = {
                ...mockCreateAvailabilityDto,
                startTime: '25:00', // Invalid hour
            };
            await expect(service.createAvailability(invalidDto, test_utils_1.TEST_USER_IDS.THERAPIST)).rejects.toThrow(common_1.BadRequestException);
            expect(prismaService.therapistAvailability.findFirst).not.toHaveBeenCalled();
        });
        it('should throw BadRequestException when start time is after end time', async () => {
            const invalidDto = {
                ...mockCreateAvailabilityDto,
                startTime: '17:00',
                endTime: '09:00',
            };
            await expect(service.createAvailability(invalidDto, test_utils_1.TEST_USER_IDS.THERAPIST)).rejects.toThrow(common_1.BadRequestException);
        });
        it('should throw BadRequestException when availability overlaps', async () => {
            const overlappingAvailability = {
                id: 'existing-id',
                startTime: '10:00',
                endTime: '16:00',
            };
            prismaService.therapistAvailability.findFirst.mockResolvedValue(overlappingAvailability);
            await expect(service.createAvailability(mockCreateAvailabilityDto, test_utils_1.TEST_USER_IDS.THERAPIST)).rejects.toThrow(common_1.BadRequestException);
            expect(prismaService.therapistAvailability.create).not.toHaveBeenCalled();
        });
    });
    describe('getAvailability', () => {
        const mockAvailabilities = [
            {
                id: 'availability-1',
                therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
                dayOfWeek: 1,
                startTime: '09:00',
                endTime: '12:00',
            },
            {
                id: 'availability-2',
                therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
                dayOfWeek: 1,
                startTime: '13:00',
                endTime: '17:00',
            },
        ];
        it('should return therapist availability', async () => {
            prismaService.therapistAvailability.findMany.mockResolvedValue(mockAvailabilities);
            const result = await service.getAvailability(test_utils_1.TEST_USER_IDS.THERAPIST);
            expect(result).toEqual(mockAvailabilities);
            expect(prismaService.therapistAvailability.findMany).toHaveBeenCalledWith({
                where: { therapistId: test_utils_1.TEST_USER_IDS.THERAPIST },
                orderBy: [{ dayOfWeek: 'asc' }, { startTime: 'asc' }],
            });
        });
        it('should handle database errors', async () => {
            prismaService.therapistAvailability.findMany.mockRejectedValue(new Error('Database error'));
            await expect(service.getAvailability(test_utils_1.TEST_USER_IDS.THERAPIST)).rejects.toThrow(common_1.BadRequestException);
        });
    });
    describe('updateAvailability', () => {
        const mockUpdateDto = {
            dayOfWeek: 1,
            startTime: '10:00',
            endTime: '16:00',
            notes: 'Updated hours',
        };
        it('should successfully update availability', async () => {
            const existingAvailability = {
                id: 'availability-id',
                therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
            };
            const updatedAvailability = {
                ...existingAvailability,
                ...mockUpdateDto,
            };
            prismaService.therapistAvailability.findFirst.mockResolvedValue(existingAvailability);
            prismaService.therapistAvailability.update.mockResolvedValue(updatedAvailability);
            const result = await service.updateAvailability('availability-id', mockUpdateDto, test_utils_1.TEST_USER_IDS.THERAPIST);
            expect(result).toEqual(updatedAvailability);
            expect(prismaService.therapistAvailability.update).toHaveBeenCalledWith({
                where: { id: 'availability-id' },
                data: mockUpdateDto,
            });
        });
        it('should throw NotFoundException when availability does not exist', async () => {
            prismaService.therapistAvailability.findFirst.mockResolvedValue(null);
            await expect(service.updateAvailability('non-existent-id', mockUpdateDto, test_utils_1.TEST_USER_IDS.THERAPIST)).rejects.toThrow(common_1.NotFoundException);
            expect(prismaService.therapistAvailability.update).not.toHaveBeenCalled();
        });
    });
    describe('deleteAvailability', () => {
        it('should successfully delete availability', async () => {
            const existingAvailability = {
                id: 'availability-id',
                therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
            };
            prismaService.therapistAvailability.findFirst.mockResolvedValue(existingAvailability);
            prismaService.therapistAvailability.delete.mockResolvedValue(existingAvailability);
            const result = await service.deleteAvailability('availability-id', test_utils_1.TEST_USER_IDS.THERAPIST);
            expect(result).toEqual(existingAvailability);
            expect(prismaService.therapistAvailability.delete).toHaveBeenCalledWith({
                where: { id: 'availability-id' },
            });
        });
        it('should throw NotFoundException when availability does not exist', async () => {
            prismaService.therapistAvailability.findFirst.mockResolvedValue(null);
            await expect(service.deleteAvailability('non-existent-id', test_utils_1.TEST_USER_IDS.THERAPIST)).rejects.toThrow(common_1.NotFoundException);
            expect(prismaService.therapistAvailability.delete).not.toHaveBeenCalled();
        });
    });
    describe('getAvailableSlots', () => {
        const mockDate = '2024-01-15'; // Monday
        const mockAvailability = [
            {
                id: 'availability-1',
                therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
                dayOfWeek: 1, // Monday
                startTime: '09:00',
                endTime: '17:00',
                isAvailable: true,
            },
        ];
        it('should return available slots when no conflicts', async () => {
            prismaService.therapistAvailability.findMany.mockResolvedValue(mockAvailability);
            prismaService.meeting.findMany.mockResolvedValue([]); // No existing bookings
            const result = await service.getAvailableSlots(test_utils_1.TEST_USER_IDS.THERAPIST, mockDate);
            expect(result).toBeDefined();
            expect(Array.isArray(result)).toBe(true);
            expect(prismaService.therapistAvailability.findMany).toHaveBeenCalledWith({
                where: {
                    therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
                    dayOfWeek: 1,
                    isAvailable: true,
                },
                orderBy: { startTime: 'asc' },
            });
        });
        it('should return empty array when therapist has no availability', async () => {
            prismaService.therapistAvailability.findMany.mockResolvedValue([]);
            const result = await service.getAvailableSlots(test_utils_1.TEST_USER_IDS.THERAPIST, mockDate);
            expect(result).toEqual([]);
            expect(prismaService.meeting.findMany).not.toHaveBeenCalled();
        });
        it('should exclude conflicting time slots', async () => {
            const existingBooking = {
                id: 'booking-1',
                startTime: new Date('2024-01-15T10:00:00Z'),
                duration: 60,
                status: 'SCHEDULED',
            };
            prismaService.therapistAvailability.findMany.mockResolvedValue(mockAvailability);
            prismaService.meeting.findMany.mockResolvedValue([
                existingBooking,
            ]);
            const result = await service.getAvailableSlots(test_utils_1.TEST_USER_IDS.THERAPIST, mockDate);
            expect(result).toBeDefined();
            expect(prismaService.meeting.findMany).toHaveBeenCalledWith({
                where: {
                    therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
                    startTime: {
                        gte: expect.any(Date),
                        lte: expect.any(Date),
                    },
                    status: { in: ['SCHEDULED', 'CONFIRMED'] },
                },
                orderBy: { startTime: 'asc' },
            });
        });
    });
    describe('validateMeetingTime', () => {
        it('should validate meeting time successfully', async () => {
            const mockAvailability = {
                id: 'availability-id',
                therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
                dayOfWeek: 1,
                startTime: '09:00',
                endTime: '17:00',
                isAvailable: true,
            };
            prismaService.therapistAvailability.findFirst.mockResolvedValue(mockAvailability);
            prismaService.meeting.findMany.mockResolvedValue([]); // No conflicts
            await expect(service.validateMeetingTime(test_utils_1.TEST_USER_IDS.THERAPIST, test_utils_1.TEST_USER_IDS.CLIENT, '2024-01-15T14:00:00Z', 60)).resolves.not.toThrow();
            expect(prismaService.therapistAvailability.findFirst).toHaveBeenCalled();
            expect(prismaService.meeting.findMany).toHaveBeenCalled();
        });
        it('should throw BadRequestException for invalid duration', async () => {
            await expect(service.validateMeetingTime(test_utils_1.TEST_USER_IDS.THERAPIST, test_utils_1.TEST_USER_IDS.CLIENT, '2024-01-15T14:00:00Z', 999)).rejects.toThrow(common_1.BadRequestException);
            expect(prismaService.therapistAvailability.findFirst).not.toHaveBeenCalled();
        });
        it('should throw BadRequestException when therapist not available', async () => {
            prismaService.therapistAvailability.findFirst.mockResolvedValue(null);
            await expect(service.validateMeetingTime(test_utils_1.TEST_USER_IDS.THERAPIST, test_utils_1.TEST_USER_IDS.CLIENT, '2024-01-15T14:00:00Z', 60)).rejects.toThrow(common_1.BadRequestException);
        });
        it('should throw BadRequestException for scheduling conflicts', async () => {
            const mockAvailability = {
                id: 'availability-id',
                therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
                dayOfWeek: 1,
                startTime: '09:00',
                endTime: '17:00',
                isAvailable: true,
            };
            const conflictingMeeting = {
                id: 'conflict-id',
                startTime: new Date('2024-01-15T14:30:00Z'),
                duration: 60,
                status: 'SCHEDULED',
            };
            prismaService.therapistAvailability.findFirst.mockResolvedValue(mockAvailability);
            prismaService.meeting.findMany.mockResolvedValue([
                conflictingMeeting,
            ]);
            await expect(service.validateMeetingTime(test_utils_1.TEST_USER_IDS.THERAPIST, test_utils_1.TEST_USER_IDS.CLIENT, '2024-01-15T14:00:00Z', 60)).rejects.toThrow(common_1.BadRequestException);
        });
    });
    describe('Edge Cases and Error Handling', () => {
        it('should handle database connection errors', async () => {
            prismaService.meeting.findMany.mockRejectedValue(new Error('Connection timeout'));
            await expect(service.getMeetings(test_utils_1.TEST_USER_IDS.CLIENT, 'client')).rejects.toThrow(common_1.BadRequestException);
        });
        it('should handle invalid meeting status transitions', async () => {
            const mockMeeting = {
                id: 'meeting-id',
                status: 'COMPLETED',
                clientId: test_utils_1.TEST_USER_IDS.CLIENT,
                therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
            };
            jest.spyOn(service, 'getMeeting').mockResolvedValue(mockMeeting);
            await expect(service.updateMeeting('meeting-id', {
                startTime: '2024-01-15T14:00:00Z',
                duration: 60,
                therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
                title: 'Test Session',
                description: 'Test description',
                status: 'SCHEDULED',
            }, test_utils_1.TEST_USER_IDS.CLIENT, 'client')).rejects.toThrow(common_1.BadRequestException);
        });
        it('should handle timezone edge cases in slot calculation', async () => {
            const mockAvailability = [
                {
                    id: 'availability-1',
                    therapistId: test_utils_1.TEST_USER_IDS.THERAPIST,
                    dayOfWeek: 1,
                    startTime: '23:30', // Near midnight
                    endTime: '23:59',
                    isAvailable: true,
                },
            ];
            prismaService.therapistAvailability.findMany.mockResolvedValue(mockAvailability);
            prismaService.meeting.findMany.mockResolvedValue([]);
            const result = await service.getAvailableSlots(test_utils_1.TEST_USER_IDS.THERAPIST, '2024-01-15');
            expect(result).toBeDefined();
            expect(Array.isArray(result)).toBe(true);
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvd2V0b29hL0RvY3VtZW50cy9jb2RlL3Byb2plY3RzL21lbnRhcmEvbWVudGFyYS1hcGkvc3JjL2Jvb2tpbmcvYm9va2luZy5zZXJ2aWNlLnNwZWMudHMiLCJtYXBwaW5ncyI6Ijs7QUFBQSw2Q0FBc0Q7QUFDdEQsMkNBSXdCO0FBQ3hCLHVEQUFtRDtBQUNuRCxnRkFBb0U7QUFFcEUsOENBSXVCO0FBRXZCLFFBQVEsQ0FBQyxnQkFBZ0IsRUFBRSxHQUFHLEVBQUU7SUFDOUIsSUFBSSxPQUF1QixDQUFDO0lBQzVCLElBQUksYUFBeUMsQ0FBQztJQUM5QyxJQUFJLFdBQTRCLENBQUM7SUFFakMsVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFO1FBQ3BCLE1BQU0sVUFBVSxHQUFHLElBQUEsb0NBQXVCLEdBQUUsQ0FBQztRQUU3QyxNQUFNLE1BQU0sR0FBa0IsTUFBTSxjQUFJLENBQUMsbUJBQW1CLENBQUM7WUFDM0QsU0FBUyxFQUFFO2dCQUNULGdDQUFjO2dCQUNkO29CQUNFLE9BQU8sRUFBRSxzQ0FBYTtvQkFDdEIsUUFBUSxFQUFFLFVBQVU7aUJBQ3JCO2FBQ0Y7U0FDRixDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFFYixPQUFPLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBaUIsZ0NBQWMsQ0FBQyxDQUFDO1FBQ3JELGFBQWEsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLHNDQUFhLENBQUMsQ0FBQztRQUMxQyxXQUFXLEdBQUcsSUFBSSw0QkFBZSxDQUFDLGFBQW9CLENBQUMsQ0FBQztJQUMxRCxDQUFDLENBQUMsQ0FBQztJQUVILFNBQVMsQ0FBQyxHQUFHLEVBQUU7UUFDYixJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDdkIsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsZUFBZSxFQUFFLEdBQUcsRUFBRTtRQUM3QixNQUFNLG9CQUFvQixHQUFHO1lBQzNCLFNBQVMsRUFBRSxzQkFBc0I7WUFDakMsUUFBUSxFQUFFLEVBQUU7WUFDWixXQUFXLEVBQUUsMEJBQWEs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QixNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMzQyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvd2V0b29hL0RvY3VtZW50cy9jb2RlL3Byb2plY3RzL21lbnRhcmEvbWVudGFyYS1hcGkvc3JjL2Jvb2tpbmcvYm9va2luZy5zZXJ2aWNlLnNwZWMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGVzdCwgVGVzdGluZ01vZHVsZSB9IGZyb20gJ0BuZXN0anMvdGVzdGluZyc7XG5pbXBvcnQge1xuICBCYWRSZXF1ZXN0RXhjZXB0aW9uLFxuICBOb3RGb3VuZEV4Y2VwdGlvbixcbiAgRm9yYmlkZGVuRXhjZXB0aW9uLFxufSBmcm9tICdAbmVzdGpzL2NvbW1vbic7XG5pbXBvcnQgeyBCb29raW5nU2VydmljZSB9IGZyb20gJy4vYm9va2luZy5zZXJ2aWNlJztcbmltcG9ydCB7IFByaXNtYVNlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvcHJpc21hLWNsaWVudC5wcm92aWRlcic7XG5pbXBvcnQgeyBNZWV0aW5nU3RhdHVzIH0gZnJvbSAnQHByaXNtYS9jbGllbnQnO1xuaW1wb3J0IHtcbiAgY3JlYXRlTW9ja1ByaXNtYVNlcnZpY2UsXG4gIFRFU1RfVVNFUl9JRFMsXG4gIFRlc3REYXRhRmFjdG9yeSxcbn0gZnJvbSAnLi4vdGVzdC11dGlscyc7XG5cbmRlc2NyaWJlKCdCb29raW5nU2VydmljZScsICgpID0+IHtcbiAgbGV0IHNlcnZpY2U6IEJvb2tpbmdTZXJ2aWNlO1xuICBsZXQgcHJpc21hU2VydmljZTogamVzdC5Nb2NrZWQ8UHJpc21hU2VydmljZT47XG4gIGxldCB0ZXN0RmFjdG9yeTogVGVzdERhdGFGYWN0b3J5O1xuXG4gIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tQcmlzbWEgPSBjcmVhdGVNb2NrUHJpc21hU2VydmljZSgpO1xuXG4gICAgY29uc3QgbW9kdWxlOiBUZXN0aW5nTW9kdWxlID0gYXdhaXQgVGVzdC5jcmVhdGVUZXN0aW5nTW9kdWxlKHtcbiAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICBCb29raW5nU2VydmljZSxcbiAgICAgICAge1xuICAgICAgICAgIHByb3ZpZGU6IFByaXNtYVNlcnZpY2UsXG4gICAgICAgICAgdXNlVmFsdWU6IG1vY2tQcmlzbWEsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0pLmNvbXBpbGUoKTtcblxuICAgIHNlcnZpY2UgPSBtb2R1bGUuZ2V0PEJvb2tpbmdTZXJ2aWNlPihCb29raW5nU2VydmljZSk7XG4gICAgcHJpc21hU2VydmljZSA9IG1vZHVsZS5nZXQoUHJpc21hU2VydmljZSk7XG4gICAgdGVzdEZhY3RvcnkgPSBuZXcgVGVzdERhdGFGYWN0b3J5KHByaXNtYVNlcnZpY2UgYXMgYW55KTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NyZWF0ZU1lZXRpbmcnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja0NyZWF0ZU1lZXRpbmdEdG8gPSB7XG4gICAgICBzdGFydFRpbWU6ICcyMDI0LTAxLTE1VDE0OjAwOjAwWicsXG4gICAgICBkdXJhdGlvbjogNjAsXG4gICAgICB0aGVyYXBpc3RJZDogVEVTVF9VU0VSX0lEUy5USEVSQVBJU1QsXG4gICAgICB0aXRsZTogJ1RoZXJhcHkgU2Vzc2lvbicsXG4gICAgICBkZXNjcmlwdGlvbjogJ1JlZ3VsYXIgdGhlcmFweSBzZXNzaW9uJyxcbiAgICAgIG1lZXRpbmdUeXBlOiAnZm9sbG93dXAnIGFzIGNvbnN0LFxuICAgIH07XG5cbiAgICBjb25zdCBtb2NrVGhlcmFwaXN0ID0ge1xuICAgICAgaWQ6ICd0aGVyYXBpc3QtZGItaWQnLFxuICAgICAgdXNlcklkOiBURVNUX1VTRVJfSURTLlRIRVJBUElTVCxcbiAgICB9O1xuXG4gICAgY29uc3QgbW9ja1JlbGF0aW9uc2hpcCA9IHtcbiAgICAgIGlkOiAncmVsYXRpb25zaGlwLWlkJyxcbiAgICAgIGNsaWVudElkOiBURVNUX1VTRVJfSURTLkNMSUVOVCxcbiAgICAgIHRoZXJhcGlzdElkOiBURVNUX1VTRVJfSURTLlRIRVJBUElTVCxcbiAgICB9O1xuXG4gICAgY29uc3QgbW9ja0F2YWlsYWJpbGl0eSA9IHtcbiAgICAgIGlkOiAnYXZhaWxhYmlsaXR5LWlkJyxcbiAgICAgIHRoZXJhcGlzdElkOiBURVNUX1VTRVJfSURTLlRIRVJBUElTVCxcbiAgICAgIGRheU9mV2VlazogMSwgLy8gTW9uZGF5XG4gICAgICBzdGFydFRpbWU6ICcwOTowMCcsXG4gICAgICBlbmRUaW1lOiAnMTc6MDAnLFxuICAgICAgaXNBdmFpbGFibGU6IHRydWUsXG4gICAgfTtcblxuICAgIGl0KCdzaG91bGQgc3VjY2Vzc2Z1bGx5IGNyZWF0ZSBhIG1lZXRpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBleHBlY3RlZE1lZXRpbmcgPSB7XG4gICAgICAgIGlkOiAnbWVldGluZy1pZCcsXG4gICAgICAgIC4uLm1vY2tDcmVhdGVNZWV0aW5nRHRvLFxuICAgICAgICBzdGF0dXM6ICdTQ0hFRFVMRUQnLFxuICAgICAgICBjbGllbnRJZDogVEVTVF9VU0VSX0lEUy5DTElFTlQsXG4gICAgICAgIGNsaWVudDoge1xuICAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICAgIGZpcnN0TmFtZTogJ0pvaG4nLFxuICAgICAgICAgICAgbGFzdE5hbWU6ICdEb2UnLFxuICAgICAgICAgICAgZW1haWw6ICdqb2huQGV4YW1wbGUuY29tJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB0aGVyYXBpc3Q6IHtcbiAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICBmaXJzdE5hbWU6ICdEci4gSmFuZScsXG4gICAgICAgICAgICBsYXN0TmFtZTogJ1NtaXRoJyxcbiAgICAgICAgICAgIGVtYWlsOiAnamFuZUBleGFtcGxlLmNvbScsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIChwcmlzbWFTZXJ2aWNlLnRoZXJhcGlzdC5maW5kRmlyc3QgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShcbiAgICAgICAgbW9ja1RoZXJhcGlzdCxcbiAgICAgICk7XG4gICAgICAocHJpc21hU2VydmljZS5jbGllbnRUaGVyYXBpc3QuZmluZEZpcnN0IGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoXG4gICAgICAgIG1vY2tSZWxhdGlvbnNoaXAsXG4gICAgICApO1xuICAgICAgKHByaXNtYVNlcnZpY2UubWVldGluZy5maW5kTWFueSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKFtdKTsgLy8gTm8gY29uZmxpY3RzXG4gICAgICAoXG4gICAgICAgIHByaXNtYVNlcnZpY2UudGhlcmFwaXN0QXZhaWxhYmlsaXR5LmZpbmRGaXJzdCBhcyBqZXN0Lk1vY2tcbiAgICAgICkubW9ja1Jlc29sdmVkVmFsdWUobW9ja0F2YWlsYWJpbGl0eSk7XG4gICAgICAocHJpc21hU2VydmljZS5tZWV0aW5nLmNyZWF0ZSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKFxuICAgICAgICBleHBlY3RlZE1lZXRpbmcsXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLmNyZWF0ZU1lZXRpbmcoXG4gICAgICAgIG1vY2tDcmVhdGVNZWV0aW5nRHRvLFxuICAgICAgICBURVNUX1VTRVJfSURTLkNMSUVOVCxcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoZXhwZWN0ZWRNZWV0aW5nKTtcbiAgICAgIGV4cGVjdChwcmlzbWFTZXJ2aWNlLm1lZXRpbmcuY3JlYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAuLi5tb2NrQ3JlYXRlTWVldGluZ0R0byxcbiAgICAgICAgICBzdGF0dXM6ICdTQ0hFRFVMRUQnLFxuICAgICAgICAgIGNsaWVudElkOiBURVNUX1VTRVJfSURTLkNMSUVOVCxcbiAgICAgICAgfSxcbiAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgIGNsaWVudDoge1xuICAgICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgICAgICAgIGZpcnN0TmFtZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGxhc3ROYW1lOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgZW1haWw6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aGVyYXBpc3Q6IHtcbiAgICAgICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICAgICAgICBmaXJzdE5hbWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICBsYXN0TmFtZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGVtYWlsOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgTm90Rm91bmRFeGNlcHRpb24gd2hlbiB0aGVyYXBpc3Qgbm90IGZvdW5kJywgYXN5bmMgKCkgPT4ge1xuICAgICAgKHByaXNtYVNlcnZpY2UudGhlcmFwaXN0LmZpbmRGaXJzdCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIHNlcnZpY2UuY3JlYXRlTWVldGluZyhtb2NrQ3JlYXRlTWVldGluZ0R0bywgVEVTVF9VU0VSX0lEUy5DTElFTlQpLFxuICAgICAgKS5yZWplY3RzLnRvVGhyb3coTm90Rm91bmRFeGNlcHRpb24pO1xuXG4gICAgICBleHBlY3QocHJpc21hU2VydmljZS5jbGllbnRUaGVyYXBpc3QuZmluZEZpcnN0KS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBGb3JiaWRkZW5FeGNlcHRpb24gd2hlbiBubyBjbGllbnQtdGhlcmFwaXN0IHJlbGF0aW9uc2hpcCBleGlzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAocHJpc21hU2VydmljZS50aGVyYXBpc3QuZmluZEZpcnN0IGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoXG4gICAgICAgIG1vY2tUaGVyYXBpc3QsXG4gICAgICApO1xuICAgICAgKHByaXNtYVNlcnZpY2UuY2xpZW50VGhlcmFwaXN0LmZpbmRGaXJzdCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKFxuICAgICAgICBudWxsLFxuICAgICAgKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBzZXJ2aWNlLmNyZWF0ZU1lZXRpbmcobW9ja0NyZWF0ZU1lZXRpbmdEdG8sIFRFU1RfVVNFUl9JRFMuQ0xJRU5UKSxcbiAgICAgICkucmVqZWN0cy50b1Rocm93KEZvcmJpZGRlbkV4Y2VwdGlvbik7XG5cbiAgICAgIGV4cGVjdChwcmlzbWFTZXJ2aWNlLm1lZXRpbmcuZmluZE1hbnkpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IEJhZFJlcXVlc3RFeGNlcHRpb24gd2hlbiB0aGVyZSBhcmUgc2NoZWR1bGluZyBjb25mbGljdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb25mbGljdGluZ01lZXRpbmcgPSB7XG4gICAgICAgIGlkOiAnY29uZmxpY3QtaWQnLFxuICAgICAgICBzdGFydFRpbWU6IG5ldyBEYXRlKCcyMDI0LTAxLTE1VDE0OjMwOjAwWicpLFxuICAgICAgICBkdXJhdGlvbjogNjAsXG4gICAgICAgIHN0YXR1czogJ1NDSEVEVUxFRCcgYXMgTWVldGluZ1N0YXR1cyxcbiAgICAgIH07XG5cbiAgICAgIChwcmlzbWFTZXJ2aWNlLnRoZXJhcGlzdC5maW5kRmlyc3QgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShcbiAgICAgICAgbW9ja1RoZXJhcGlzdCxcbiAgICAgICk7XG4gICAgICAocHJpc21hU2VydmljZS5jbGllbnRUaGVyYXBpc3QuZmluZEZpcnN0IGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoXG4gICAgICAgIG1vY2tSZWxhdGlvbnNoaXAsXG4gICAgICApO1xuICAgICAgKHByaXNtYVNlcnZpY2UubWVldGluZy5maW5kTWFueSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKFtcbiAgICAgICAgY29uZmxpY3RpbmdNZWV0aW5nLFxuICAgICAgXSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgc2VydmljZS5jcmVhdGVNZWV0aW5nKG1vY2tDcmVhdGVNZWV0aW5nRHRvLCBURVNUX1VTRVJfSURTLkNMSUVOVCksXG4gICAgICApLnJlamVjdHMudG9UaHJvdyhCYWRSZXF1ZXN0RXhjZXB0aW9uKTtcblxuICAgICAgZXhwZWN0KFxuICAgICAgICBwcmlzbWFTZXJ2aWNlLnRoZXJhcGlzdEF2YWlsYWJpbGl0eS5maW5kRmlyc3QsXG4gICAgICApLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IEJhZFJlcXVlc3RFeGNlcHRpb24gd2hlbiB0aGVyYXBpc3QgaXMgbm90IGF2YWlsYWJsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIChwcmlzbWFTZXJ2aWNlLnRoZXJhcGlzdC5maW5kRmlyc3QgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShcbiAgICAgICAgbW9ja1RoZXJhcGlzdCxcbiAgICAgICk7XG4gICAgICAocHJpc21hU2VydmljZS5jbGllbnRUaGVyYXBpc3QuZmluZEZpcnN0IGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoXG4gICAgICAgIG1vY2tSZWxhdGlvbnNoaXAsXG4gICAgICApO1xuICAgICAgKHByaXNtYVNlcnZpY2UubWVldGluZy5maW5kTWFueSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKFtdKTtcbiAgICAgIChcbiAgICAgICAgcHJpc21hU2VydmljZS50aGVyYXBpc3RBdmFpbGFiaWxpdHkuZmluZEZpcnN0IGFzIGplc3QuTW9ja1xuICAgICAgKS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBzZXJ2aWNlLmNyZWF0ZU1lZXRpbmcobW9ja0NyZWF0ZU1lZXRpbmdEdG8sIFRFU1RfVVNFUl9JRFMuQ0xJRU5UKSxcbiAgICAgICkucmVqZWN0cy50b1Rocm93KEJhZFJlcXVlc3RFeGNlcHRpb24pO1xuXG4gICAgICBleHBlY3QocHJpc21hU2VydmljZS5tZWV0aW5nLmNyZWF0ZSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgdGltZSBmb3JtYXQgYW5kIHRocm93IEJhZFJlcXVlc3RFeGNlcHRpb24gZm9yIGludmFsaWQgZm9ybWF0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFRpbWVEdG8gPSB7XG4gICAgICAgIC4uLm1vY2tDcmVhdGVNZWV0aW5nRHRvLFxuICAgICAgICBzdGFydFRpbWU6IG5ldyBEYXRlKCdpbnZhbGlkLWRhdGUnKSxcbiAgICAgIH07XG5cbiAgICAgIChwcmlzbWFTZXJ2aWNlLnRoZXJhcGlzdC5maW5kRmlyc3QgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShcbiAgICAgICAgbW9ja1RoZXJhcGlzdCxcbiAgICAgICk7XG4gICAgICAocHJpc21hU2VydmljZS5jbGllbnRUaGVyYXBpc3QuZmluZEZpcnN0IGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoXG4gICAgICAgIG1vY2tSZWxhdGlvbnNoaXAsXG4gICAgICApO1xuICAgICAgKHByaXNtYVNlcnZpY2UubWVldGluZy5maW5kTWFueSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKFtdKTtcbiAgICAgIChcbiAgICAgICAgcHJpc21hU2VydmljZS50aGVyYXBpc3RBdmFpbGFiaWxpdHkuZmluZEZpcnN0IGFzIGplc3QuTW9ja1xuICAgICAgKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQXZhaWxhYmlsaXR5KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBzZXJ2aWNlLmNyZWF0ZU1lZXRpbmcoaW52YWxpZFRpbWVEdG8sIFRFU1RfVVNFUl9JRFMuQ0xJRU5UKSxcbiAgICAgICkucmVqZWN0cy50b1Rocm93KEJhZFJlcXVlc3RFeGNlcHRpb24pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0TWVldGluZ3MnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja01lZXRpbmdzID0gW1xuICAgICAge1xuICAgICAgICBpZDogJ21lZXRpbmctMScsXG4gICAgICAgIHN0YXJ0VGltZTogbmV3IERhdGUoJzIwMjQtMDEtMTVUMTQ6MDA6MDBaJyksXG4gICAgICAgIGR1cmF0aW9uOiA2MCxcbiAgICAgICAgc3RhdHVzOiAnU0NIRURVTEVEJyBhcyBNZWV0aW5nU3RhdHVzLFxuICAgICAgICBjbGllbnQ6IHtcbiAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICBmaXJzdE5hbWU6ICdKb2huJyxcbiAgICAgICAgICAgIGxhc3ROYW1lOiAnRG9lJyxcbiAgICAgICAgICAgIGVtYWlsOiAnam9obkBleGFtcGxlLmNvbScsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdGhlcmFwaXN0OiB7XG4gICAgICAgICAgdXNlcjoge1xuICAgICAgICAgICAgZmlyc3ROYW1lOiAnRHIuIEphbmUnLFxuICAgICAgICAgICAgbGFzdE5hbWU6ICdTbWl0aCcsXG4gICAgICAgICAgICBlbWFpbDogJ2phbmVAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIF07XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBtZWV0aW5ncyBmb3IgdGhlcmFwaXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgKHByaXNtYVNlcnZpY2UubWVldGluZy5maW5kTWFueSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKFxuICAgICAgICBtb2NrTWVldGluZ3MsXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLmdldE1lZXRpbmdzKFxuICAgICAgICBURVNUX1VTRVJfSURTLlRIRVJBUElTVCxcbiAgICAgICAgJ3RoZXJhcGlzdCcsXG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tNZWV0aW5ncyk7XG4gICAgICBleHBlY3QocHJpc21hU2VydmljZS5tZWV0aW5nLmZpbmRNYW55KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIHdoZXJlOiB7IHRoZXJhcGlzdElkOiBURVNUX1VTRVJfSURTLlRIRVJBUElTVCB9LFxuICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgY2xpZW50OiB7XG4gICAgICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgICAgdXNlcjoge1xuICAgICAgICAgICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgICAgICAgZmlyc3ROYW1lOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgbGFzdE5hbWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICBlbWFpbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRoZXJhcGlzdDoge1xuICAgICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgICAgICAgIGZpcnN0TmFtZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGxhc3ROYW1lOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgZW1haWw6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgb3JkZXJCeTogeyBzdGFydFRpbWU6ICdkZXNjJyB9LFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBtZWV0aW5ncyBmb3IgY2xpZW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgKHByaXNtYVNlcnZpY2UubWVldGluZy5maW5kTWFueSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKFxuICAgICAgICBtb2NrTWVldGluZ3MsXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLmdldE1lZXRpbmdzKFRFU1RfVVNFUl9JRFMuQ0xJRU5ULCAnY2xpZW50Jyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja01lZXRpbmdzKTtcbiAgICAgIGV4cGVjdChwcmlzbWFTZXJ2aWNlLm1lZXRpbmcuZmluZE1hbnkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgd2hlcmU6IHsgY2xpZW50SWQ6IFRFU1RfVVNFUl9JRFMuQ0xJRU5UIH0sXG4gICAgICAgIGluY2x1ZGU6IGV4cGVjdC5hbnkoT2JqZWN0KSxcbiAgICAgICAgb3JkZXJCeTogeyBzdGFydFRpbWU6ICdkZXNjJyB9LFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBkYXRhYmFzZSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIChwcmlzbWFTZXJ2aWNlLm1lZXRpbmcuZmluZE1hbnkgYXMgamVzdC5Nb2NrKS5tb2NrUmVqZWN0ZWRWYWx1ZShcbiAgICAgICAgbmV3IEVycm9yKCdEYXRhYmFzZSBlcnJvcicpLFxuICAgICAgKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBzZXJ2aWNlLmdldE1lZXRpbmdzKFRFU1RfVVNFUl9JRFMuQ0xJRU5ULCAnY2xpZW50JyksXG4gICAgICApLnJlamVjdHMudG9UaHJvdyhCYWRSZXF1ZXN0RXhjZXB0aW9uKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldE1lZXRpbmcnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja01lZXRpbmcgPSB7XG4gICAgICBpZDogJ21lZXRpbmctaWQnLFxuICAgICAgY2xpZW50SWQ6IFRFU1RfVVNFUl9JRFMuQ0xJRU5ULFxuICAgICAgdGhlcmFwaXN0SWQ6IFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNULFxuICAgICAgc3RhcnRUaW1lOiBuZXcgRGF0ZSgnMjAyNC0wMS0xNVQxNDowMDowMFonKSxcbiAgICAgIHN0YXR1czogJ1NDSEVEVUxFRCcgYXMgTWVldGluZ1N0YXR1cyxcbiAgICAgIGNsaWVudDoge1xuICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgZmlyc3ROYW1lOiAnSm9obicsXG4gICAgICAgICAgbGFzdE5hbWU6ICdEb2UnLFxuICAgICAgICAgIGVtYWlsOiAnam9obkBleGFtcGxlLmNvbScsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgdGhlcmFwaXN0OiB7XG4gICAgICAgIHVzZXI6IHtcbiAgICAgICAgICBmaXJzdE5hbWU6ICdEci4gSmFuZScsXG4gICAgICAgICAgbGFzdE5hbWU6ICdTbWl0aCcsXG4gICAgICAgICAgZW1haWw6ICdqYW5lQGV4YW1wbGUuY29tJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIG1lZXRpbmcgZm9yIHZhbGlkIHRoZXJhcGlzdCBhY2Nlc3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAocHJpc21hU2VydmljZS5tZWV0aW5nLmZpbmRVbmlxdWUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShcbiAgICAgICAgbW9ja01lZXRpbmcsXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLmdldE1lZXRpbmcoXG4gICAgICAgICdtZWV0aW5nLWlkJyxcbiAgICAgICAgVEVTVF9VU0VSX0lEUy5USEVSQVBJU1QsXG4gICAgICAgICd0aGVyYXBpc3QnLFxuICAgICAgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrTWVldGluZyk7XG4gICAgICBleHBlY3QocHJpc21hU2VydmljZS5tZWV0aW5nLmZpbmRVbmlxdWUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgd2hlcmU6IHsgaWQ6ICdtZWV0aW5nLWlkJyB9LFxuICAgICAgICBpbmNsdWRlOiBleHBlY3QuYW55KE9iamVjdCksXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIG1lZXRpbmcgZm9yIHZhbGlkIGNsaWVudCBhY2Nlc3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAocHJpc21hU2VydmljZS5tZWV0aW5nLmZpbmRVbmlxdWUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShcbiAgICAgICAgbW9ja01lZXRpbmcsXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLmdldE1lZXRpbmcoXG4gICAgICAgICdtZWV0aW5nLWlkJyxcbiAgICAgICAgVEVTVF9VU0VSX0lEUy5DTElFTlQsXG4gICAgICAgICdjbGllbnQnLFxuICAgICAgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrTWVldGluZyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IE5vdEZvdW5kRXhjZXB0aW9uIHdoZW4gbWVldGluZyBkb2VzIG5vdCBleGlzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIChwcmlzbWFTZXJ2aWNlLm1lZXRpbmcuZmluZFVuaXF1ZSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIHNlcnZpY2UuZ2V0TWVldGluZygnbm9uLWV4aXN0ZW50LWlkJywgVEVTVF9VU0VSX0lEUy5DTElFTlQsICdjbGllbnQnKSxcbiAgICAgICkucmVqZWN0cy50b1Rocm93KE5vdEZvdW5kRXhjZXB0aW9uKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgRm9yYmlkZGVuRXhjZXB0aW9uIHdoZW4gdGhlcmFwaXN0IGFjY2Vzc2VzIHdyb25nIG1lZXRpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB3cm9uZ01lZXRpbmcgPSB7XG4gICAgICAgIC4uLm1vY2tNZWV0aW5nLFxuICAgICAgICB0aGVyYXBpc3RJZDogJ2RpZmZlcmVudC10aGVyYXBpc3QtaWQnLFxuICAgICAgfTtcbiAgICAgIChwcmlzbWFTZXJ2aWNlLm1lZXRpbmcuZmluZFVuaXF1ZSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKFxuICAgICAgICB3cm9uZ01lZXRpbmcsXG4gICAgICApO1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIHNlcnZpY2UuZ2V0TWVldGluZygnbWVldGluZy1pZCcsIFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNULCAndGhlcmFwaXN0JyksXG4gICAgICApLnJlamVjdHMudG9UaHJvdyhGb3JiaWRkZW5FeGNlcHRpb24pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBGb3JiaWRkZW5FeGNlcHRpb24gd2hlbiBjbGllbnQgYWNjZXNzZXMgd3JvbmcgbWVldGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHdyb25nTWVldGluZyA9IHtcbiAgICAgICAgLi4ubW9ja01lZXRpbmcsXG4gICAgICAgIGNsaWVudElkOiAnZGlmZmVyZW50LWNsaWVudC1pZCcsXG4gICAgICB9O1xuICAgICAgKHByaXNtYVNlcnZpY2UubWVldGluZy5maW5kVW5pcXVlIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoXG4gICAgICAgIHdyb25nTWVldGluZyxcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgc2VydmljZS5nZXRNZWV0aW5nKCdtZWV0aW5nLWlkJywgVEVTVF9VU0VSX0lEUy5DTElFTlQsICdjbGllbnQnKSxcbiAgICAgICkucmVqZWN0cy50b1Rocm93KEZvcmJpZGRlbkV4Y2VwdGlvbik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd1cGRhdGVNZWV0aW5nJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tVcGRhdGVEdG8gPSB7XG4gICAgICBzdGFydFRpbWU6ICcyMDI0LTAxLTE1VDE0OjAwOjAwWicsXG4gICAgICBkdXJhdGlvbjogNjAsXG4gICAgICB0aGVyYXBpc3RJZDogVEVTVF9VU0VSX0lEUy5USEVSQVBJU1QsXG4gICAgICB0aXRsZTogJ1VwZGF0ZWQgU2Vzc2lvbicsXG4gICAgICBkZXNjcmlwdGlvbjogJ1VwZGF0ZWQgZGVzY3JpcHRpb24nLFxuICAgICAgc3RhdHVzOiAnQ09ORklSTUVEJyBhcyBNZWV0aW5nU3RhdHVzLFxuICAgIH07XG5cbiAgICBjb25zdCBtb2NrTWVldGluZyA9IHtcbiAgICAgIGlkOiAnbWVldGluZy1pZCcsXG4gICAgICBjbGllbnRJZDogVEVTVF9VU0VSX0lEUy5DTElFTlQsXG4gICAgICB0aGVyYXBpc3RJZDogVEVTVF9VU0VSX0lEUy5USEVSQVBJU1QsXG4gICAgICBzdGF0dXM6ICdTQ0hFRFVMRUQnIGFzIE1lZXRpbmdTdGF0dXMsXG4gICAgfTtcblxuICAgIGl0KCdzaG91bGQgc3VjY2Vzc2Z1bGx5IHVwZGF0ZSBhIG1lZXRpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkTWVldGluZyA9IHtcbiAgICAgICAgLi4ubW9ja01lZXRpbmcsXG4gICAgICAgIC4uLm1vY2tVcGRhdGVEdG8sXG4gICAgICB9O1xuXG4gICAgICBqZXN0LnNweU9uKHNlcnZpY2UsICdnZXRNZWV0aW5nJykubW9ja1Jlc29sdmVkVmFsdWUobW9ja01lZXRpbmcgYXMgYW55KTtcbiAgICAgIChwcmlzbWFTZXJ2aWNlLm1lZXRpbmcudXBkYXRlIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoXG4gICAgICAgIHVwZGF0ZWRNZWV0aW5nIGFzIGFueSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcnZpY2UudXBkYXRlTWVldGluZyhcbiAgICAgICAgJ21lZXRpbmctaWQnLFxuICAgICAgICBtb2NrVXBkYXRlRHRvLFxuICAgICAgICBURVNUX1VTRVJfSURTLkNMSUVOVCxcbiAgICAgICAgJ2NsaWVudCcsXG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHVwZGF0ZWRNZWV0aW5nKTtcbiAgICAgIGV4cGVjdChwcmlzbWFTZXJ2aWNlLm1lZXRpbmcudXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIHdoZXJlOiB7IGlkOiAnbWVldGluZy1pZCcgfSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHRpdGxlOiBtb2NrVXBkYXRlRHRvLnRpdGxlLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBtb2NrVXBkYXRlRHRvLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIHN0YXJ0VGltZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGR1cmF0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgbWVldGluZ1R5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICB0aGVyYXBpc3RJZDogdW5kZWZpbmVkLFxuICAgICAgICAgIHN0YXR1czogbW9ja1VwZGF0ZUR0by5zdGF0dXMsXG4gICAgICAgIH0sXG4gICAgICAgIGluY2x1ZGU6IGV4cGVjdC5hbnkoT2JqZWN0KSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBCYWRSZXF1ZXN0RXhjZXB0aW9uIHdoZW4gdHJ5aW5nIHRvIHVwZGF0ZSBjb21wbGV0ZWQgbWVldGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBsZXRlZE1lZXRpbmcgPSB7XG4gICAgICAgIC4uLm1vY2tNZWV0aW5nLFxuICAgICAgICBzdGF0dXM6ICdDT01QTEVURUQnIGFzIE1lZXRpbmdTdGF0dXMsXG4gICAgICB9O1xuXG4gICAgICBqZXN0XG4gICAgICAgIC5zcHlPbihzZXJ2aWNlLCAnZ2V0TWVldGluZycpXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZShjb21wbGV0ZWRNZWV0aW5nIGFzIGFueSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgc2VydmljZS51cGRhdGVNZWV0aW5nKFxuICAgICAgICAgICdtZWV0aW5nLWlkJyxcbiAgICAgICAgICBtb2NrVXBkYXRlRHRvLFxuICAgICAgICAgIFRFU1RfVVNFUl9JRFMuQ0xJRU5ULFxuICAgICAgICAgICdjbGllbnQnLFxuICAgICAgICApLFxuICAgICAgKS5yZWplY3RzLnRvVGhyb3coQmFkUmVxdWVzdEV4Y2VwdGlvbik7XG5cbiAgICAgIGV4cGVjdChwcmlzbWFTZXJ2aWNlLm1lZXRpbmcudXBkYXRlKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBCYWRSZXF1ZXN0RXhjZXB0aW9uIHdoZW4gdHJ5aW5nIHRvIHVwZGF0ZSBjYW5jZWxsZWQgbWVldGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbmNlbGxlZE1lZXRpbmcgPSB7XG4gICAgICAgIC4uLm1vY2tNZWV0aW5nLFxuICAgICAgICBzdGF0dXM6ICdDQU5DRUxMRUQnIGFzIE1lZXRpbmdTdGF0dXMsXG4gICAgICB9O1xuXG4gICAgICBqZXN0XG4gICAgICAgIC5zcHlPbihzZXJ2aWNlLCAnZ2V0TWVldGluZycpXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZShjYW5jZWxsZWRNZWV0aW5nIGFzIGFueSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgc2VydmljZS51cGRhdGVNZWV0aW5nKFxuICAgICAgICAgICdtZWV0aW5nLWlkJyxcbiAgICAgICAgICBtb2NrVXBkYXRlRHRvLFxuICAgICAgICAgIFRFU1RfVVNFUl9JRFMuQ0xJRU5ULFxuICAgICAgICAgICdjbGllbnQnLFxuICAgICAgICApLFxuICAgICAgKS5yZWplY3RzLnRvVGhyb3coQmFkUmVxdWVzdEV4Y2VwdGlvbik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdjYW5jZWxNZWV0aW5nJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tNZWV0aW5nID0ge1xuICAgICAgaWQ6ICdtZWV0aW5nLWlkJyxcbiAgICAgIGNsaWVudElkOiBURVNUX1VTRVJfSURTLkNMSUVOVCxcbiAgICAgIHRoZXJhcGlzdElkOiBURVNUX1VTRVJfSURTLlRIRVJBUElTVCxcbiAgICAgIHN0YXR1czogJ1NDSEVEVUxFRCcgYXMgTWVldGluZ1N0YXR1cyxcbiAgICB9O1xuXG4gICAgaXQoJ3Nob3VsZCBzdWNjZXNzZnVsbHkgY2FuY2VsIGEgbWVldGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbmNlbGxlZE1lZXRpbmcgPSB7XG4gICAgICAgIC4uLm1vY2tNZWV0aW5nLFxuICAgICAgICBzdGF0dXM6ICdDQU5DRUxMRUQnIGFzIE1lZXRpbmdTdGF0dXMsXG4gICAgICB9O1xuXG4gICAgICBqZXN0LnNweU9uKHNlcnZpY2UsICdnZXRNZWV0aW5nJykubW9ja1Jlc29sdmVkVmFsdWUobW9ja01lZXRpbmcgYXMgYW55KTtcbiAgICAgIChwcmlzbWFTZXJ2aWNlLm1lZXRpbmcudXBkYXRlIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoXG4gICAgICAgIGNhbmNlbGxlZE1lZXRpbmcgYXMgYW55LFxuICAgICAgKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VydmljZS5jYW5jZWxNZWV0aW5nKFxuICAgICAgICAnbWVldGluZy1pZCcsXG4gICAgICAgIFRFU1RfVVNFUl9JRFMuQ0xJRU5ULFxuICAgICAgICAnY2xpZW50JyxcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoY2FuY2VsbGVkTWVldGluZyk7XG4gICAgICBleHBlY3QocHJpc21hU2VydmljZS5tZWV0aW5nLnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB3aGVyZTogeyBpZDogJ21lZXRpbmctaWQnIH0sXG4gICAgICAgIGRhdGE6IHsgc3RhdHVzOiAnQ0FOQ0VMTEVEJyB9LFxuICAgICAgICBpbmNsdWRlOiBleHBlY3QuYW55KE9iamVjdCksXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgQmFkUmVxdWVzdEV4Y2VwdGlvbiB3aGVuIG1lZXRpbmcgaXMgYWxyZWFkeSBjYW5jZWxsZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjYW5jZWxsZWRNZWV0aW5nID0ge1xuICAgICAgICAuLi5tb2NrTWVldGluZyxcbiAgICAgICAgc3RhdHVzOiAnQ0FOQ0VMTEVEJyBhcyBNZWV0aW5nU3RhdHVzLFxuICAgICAgfTtcblxuICAgICAgamVzdFxuICAgICAgICAuc3B5T24oc2VydmljZSwgJ2dldE1lZXRpbmcnKVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWUoY2FuY2VsbGVkTWVldGluZyBhcyBhbnkpO1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIHNlcnZpY2UuY2FuY2VsTWVldGluZygnbWVldGluZy1pZCcsIFRFU1RfVVNFUl9JRFMuQ0xJRU5ULCAnY2xpZW50JyksXG4gICAgICApLnJlamVjdHMudG9UaHJvdyhCYWRSZXF1ZXN0RXhjZXB0aW9uKTtcblxuICAgICAgZXhwZWN0KHByaXNtYVNlcnZpY2UubWVldGluZy51cGRhdGUpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IEJhZFJlcXVlc3RFeGNlcHRpb24gd2hlbiB0cnlpbmcgdG8gY2FuY2VsIGNvbXBsZXRlZCBtZWV0aW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29tcGxldGVkTWVldGluZyA9IHtcbiAgICAgICAgLi4ubW9ja01lZXRpbmcsXG4gICAgICAgIHN0YXR1czogJ0NPTVBMRVRFRCcgYXMgTWVldGluZ1N0YXR1cyxcbiAgICAgIH07XG5cbiAgICAgIGplc3RcbiAgICAgICAgLnNweU9uKHNlcnZpY2UsICdnZXRNZWV0aW5nJylcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlKGNvbXBsZXRlZE1lZXRpbmcgYXMgYW55KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBzZXJ2aWNlLmNhbmNlbE1lZXRpbmcoJ21lZXRpbmctaWQnLCBURVNUX1VTRVJfSURTLkNMSUVOVCwgJ2NsaWVudCcpLFxuICAgICAgKS5yZWplY3RzLnRvVGhyb3coQmFkUmVxdWVzdEV4Y2VwdGlvbik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdjcmVhdGVBdmFpbGFiaWxpdHknLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja0NyZWF0ZUF2YWlsYWJpbGl0eUR0byA9IHtcbiAgICAgIGRheU9mV2VlazogMSwgLy8gTW9uZGF5XG4gICAgICBzdGFydFRpbWU6ICcwOTowMCcsXG4gICAgICBlbmRUaW1lOiAnMTc6MDAnLFxuICAgICAgbm90ZXM6ICdSZWd1bGFyIGF2YWlsYWJpbGl0eScsXG4gICAgfTtcblxuICAgIGl0KCdzaG91bGQgc3VjY2Vzc2Z1bGx5IGNyZWF0ZSBhdmFpbGFiaWxpdHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBleHBlY3RlZEF2YWlsYWJpbGl0eSA9IHtcbiAgICAgICAgaWQ6ICdhdmFpbGFiaWxpdHktaWQnLFxuICAgICAgICB0aGVyYXBpc3RJZDogVEVTVF9VU0VSX0lEUy5USEVSQVBJU1QsXG4gICAgICAgIC4uLm1vY2tDcmVhdGVBdmFpbGFiaWxpdHlEdG8sXG4gICAgICB9O1xuXG4gICAgICAoXG4gICAgICAgIHByaXNtYVNlcnZpY2UudGhlcmFwaXN0QXZhaWxhYmlsaXR5LmZpbmRGaXJzdCBhcyBqZXN0Lk1vY2tcbiAgICAgICkubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7IC8vIE5vIG92ZXJsYXBcbiAgICAgIChcbiAgICAgICAgcHJpc21hU2VydmljZS50aGVyYXBpc3RBdmFpbGFiaWxpdHkuY3JlYXRlIGFzIGplc3QuTW9ja1xuICAgICAgKS5tb2NrUmVzb2x2ZWRWYWx1ZShleHBlY3RlZEF2YWlsYWJpbGl0eSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcnZpY2UuY3JlYXRlQXZhaWxhYmlsaXR5KFxuICAgICAgICBtb2NrQ3JlYXRlQXZhaWxhYmlsaXR5RHRvLFxuICAgICAgICBURVNUX1VTRVJfSURTLlRIRVJBUElTVCxcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoZXhwZWN0ZWRBdmFpbGFiaWxpdHkpO1xuICAgICAgZXhwZWN0KHByaXNtYVNlcnZpY2UudGhlcmFwaXN0QXZhaWxhYmlsaXR5LmNyZWF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdGhlcmFwaXN0SWQ6IFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNULFxuICAgICAgICAgIC4uLm1vY2tDcmVhdGVBdmFpbGFiaWxpdHlEdG8sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgQmFkUmVxdWVzdEV4Y2VwdGlvbiBmb3IgaW52YWxpZCB0aW1lIGZvcm1hdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWREdG8gPSB7XG4gICAgICAgIC4uLm1vY2tDcmVhdGVBdmFpbGFiaWxpdHlEdG8sXG4gICAgICAgIHN0YXJ0VGltZTogJzI1OjAwJywgLy8gSW52YWxpZCBob3VyXG4gICAgICB9O1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIHNlcnZpY2UuY3JlYXRlQXZhaWxhYmlsaXR5KGludmFsaWREdG8sIFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNUKSxcbiAgICAgICkucmVqZWN0cy50b1Rocm93KEJhZFJlcXVlc3RFeGNlcHRpb24pO1xuXG4gICAgICBleHBlY3QoXG4gICAgICAgIHByaXNtYVNlcnZpY2UudGhlcmFwaXN0QXZhaWxhYmlsaXR5LmZpbmRGaXJzdCxcbiAgICAgICkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgQmFkUmVxdWVzdEV4Y2VwdGlvbiB3aGVuIHN0YXJ0IHRpbWUgaXMgYWZ0ZXIgZW5kIHRpbWUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkRHRvID0ge1xuICAgICAgICAuLi5tb2NrQ3JlYXRlQXZhaWxhYmlsaXR5RHRvLFxuICAgICAgICBzdGFydFRpbWU6ICcxNzowMCcsXG4gICAgICAgIGVuZFRpbWU6ICcwOTowMCcsXG4gICAgICB9O1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIHNlcnZpY2UuY3JlYXRlQXZhaWxhYmlsaXR5KGludmFsaWREdG8sIFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNUKSxcbiAgICAgICkucmVqZWN0cy50b1Rocm93KEJhZFJlcXVlc3RFeGNlcHRpb24pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBCYWRSZXF1ZXN0RXhjZXB0aW9uIHdoZW4gYXZhaWxhYmlsaXR5IG92ZXJsYXBzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdBdmFpbGFiaWxpdHkgPSB7XG4gICAgICAgIGlkOiAnZXhpc3RpbmctaWQnLFxuICAgICAgICBzdGFydFRpbWU6ICcxMDowMCcsXG4gICAgICAgIGVuZFRpbWU6ICcxNjowMCcsXG4gICAgICB9O1xuXG4gICAgICAoXG4gICAgICAgIHByaXNtYVNlcnZpY2UudGhlcmFwaXN0QXZhaWxhYmlsaXR5LmZpbmRGaXJzdCBhcyBqZXN0Lk1vY2tcbiAgICAgICkubW9ja1Jlc29sdmVkVmFsdWUob3ZlcmxhcHBpbmdBdmFpbGFiaWxpdHkpO1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIHNlcnZpY2UuY3JlYXRlQXZhaWxhYmlsaXR5KFxuICAgICAgICAgIG1vY2tDcmVhdGVBdmFpbGFiaWxpdHlEdG8sXG4gICAgICAgICAgVEVTVF9VU0VSX0lEUy5USEVSQVBJU1QsXG4gICAgICAgICksXG4gICAgICApLnJlamVjdHMudG9UaHJvdyhCYWRSZXF1ZXN0RXhjZXB0aW9uKTtcblxuICAgICAgZXhwZWN0KHByaXNtYVNlcnZpY2UudGhlcmFwaXN0QXZhaWxhYmlsaXR5LmNyZWF0ZSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldEF2YWlsYWJpbGl0eScsICgpID0+IHtcbiAgICBjb25zdCBtb2NrQXZhaWxhYmlsaXRpZXMgPSBbXG4gICAgICB7XG4gICAgICAgIGlkOiAnYXZhaWxhYmlsaXR5LTEnLFxuICAgICAgICB0aGVyYXBpc3RJZDogVEVTVF9VU0VSX0lEUy5USEVSQVBJU1QsXG4gICAgICAgIGRheU9mV2VlazogMSxcbiAgICAgICAgc3RhcnRUaW1lOiAnMDk6MDAnLFxuICAgICAgICBlbmRUaW1lOiAnMTI6MDAnLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6ICdhdmFpbGFiaWxpdHktMicsXG4gICAgICAgIHRoZXJhcGlzdElkOiBURVNUX1VTRVJfSURTLlRIRVJBUElTVCxcbiAgICAgICAgZGF5T2ZXZWVrOiAxLFxuICAgICAgICBzdGFydFRpbWU6ICcxMzowMCcsXG4gICAgICAgIGVuZFRpbWU6ICcxNzowMCcsXG4gICAgICB9LFxuICAgIF07XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiB0aGVyYXBpc3QgYXZhaWxhYmlsaXR5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgKFxuICAgICAgICBwcmlzbWFTZXJ2aWNlLnRoZXJhcGlzdEF2YWlsYWJpbGl0eS5maW5kTWFueSBhcyBqZXN0Lk1vY2tcbiAgICAgICkubW9ja1Jlc29sdmVkVmFsdWUobW9ja0F2YWlsYWJpbGl0aWVzKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VydmljZS5nZXRBdmFpbGFiaWxpdHkoVEVTVF9VU0VSX0lEUy5USEVSQVBJU1QpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tBdmFpbGFiaWxpdGllcyk7XG4gICAgICBleHBlY3QocHJpc21hU2VydmljZS50aGVyYXBpc3RBdmFpbGFiaWxpdHkuZmluZE1hbnkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICB7XG4gICAgICAgICAgd2hlcmU6IHsgdGhlcmFwaXN0SWQ6IFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNUIH0sXG4gICAgICAgICAgb3JkZXJCeTogW3sgZGF5T2ZXZWVrOiAnYXNjJyB9LCB7IHN0YXJ0VGltZTogJ2FzYycgfV0sXG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgKFxuICAgICAgICBwcmlzbWFTZXJ2aWNlLnRoZXJhcGlzdEF2YWlsYWJpbGl0eS5maW5kTWFueSBhcyBqZXN0Lk1vY2tcbiAgICAgICkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdEYXRhYmFzZSBlcnJvcicpKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBzZXJ2aWNlLmdldEF2YWlsYWJpbGl0eShURVNUX1VTRVJfSURTLlRIRVJBUElTVCksXG4gICAgICApLnJlamVjdHMudG9UaHJvdyhCYWRSZXF1ZXN0RXhjZXB0aW9uKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3VwZGF0ZUF2YWlsYWJpbGl0eScsICgpID0+IHtcbiAgICBjb25zdCBtb2NrVXBkYXRlRHRvID0ge1xuICAgICAgZGF5T2ZXZWVrOiAxLFxuICAgICAgc3RhcnRUaW1lOiAnMTA6MDAnLFxuICAgICAgZW5kVGltZTogJzE2OjAwJyxcbiAgICAgIG5vdGVzOiAnVXBkYXRlZCBob3VycycsXG4gICAgfTtcblxuICAgIGl0KCdzaG91bGQgc3VjY2Vzc2Z1bGx5IHVwZGF0ZSBhdmFpbGFiaWxpdHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBleGlzdGluZ0F2YWlsYWJpbGl0eSA9IHtcbiAgICAgICAgaWQ6ICdhdmFpbGFiaWxpdHktaWQnLFxuICAgICAgICB0aGVyYXBpc3RJZDogVEVTVF9VU0VSX0lEUy5USEVSQVBJU1QsXG4gICAgICB9O1xuICAgICAgY29uc3QgdXBkYXRlZEF2YWlsYWJpbGl0eSA9IHtcbiAgICAgICAgLi4uZXhpc3RpbmdBdmFpbGFiaWxpdHksXG4gICAgICAgIC4uLm1vY2tVcGRhdGVEdG8sXG4gICAgICB9O1xuXG4gICAgICAoXG4gICAgICAgIHByaXNtYVNlcnZpY2UudGhlcmFwaXN0QXZhaWxhYmlsaXR5LmZpbmRGaXJzdCBhcyBqZXN0Lk1vY2tcbiAgICAgICkubW9ja1Jlc29sdmVkVmFsdWUoZXhpc3RpbmdBdmFpbGFiaWxpdHkpO1xuICAgICAgKFxuICAgICAgICBwcmlzbWFTZXJ2aWNlLnRoZXJhcGlzdEF2YWlsYWJpbGl0eS51cGRhdGUgYXMgamVzdC5Nb2NrXG4gICAgICApLm1vY2tSZXNvbHZlZFZhbHVlKHVwZGF0ZWRBdmFpbGFiaWxpdHkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLnVwZGF0ZUF2YWlsYWJpbGl0eShcbiAgICAgICAgJ2F2YWlsYWJpbGl0eS1pZCcsXG4gICAgICAgIG1vY2tVcGRhdGVEdG8sXG4gICAgICAgIFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNULFxuICAgICAgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh1cGRhdGVkQXZhaWxhYmlsaXR5KTtcbiAgICAgIGV4cGVjdChwcmlzbWFTZXJ2aWNlLnRoZXJhcGlzdEF2YWlsYWJpbGl0eS51cGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgd2hlcmU6IHsgaWQ6ICdhdmFpbGFiaWxpdHktaWQnIH0sXG4gICAgICAgIGRhdGE6IG1vY2tVcGRhdGVEdG8sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgTm90Rm91bmRFeGNlcHRpb24gd2hlbiBhdmFpbGFiaWxpdHkgZG9lcyBub3QgZXhpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAoXG4gICAgICAgIHByaXNtYVNlcnZpY2UudGhlcmFwaXN0QXZhaWxhYmlsaXR5LmZpbmRGaXJzdCBhcyBqZXN0Lk1vY2tcbiAgICAgICkubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgc2VydmljZS51cGRhdGVBdmFpbGFiaWxpdHkoXG4gICAgICAgICAgJ25vbi1leGlzdGVudC1pZCcsXG4gICAgICAgICAgbW9ja1VwZGF0ZUR0byxcbiAgICAgICAgICBURVNUX1VTRVJfSURTLlRIRVJBUElTVCxcbiAgICAgICAgKSxcbiAgICAgICkucmVqZWN0cy50b1Rocm93KE5vdEZvdW5kRXhjZXB0aW9uKTtcblxuICAgICAgZXhwZWN0KHByaXNtYVNlcnZpY2UudGhlcmFwaXN0QXZhaWxhYmlsaXR5LnVwZGF0ZSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2RlbGV0ZUF2YWlsYWJpbGl0eScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHN1Y2Nlc3NmdWxseSBkZWxldGUgYXZhaWxhYmlsaXR5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmdBdmFpbGFiaWxpdHkgPSB7XG4gICAgICAgIGlkOiAnYXZhaWxhYmlsaXR5LWlkJyxcbiAgICAgICAgdGhlcmFwaXN0SWQ6IFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNULFxuICAgICAgfTtcblxuICAgICAgKFxuICAgICAgICBwcmlzbWFTZXJ2aWNlLnRoZXJhcGlzdEF2YWlsYWJpbGl0eS5maW5kRmlyc3QgYXMgamVzdC5Nb2NrXG4gICAgICApLm1vY2tSZXNvbHZlZFZhbHVlKGV4aXN0aW5nQXZhaWxhYmlsaXR5KTtcbiAgICAgIChcbiAgICAgICAgcHJpc21hU2VydmljZS50aGVyYXBpc3RBdmFpbGFiaWxpdHkuZGVsZXRlIGFzIGplc3QuTW9ja1xuICAgICAgKS5tb2NrUmVzb2x2ZWRWYWx1ZShleGlzdGluZ0F2YWlsYWJpbGl0eSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcnZpY2UuZGVsZXRlQXZhaWxhYmlsaXR5KFxuICAgICAgICAnYXZhaWxhYmlsaXR5LWlkJyxcbiAgICAgICAgVEVTVF9VU0VSX0lEUy5USEVSQVBJU1QsXG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKGV4aXN0aW5nQXZhaWxhYmlsaXR5KTtcbiAgICAgIGV4cGVjdChwcmlzbWFTZXJ2aWNlLnRoZXJhcGlzdEF2YWlsYWJpbGl0eS5kZWxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgd2hlcmU6IHsgaWQ6ICdhdmFpbGFiaWxpdHktaWQnIH0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgTm90Rm91bmRFeGNlcHRpb24gd2hlbiBhdmFpbGFiaWxpdHkgZG9lcyBub3QgZXhpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAoXG4gICAgICAgIHByaXNtYVNlcnZpY2UudGhlcmFwaXN0QXZhaWxhYmlsaXR5LmZpbmRGaXJzdCBhcyBqZXN0Lk1vY2tcbiAgICAgICkubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgc2VydmljZS5kZWxldGVBdmFpbGFiaWxpdHkoJ25vbi1leGlzdGVudC1pZCcsIFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNUKSxcbiAgICAgICkucmVqZWN0cy50b1Rocm93KE5vdEZvdW5kRXhjZXB0aW9uKTtcblxuICAgICAgZXhwZWN0KHByaXNtYVNlcnZpY2UudGhlcmFwaXN0QXZhaWxhYmlsaXR5LmRlbGV0ZSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldEF2YWlsYWJsZVNsb3RzJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tEYXRlID0gJzIwMjQtMDEtMTUnOyAvLyBNb25kYXlcbiAgICBjb25zdCBtb2NrQXZhaWxhYmlsaXR5ID0gW1xuICAgICAge1xuICAgICAgICBpZDogJ2F2YWlsYWJpbGl0eS0xJyxcbiAgICAgICAgdGhlcmFwaXN0SWQ6IFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNULFxuICAgICAgICBkYXlPZldlZWs6IDEsIC8vIE1vbmRheVxuICAgICAgICBzdGFydFRpbWU6ICcwOTowMCcsXG4gICAgICAgIGVuZFRpbWU6ICcxNzowMCcsXG4gICAgICAgIGlzQXZhaWxhYmxlOiB0cnVlLFxuICAgICAgfSxcbiAgICBdO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gYXZhaWxhYmxlIHNsb3RzIHdoZW4gbm8gY29uZmxpY3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgKFxuICAgICAgICBwcmlzbWFTZXJ2aWNlLnRoZXJhcGlzdEF2YWlsYWJpbGl0eS5maW5kTWFueSBhcyBqZXN0Lk1vY2tcbiAgICAgICkubW9ja1Jlc29sdmVkVmFsdWUobW9ja0F2YWlsYWJpbGl0eSk7XG4gICAgICAocHJpc21hU2VydmljZS5tZWV0aW5nLmZpbmRNYW55IGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoW10pOyAvLyBObyBleGlzdGluZyBib29raW5nc1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLmdldEF2YWlsYWJsZVNsb3RzKFxuICAgICAgICBURVNUX1VTRVJfSURTLlRIRVJBUElTVCxcbiAgICAgICAgbW9ja0RhdGUsXG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KEFycmF5LmlzQXJyYXkocmVzdWx0KSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChwcmlzbWFTZXJ2aWNlLnRoZXJhcGlzdEF2YWlsYWJpbGl0eS5maW5kTWFueSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIHtcbiAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgdGhlcmFwaXN0SWQ6IFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNULFxuICAgICAgICAgICAgZGF5T2ZXZWVrOiAxLFxuICAgICAgICAgICAgaXNBdmFpbGFibGU6IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcmRlckJ5OiB7IHN0YXJ0VGltZTogJ2FzYycgfSxcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBlbXB0eSBhcnJheSB3aGVuIHRoZXJhcGlzdCBoYXMgbm8gYXZhaWxhYmlsaXR5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgKFxuICAgICAgICBwcmlzbWFTZXJ2aWNlLnRoZXJhcGlzdEF2YWlsYWJpbGl0eS5maW5kTWFueSBhcyBqZXN0Lk1vY2tcbiAgICAgICkubW9ja1Jlc29sdmVkVmFsdWUoW10pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLmdldEF2YWlsYWJsZVNsb3RzKFxuICAgICAgICBURVNUX1VTRVJfSURTLlRIRVJBUElTVCxcbiAgICAgICAgbW9ja0RhdGUsXG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdChwcmlzbWFTZXJ2aWNlLm1lZXRpbmcuZmluZE1hbnkpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGV4Y2x1ZGUgY29uZmxpY3RpbmcgdGltZSBzbG90cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nQm9va2luZyA9IHtcbiAgICAgICAgaWQ6ICdib29raW5nLTEnLFxuICAgICAgICBzdGFydFRpbWU6IG5ldyBEYXRlKCcyMDI0LTAxLTE1VDEwOjAwOjAwWicpLFxuICAgICAgICBkdXJhdGlvbjogNjAsXG4gICAgICAgIHN0YXR1czogJ1NDSEVEVUxFRCcgYXMgTWVldGluZ1N0YXR1cyxcbiAgICAgIH07XG5cbiAgICAgIChcbiAgICAgICAgcHJpc21hU2VydmljZS50aGVyYXBpc3RBdmFpbGFiaWxpdHkuZmluZE1hbnkgYXMgamVzdC5Nb2NrXG4gICAgICApLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tBdmFpbGFiaWxpdHkpO1xuICAgICAgKHByaXNtYVNlcnZpY2UubWVldGluZy5maW5kTWFueSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKFtcbiAgICAgICAgZXhpc3RpbmdCb29raW5nLFxuICAgICAgXSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcnZpY2UuZ2V0QXZhaWxhYmxlU2xvdHMoXG4gICAgICAgIFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNULFxuICAgICAgICBtb2NrRGF0ZSxcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocHJpc21hU2VydmljZS5tZWV0aW5nLmZpbmRNYW55KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgdGhlcmFwaXN0SWQ6IFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNULFxuICAgICAgICAgIHN0YXJ0VGltZToge1xuICAgICAgICAgICAgZ3RlOiBleHBlY3QuYW55KERhdGUpLFxuICAgICAgICAgICAgbHRlOiBleHBlY3QuYW55KERhdGUpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RhdHVzOiB7IGluOiBbJ1NDSEVEVUxFRCcsICdDT05GSVJNRUQnXSB9LFxuICAgICAgICB9LFxuICAgICAgICBvcmRlckJ5OiB7IHN0YXJ0VGltZTogJ2FzYycgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndmFsaWRhdGVNZWV0aW5nVGltZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIG1lZXRpbmcgdGltZSBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQXZhaWxhYmlsaXR5ID0ge1xuICAgICAgICBpZDogJ2F2YWlsYWJpbGl0eS1pZCcsXG4gICAgICAgIHRoZXJhcGlzdElkOiBURVNUX1VTRVJfSURTLlRIRVJBUElTVCxcbiAgICAgICAgZGF5T2ZXZWVrOiAxLFxuICAgICAgICBzdGFydFRpbWU6ICcwOTowMCcsXG4gICAgICAgIGVuZFRpbWU6ICcxNzowMCcsXG4gICAgICAgIGlzQXZhaWxhYmxlOiB0cnVlLFxuICAgICAgfTtcblxuICAgICAgKFxuICAgICAgICBwcmlzbWFTZXJ2aWNlLnRoZXJhcGlzdEF2YWlsYWJpbGl0eS5maW5kRmlyc3QgYXMgamVzdC5Nb2NrXG4gICAgICApLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tBdmFpbGFiaWxpdHkpO1xuICAgICAgKHByaXNtYVNlcnZpY2UubWVldGluZy5maW5kTWFueSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKFtdKTsgLy8gTm8gY29uZmxpY3RzXG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgc2VydmljZS52YWxpZGF0ZU1lZXRpbmdUaW1lKFxuICAgICAgICAgIFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNULFxuICAgICAgICAgIFRFU1RfVVNFUl9JRFMuQ0xJRU5ULFxuICAgICAgICAgICcyMDI0LTAxLTE1VDE0OjAwOjAwWicsXG4gICAgICAgICAgNjAsXG4gICAgICAgICksXG4gICAgICApLnJlc29sdmVzLm5vdC50b1Rocm93KCk7XG5cbiAgICAgIGV4cGVjdChwcmlzbWFTZXJ2aWNlLnRoZXJhcGlzdEF2YWlsYWJpbGl0eS5maW5kRmlyc3QpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChwcmlzbWFTZXJ2aWNlLm1lZXRpbmcuZmluZE1hbnkpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgQmFkUmVxdWVzdEV4Y2VwdGlvbiBmb3IgaW52YWxpZCBkdXJhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgc2VydmljZS52YWxpZGF0ZU1lZXRpbmdUaW1lKFxuICAgICAgICAgIFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNULFxuICAgICAgICAgIFRFU1RfVVNFUl9JRFMuQ0xJRU5ULFxuICAgICAgICAgICcyMDI0LTAxLTE1VDE0OjAwOjAwWicsXG4gICAgICAgICAgOTk5LCAvLyBJbnZhbGlkIGR1cmF0aW9uXG4gICAgICAgICksXG4gICAgICApLnJlamVjdHMudG9UaHJvdyhCYWRSZXF1ZXN0RXhjZXB0aW9uKTtcblxuICAgICAgZXhwZWN0KFxuICAgICAgICBwcmlzbWFTZXJ2aWNlLnRoZXJhcGlzdEF2YWlsYWJpbGl0eS5maW5kRmlyc3QsXG4gICAgICApLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IEJhZFJlcXVlc3RFeGNlcHRpb24gd2hlbiB0aGVyYXBpc3Qgbm90IGF2YWlsYWJsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIChcbiAgICAgICAgcHJpc21hU2VydmljZS50aGVyYXBpc3RBdmFpbGFiaWxpdHkuZmluZEZpcnN0IGFzIGplc3QuTW9ja1xuICAgICAgKS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBzZXJ2aWNlLnZhbGlkYXRlTWVldGluZ1RpbWUoXG4gICAgICAgICAgVEVTVF9VU0VSX0lEUy5USEVSQVBJU1QsXG4gICAgICAgICAgVEVTVF9VU0VSX0lEUy5DTElFTlQsXG4gICAgICAgICAgJzIwMjQtMDEtMTVUMTQ6MDA6MDBaJyxcbiAgICAgICAgICA2MCxcbiAgICAgICAgKSxcbiAgICAgICkucmVqZWN0cy50b1Rocm93KEJhZFJlcXVlc3RFeGNlcHRpb24pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBCYWRSZXF1ZXN0RXhjZXB0aW9uIGZvciBzY2hlZHVsaW5nIGNvbmZsaWN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tBdmFpbGFiaWxpdHkgPSB7XG4gICAgICAgIGlkOiAnYXZhaWxhYmlsaXR5LWlkJyxcbiAgICAgICAgdGhlcmFwaXN0SWQ6IFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNULFxuICAgICAgICBkYXlPZldlZWs6IDEsXG4gICAgICAgIHN0YXJ0VGltZTogJzA5OjAwJyxcbiAgICAgICAgZW5kVGltZTogJzE3OjAwJyxcbiAgICAgICAgaXNBdmFpbGFibGU6IHRydWUsXG4gICAgICB9O1xuICAgICAgY29uc3QgY29uZmxpY3RpbmdNZWV0aW5nID0ge1xuICAgICAgICBpZDogJ2NvbmZsaWN0LWlkJyxcbiAgICAgICAgc3RhcnRUaW1lOiBuZXcgRGF0ZSgnMjAyNC0wMS0xNVQxNDozMDowMFonKSxcbiAgICAgICAgZHVyYXRpb246IDYwLFxuICAgICAgICBzdGF0dXM6ICdTQ0hFRFVMRUQnIGFzIE1lZXRpbmdTdGF0dXMsXG4gICAgICB9O1xuXG4gICAgICAoXG4gICAgICAgIHByaXNtYVNlcnZpY2UudGhlcmFwaXN0QXZhaWxhYmlsaXR5LmZpbmRGaXJzdCBhcyBqZXN0Lk1vY2tcbiAgICAgICkubW9ja1Jlc29sdmVkVmFsdWUobW9ja0F2YWlsYWJpbGl0eSk7XG4gICAgICAocHJpc21hU2VydmljZS5tZWV0aW5nLmZpbmRNYW55IGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoW1xuICAgICAgICBjb25mbGljdGluZ01lZXRpbmcsXG4gICAgICBdKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBzZXJ2aWNlLnZhbGlkYXRlTWVldGluZ1RpbWUoXG4gICAgICAgICAgVEVTVF9VU0VSX0lEUy5USEVSQVBJU1QsXG4gICAgICAgICAgVEVTVF9VU0VSX0lEUy5DTElFTlQsXG4gICAgICAgICAgJzIwMjQtMDEtMTVUMTQ6MDA6MDBaJyxcbiAgICAgICAgICA2MCxcbiAgICAgICAgKSxcbiAgICAgICkucmVqZWN0cy50b1Rocm93KEJhZFJlcXVlc3RFeGNlcHRpb24pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRWRnZSBDYXNlcyBhbmQgRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgY29ubmVjdGlvbiBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAocHJpc21hU2VydmljZS5tZWV0aW5nLmZpbmRNYW55IGFzIGplc3QuTW9jaykubW9ja1JlamVjdGVkVmFsdWUoXG4gICAgICAgIG5ldyBFcnJvcignQ29ubmVjdGlvbiB0aW1lb3V0JyksXG4gICAgICApO1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIHNlcnZpY2UuZ2V0TWVldGluZ3MoVEVTVF9VU0VSX0lEUy5DTElFTlQsICdjbGllbnQnKSxcbiAgICAgICkucmVqZWN0cy50b1Rocm93KEJhZFJlcXVlc3RFeGNlcHRpb24pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgaW52YWxpZCBtZWV0aW5nIHN0YXR1cyB0cmFuc2l0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tNZWV0aW5nID0ge1xuICAgICAgICBpZDogJ21lZXRpbmctaWQnLFxuICAgICAgICBzdGF0dXM6ICdDT01QTEVURUQnIGFzIE1lZXRpbmdTdGF0dXMsXG4gICAgICAgIGNsaWVudElkOiBURVNUX1VTRVJfSURTLkNMSUVOVCxcbiAgICAgICAgdGhlcmFwaXN0SWQ6IFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNULFxuICAgICAgfTtcblxuICAgICAgamVzdC5zcHlPbihzZXJ2aWNlLCAnZ2V0TWVldGluZycpLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tNZWV0aW5nIGFzIGFueSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgc2VydmljZS51cGRhdGVNZWV0aW5nKFxuICAgICAgICAgICdtZWV0aW5nLWlkJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGFydFRpbWU6ICcyMDI0LTAxLTE1VDE0OjAwOjAwWicsXG4gICAgICAgICAgICBkdXJhdGlvbjogNjAsXG4gICAgICAgICAgICB0aGVyYXBpc3RJZDogVEVTVF9VU0VSX0lEUy5USEVSQVBJU1QsXG4gICAgICAgICAgICB0aXRsZTogJ1Rlc3QgU2Vzc2lvbicsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1Rlc3QgZGVzY3JpcHRpb24nLFxuICAgICAgICAgICAgc3RhdHVzOiAnU0NIRURVTEVEJyBhcyBNZWV0aW5nU3RhdHVzLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgVEVTVF9VU0VSX0lEUy5DTElFTlQsXG4gICAgICAgICAgJ2NsaWVudCcsXG4gICAgICAgICksXG4gICAgICApLnJlamVjdHMudG9UaHJvdyhCYWRSZXF1ZXN0RXhjZXB0aW9uKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHRpbWV6b25lIGVkZ2UgY2FzZXMgaW4gc2xvdCBjYWxjdWxhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tBdmFpbGFiaWxpdHkgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ2F2YWlsYWJpbGl0eS0xJyxcbiAgICAgICAgICB0aGVyYXBpc3RJZDogVEVTVF9VU0VSX0lEUy5USEVSQVBJU1QsXG4gICAgICAgICAgZGF5T2ZXZWVrOiAxLFxuICAgICAgICAgIHN0YXJ0VGltZTogJzIzOjMwJywgLy8gTmVhciBtaWRuaWdodFxuICAgICAgICAgIGVuZFRpbWU6ICcyMzo1OScsXG4gICAgICAgICAgaXNBdmFpbGFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICAoXG4gICAgICAgIHByaXNtYVNlcnZpY2UudGhlcmFwaXN0QXZhaWxhYmlsaXR5LmZpbmRNYW55IGFzIGplc3QuTW9ja1xuICAgICAgKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQXZhaWxhYmlsaXR5KTtcbiAgICAgIChwcmlzbWFTZXJ2aWNlLm1lZXRpbmcuZmluZE1hbnkgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcnZpY2UuZ2V0QXZhaWxhYmxlU2xvdHMoXG4gICAgICAgIFRFU1RfVVNFUl9JRFMuVEhFUkFQSVNULFxuICAgICAgICAnMjAyNC0wMS0xNScsXG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KEFycmF5LmlzQXJyYXkocmVzdWx0KSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJ2ZXJzaW9uIjozfQ==