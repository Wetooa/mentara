f9e0a6c7b9fbbb1fc1df12f5fd470326
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConflictDetectionService = void 0;
const common_1 = require("@nestjs/common");
const prisma_client_provider_1 = require("../../providers/prisma-client.provider");
let ConflictDetectionService = class ConflictDetectionService {
    prisma;
    constructor(prisma) {
        this.prisma = prisma;
    }
    /**
     * Check for scheduling conflicts for both therapist and client
     */
    async checkSchedulingConflicts(therapistId, clientId, startTime, duration) {
        const endTime = new Date(startTime.getTime() + duration * 60 * 1000);
        const timeRange = { startTime, endTime };
        const [therapistConflicts, clientConflicts] = await Promise.all([
            this.checkTherapistConflicts(therapistId, timeRange),
            this.checkClientConflicts(clientId, timeRange),
        ]);
        const hasConflict = therapistConflicts.length > 0 || clientConflicts.length > 0;
        let conflictType = 'none';
        if (therapistConflicts.length > 0 && clientConflicts.length > 0) {
            conflictType = 'both';
        }
        else if (therapistConflicts.length > 0) {
            conflictType = 'therapist';
        }
        else if (clientConflicts.length > 0) {
            conflictType = 'client';
        }
        return {
            hasConflict,
            conflictingMeetings: [...therapistConflicts, ...clientConflicts],
            conflictType,
        };
    }
    /**
     * Check for conflicts in therapist's schedule
     */
    async checkTherapistConflicts(therapistId, timeRange) {
        return this.findConflictingMeetings({
            therapistId,
            timeRange,
            statuses: ['SCHEDULED', 'CONFIRMED', 'IN_PROGRESS'],
        });
    }
    /**
     * Check for conflicts in client's schedule
     */
    async checkClientConflicts(clientId, timeRange) {
        return this.findConflictingMeetings({
            clientId,
            timeRange,
            statuses: ['SCHEDULED', 'CONFIRMED', 'IN_PROGRESS'],
        });
    }
    /**
     * Check if updating a meeting would cause conflicts
     */
    async checkUpdateConflicts(meetingId, therapistId, clientId, newStartTime, newDuration) {
        const endTime = new Date(newStartTime.getTime() + newDuration * 60 * 1000);
        const timeRange = { startTime: newStartTime, endTime };
        // Find conflicts excluding the current meeting
        const conflicts = await this.findConflictingMeetings({
            therapistId,
            clientId,
            timeRange,
            statuses: ['SCHEDULED', 'CONFIRMED', 'IN_PROGRESS'],
            excludeMeetingId: meetingId,
        });
        const therapistConflicts = conflicts.filter((m) => m.therapistId === therapistId);
        const clientConflicts = conflicts.filter((m) => m.clientId === clientId);
        const hasConflict = conflicts.length > 0;
        let conflictType = 'none';
        if (therapistConflicts.length > 0 && clientConflicts.length > 0) {
            conflictType = 'both';
        }
        else if (therapistConflicts.length > 0) {
            conflictType = 'therapist';
        }
        else if (clientConflicts.length > 0) {
            conflictType = 'client';
        }
        return {
            hasConflict,
            conflictingMeetings: conflicts,
            conflictType,
        };
    }
    /**
     * Check for conflicts when bulk scheduling multiple meetings
     */
    async checkBulkConflicts(meetings) {
        const conflicts = [];
        for (let i = 0; i < meetings.length; i++) {
            const meeting = meetings[i];
            // Check against existing meetings
            const existingConflicts = await this.checkSchedulingConflicts(meeting.therapistId, meeting.clientId, meeting.startTime, meeting.duration);
            // Check against other meetings in the bulk operation
            const internalConflicts = this.checkInternalConflicts(meeting, meetings, i);
            if (existingConflicts.hasConflict || internalConflicts.length > 0) {
                conflicts.push({
                    meetingIndex: i,
                    conflicts: {
                        hasConflict: true,
                        conflictingMeetings: [
                            ...existingConflicts.conflictingMeetings,
                            ...internalConflicts,
                        ],
                        conflictType: existingConflicts.conflictType,
                    },
                });
            }
        }
        return conflicts;
    }
    async findConflictingMeetings({ therapistId, clientId, timeRange, statuses, excludeMeetingId, }) {
        const whereConditions = [];
        // Add therapist condition
        if (therapistId) {
            whereConditions.push({
                therapistId,
                startTime: { lt: timeRange.endTime },
                // Use a computed endTime for proper overlap detection
                OR: [
                    {
                        // Meeting starts before our end time and hasn't ended yet
                        startTime: { gte: timeRange.startTime },
                    },
                    {
                        // Meeting started before our start time but extends into our time
                        startTime: { lt: timeRange.startTime },
                        // This is a bit complex in Prisma - we need to use raw SQL or compute endTime
                    },
                ],
                status: { in: statuses },
            });
        }
        // Add client condition
        if (clientId) {
            whereConditions.push({
                clientId,
                startTime: { lt: timeRange.endTime },
                OR: [
                    { startTime: { gte: timeRange.startTime } },
                    { startTime: { lt: timeRange.startTime } },
                ],
                status: { in: statuses },
            });
        }
        if (whereConditions.length === 0) {
            return [];
        }
        const meetings = await this.prisma.meeting.findMany({
            where: {
                OR: whereConditions,
                ...(excludeMeetingId && { id: { not: excludeMeetingId } }),
            },
            include: {
                client: {
                    select: {
                        user: {
                            select: { firstName: true, lastName: true },
                        },
                    },
                },
                therapist: {
                    select: {
                        user: {
                            select: { firstName: true, lastName: true },
                        },
                    },
                },
            },
        });
        // Filter meetings that actually overlap (since Prisma doesn't handle computed endTime well)
        return meetings.filter((meeting) => {
            const meetingEndTime = new Date(meeting.startTime.getTime() + meeting.duration * 60 * 1000);
            return this.hasTimeOverlap(timeRange.startTime, timeRange.endTime, meeting.startTime, meetingEndTime);
        });
    }
    checkInternalConflicts(currentMeeting, allMeetings, currentIndex) {
        const conflicts = [];
        const currentEndTime = new Date(currentMeeting.startTime.getTime() + currentMeeting.duration * 60 * 1000);
        for (let i = 0; i < allMeetings.length; i++) {
            if (i === currentIndex)
                continue;
            const otherMeeting = allMeetings[i];
            const otherEndTime = new Date(otherMeeting.startTime.getTime() + otherMeeting.duration * 60 * 1000);
            // Check if meetings involve the same people
            const sameTherapist = currentMeeting.therapistId === otherMeeting.therapistId;
            const sameClient = currentMeeting.clientId === otherMeeting.clientId;
            if ((sameTherapist || sameClient) &&
                this.hasTimeOverlap(currentMeeting.startTime, currentEndTime, otherMeeting.startTime, otherEndTime)) {
                conflicts.push({
                    ...otherMeeting,
                    conflictType: sameTherapist && sameClient
                        ? 'both'
                        : sameTherapist
                            ? 'therapist'
                            : 'client',
                    isInternalConflict: true,
                    conflictIndex: i,
                });
            }
        }
        return conflicts;
    }
    /**
     * Check if two time ranges overlap
     */
    hasTimeOverlap(start1, end1, start2, end2) {
        return start1 < end2 && end1 > start2;
    }
    /**
     * Validate that a proposed meeting time doesn't conflict
     * Throws BadRequestException if conflicts are found
     */
    async validateNoConflicts(therapistId, clientId, startTime, duration) {
        const conflicts = await this.checkSchedulingConflicts(therapistId, clientId, startTime, duration);
        if (conflicts.hasConflict) {
            const conflictMessages = conflicts.conflictingMeetings.map((meeting) => {
                const meetingStart = meeting.startTime.toLocaleString();
                const meetingEnd = new Date(meeting.startTime.getTime() + meeting.duration * 60000).toLocaleString();
                return `Meeting from ${meetingStart} to ${meetingEnd}`;
            });
            throw new common_1.BadRequestException(`Time slot conflicts with existing meetings: ${conflictMessages.join(', ')}`);
        }
    }
};
exports.ConflictDetectionService = ConflictDetectionService;
exports.ConflictDetectionService = ConflictDetectionService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [prisma_client_provider_1.PrismaService])
], ConflictDetectionService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvd2V0b29hL0RvY3VtZW50cy9jb2RlL3Byb2plY3RzL21lbnRhcmEvbWVudGFyYS1hcGkvc3JjL2Jvb2tpbmcvc2VydmljZXMvY29uZmxpY3QtZGV0ZWN0aW9uLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQWlFO0FBQ2pFLG1GQUF1RTtBQWNoRSxJQUFNLHdCQUF3QixHQUE5QixNQUFNLHdCQUF3QjtJQUNOO0lBQTdCLFlBQTZCLE1BQXFCO1FBQXJCLFdBQU0sR0FBTixNQUFNLENBQWU7SUFBRyxDQUFDO0lBRXREOztPQUVHO0lBQ0gsS0FBSyxDQUFDLHdCQUF3QixDQUM1QixXQUFtQixFQUNuQixRQUFnQixFQUNoQixTQUFlLEVBQ2YsUUFBZ0I7UUFFaEIsTUFBTSxPQUFPLEdBQUcsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxHQUFHLFFBQVEsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUM7UUFDckUsTUFBTSxTQUFTLEdBQUcsRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLENBQUM7UUFFekMsTUFBTSxDQUFDLGtCQUFrQixFQUFFLGVBQWUsQ0FBQyxHQUFHLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQztZQUM5RCxJQUFJLENBQUMsdUJBQXVCLENBQUMsV0FBVyxFQUFFLFNBQVMsQ0FBQztZQUNwRCxJQUFJLENBQUMsb0JBQW9CLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQztTQUMvQyxDQUFDLENBQUM7UUFFSCxNQUFNLFdBQVcsR0FDZixrQkFBa0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLGVBQWUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBQzlELElBQUksWUFBWSxHQUE2QyxNQUFNLENBQUM7UUFFcEUsSUFBSSxrQkFBa0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLGVBQWUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDaEUsWUFBWSxHQUFHLE1BQU0sQ0FBQztRQUN4QixDQUFDO2FB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LEtBQUssQ0FBQyxtQkFBbUIsQ0FDdkIsV0FBbUIsRUFDbkIsUUFBZ0IsRUFDaEIsU0FBZSxFQUNmLFFBQWdCO1FBRWhCLE1BQU0sU0FBUyxHQUFHLE1BQU0sSUFBSSxDQUFDLHdCQUF3QixDQUNuRCxXQUFXLEVBQ1gsUUFBUSxFQUNSLFNBQVMsRUFDVCxRQUFRLENBQ1QsQ0FBQztRQUVGLElBQUksU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQzFCLE1BQU0sZ0JBQWdCLEdBQUcsU0FBUyxDQUFDLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFO2dCQUNyRSxNQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLGNBQWMsRUFBRSxDQUFDO2dCQUN4RCxNQUFNLFVBQVUsR0FBRyxJQUFJLElBQUksQ0FDekIsT0FBTyxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsR0FBRyxPQUFPLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FDdkQsQ0FBQyxjQUFjLEVBQUUsQ0FBQztnQkFDbkIsT0FBTyxnQkFBZ0IsWUFBWSxPQUFPLFVBQVUsRUFBRSxDQUFDO1lBQ3pELENBQUMsQ0FBQyxDQUFDO1lBRUgsTUFBTSxJQUFJLDRCQUFtQixDQUMzQiwrQ0FBK0MsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQzdFLENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQztDQUNGLENBQUE7QUE1VlksNERBQXdCO21DQUF4Qix3QkFBd0I7SUFEcEMsSUFBQSxtQkFBVSxHQUFFO3FDQUUwQixzQ0FBYTtHQUR2Qyx3QkFBd0IsQ0E0VnBDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9ob21lL3dldG9vYS9Eb2N1bWVudHMvY29kZS9wcm9qZWN0cy9tZW50YXJhL21lbnRhcmEtYXBpL3NyYy9ib29raW5nL3NlcnZpY2VzL2NvbmZsaWN0LWRldGVjdGlvbi5zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEJhZFJlcXVlc3RFeGNlcHRpb24gfSBmcm9tICdAbmVzdGpzL2NvbW1vbic7XG5pbXBvcnQgeyBQcmlzbWFTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vcHJvdmlkZXJzL3ByaXNtYS1jbGllbnQucHJvdmlkZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVSYW5nZSB7XG4gIHN0YXJ0VGltZTogRGF0ZTtcbiAgZW5kVGltZTogRGF0ZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb25mbGljdFJlc3VsdCB7XG4gIGhhc0NvbmZsaWN0OiBib29sZWFuO1xuICBjb25mbGljdGluZ01lZXRpbmdzOiBhbnlbXTtcbiAgY29uZmxpY3RUeXBlOiAndGhlcmFwaXN0JyB8ICdjbGllbnQnIHwgJ2JvdGgnIHwgJ25vbmUnO1xufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ29uZmxpY3REZXRlY3Rpb25TZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwcmlzbWE6IFByaXNtYVNlcnZpY2UpIHt9XG5cbiAgLyoqXG4gICAqIENoZWNrIGZvciBzY2hlZHVsaW5nIGNvbmZsaWN0cyBmb3IgYm90aCB0aGVyYXBpc3QgYW5kIGNsaWVudFxuICAgKi9cbiAgYXN5bmMgY2hlY2tTY2hlZHVsaW5nQ29uZmxpY3RzKFxuICAgIHRoZXJhcGlzdElkOiBzdHJpbmcsXG4gICAgY2xpZW50SWQ6IHN0cmluZyxcbiAgICBzdGFydFRpbWU6IERhdGUsXG4gICAgZHVyYXRpb246IG51bWJlcixcbiAgKTogUHJvbWlzZTxDb25mbGljdFJlc3VsdD4ge1xuICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZShzdGFydFRpbWUuZ2V0VGltZSgpICsgZHVyYXRpb24gKiA2MCAqIDEwMDApO1xuICAgIGNvbnN0IHRpbWVSYW5nZSA9IHsgc3RhcnRUaW1lLCBlbmRUaW1lIH07XG5cbiAgICBjb25zdCBbdGhlcmFwaXN0Q29uZmxpY3RzLCBjbGllbnRDb25mbGljdHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5jaGVja1RoZXJhcGlzdENvbmZsaWN0cyh0aGVyYXBpc3RJZCwgdGltZVJhbmdlKSxcbiAgICAgIHRoaXMuY2hlY2tDbGllbnRDb25mbGljdHMoY2xpZW50SWQsIHRpbWVSYW5nZSksXG4gICAgXSk7XG5cbiAgICBjb25zdCBoYXNDb25mbGljdCA9XG4gICAgICB0aGVyYXBpc3RDb25mbGljdHMubGVuZ3RoID4gMCB8fCBjbGllbnRDb25mbGljdHMubGVuZ3RoID4gMDtcbiAgICBsZXQgY29uZmxpY3RUeXBlOiAndGhlcmFwaXN0JyB8ICdjbGllbnQnIHwgJ2JvdGgnIHwgJ25vbmUnID0gJ25vbmUnO1xuXG4gICAgaWYgKHRoZXJhcGlzdENvbmZsaWN0cy5sZW5ndGggPiAwICYmIGNsaWVudENvbmZsaWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25mbGljdFR5cGUgPSAnYm90aCc7XG4gICAgfSBlbHNlIGlmICh0aGVyYXBpc3RDb25mbGljdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uZmxpY3RUeXBlID0gJ3RoZXJhcGlzdCc7XG4gICAgfSBlbHNlIGlmIChjbGllbnRDb25mbGljdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uZmxpY3RUeXBlID0gJ2NsaWVudCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc0NvbmZsaWN0LFxuICAgICAgY29uZmxpY3RpbmdNZWV0aW5nczogWy4uLnRoZXJhcGlzdENvbmZsaWN0cywgLi4uY2xpZW50Q29uZmxpY3RzXSxcbiAgICAgIGNvbmZsaWN0VHlwZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGZvciBjb25mbGljdHMgaW4gdGhlcmFwaXN0J3Mgc2NoZWR1bGVcbiAgICovXG4gIGFzeW5jIGNoZWNrVGhlcmFwaXN0Q29uZmxpY3RzKFxuICAgIHRoZXJhcGlzdElkOiBzdHJpbmcsXG4gICAgdGltZVJhbmdlOiBUaW1lUmFuZ2UsXG4gICk6IFByb21pc2U8YW55W10+IHtcbiAgICByZXR1cm4gdGhpcy5maW5kQ29uZmxpY3RpbmdNZWV0aW5ncyh7XG4gICAgICB0aGVyYXBpc3RJZCxcbiAgICAgIHRpbWVSYW5nZSxcbiAgICAgIHN0YXR1c2VzOiBbJ1NDSEVEVUxFRCcsICdDT05GSVJNRUQnLCAnSU5fUFJPR1JFU1MnXSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBmb3IgY29uZmxpY3RzIGluIGNsaWVudCdzIHNjaGVkdWxlXG4gICAqL1xuICBhc3luYyBjaGVja0NsaWVudENvbmZsaWN0cyhcbiAgICBjbGllbnRJZDogc3RyaW5nLFxuICAgIHRpbWVSYW5nZTogVGltZVJhbmdlLFxuICApOiBQcm9taXNlPGFueVtdPiB7XG4gICAgcmV0dXJuIHRoaXMuZmluZENvbmZsaWN0aW5nTWVldGluZ3Moe1xuICAgICAgY2xpZW50SWQsXG4gICAgICB0aW1lUmFuZ2UsXG4gICAgICBzdGF0dXNlczogWydTQ0hFRFVMRUQnLCAnQ09ORklSTUVEJywgJ0lOX1BST0dSRVNTJ10sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdXBkYXRpbmcgYSBtZWV0aW5nIHdvdWxkIGNhdXNlIGNvbmZsaWN0c1xuICAgKi9cbiAgYXN5bmMgY2hlY2tVcGRhdGVDb25mbGljdHMoXG4gICAgbWVldGluZ0lkOiBzdHJpbmcsXG4gICAgdGhlcmFwaXN0SWQ6IHN0cmluZyxcbiAgICBjbGllbnRJZDogc3RyaW5nLFxuICAgIG5ld1N0YXJ0VGltZTogRGF0ZSxcbiAgICBuZXdEdXJhdGlvbjogbnVtYmVyLFxuICApOiBQcm9taXNlPENvbmZsaWN0UmVzdWx0PiB7XG4gICAgY29uc3QgZW5kVGltZSA9IG5ldyBEYXRlKG5ld1N0YXJ0VGltZS5nZXRUaW1lKCkgKyBuZXdEdXJhdGlvbiAqIDYwICogMTAwMCk7XG4gICAgY29uc3QgdGltZVJhbmdlID0geyBzdGFydFRpbWU6IG5ld1N0YXJ0VGltZSwgZW5kVGltZSB9O1xuXG4gICAgLy8gRmluZCBjb25mbGljdHMgZXhjbHVkaW5nIHRoZSBjdXJyZW50IG1lZXRpbmdcbiAgICBjb25zdCBjb25mbGljdHMgPSBhd2FpdCB0aGlzLmZpbmRDb25mbGljdGluZ01lZXRpbmdzKHtcbiAgICAgIHRoZXJhcGlzdElkLFxuICAgICAgY2xpZW50SWQsXG4gICAgICB0aW1lUmFuZ2UsXG4gICAgICBzdGF0dXNlczogWydTQ0hFRFVMRUQnLCAnQ09ORklSTUVEJywgJ0lOX1BST0dSRVNTJ10sXG4gICAgICBleGNsdWRlTWVldGluZ0lkOiBtZWV0aW5nSWQsXG4gICAgfSk7XG5cbiAgICBjb25zdCB0aGVyYXBpc3RDb25mbGljdHMgPSBjb25mbGljdHMuZmlsdGVyKFxuICAgICAgKG0pID0+IG0udGhlcmFwaXN0SWQgPT09IHRoZXJhcGlzdElkLFxuICAgICk7XG4gICAgY29uc3QgY2xpZW50Q29uZmxpY3RzID0gY29uZmxpY3RzLmZpbHRlcigobSkgPT4gbS5jbGllbnRJZCA9PT0gY2xpZW50SWQpO1xuXG4gICAgY29uc3QgaGFzQ29uZmxpY3QgPSBjb25mbGljdHMubGVuZ3RoID4gMDtcbiAgICBsZXQgY29uZmxpY3RUeXBlOiAndGhlcmFwaXN0JyB8ICdjbGllbnQnIHwgJ2JvdGgnIHwgJ25vbmUnID0gJ25vbmUnO1xuXG4gICAgaWYgKHRoZXJhcGlzdENvbmZsaWN0cy5sZW5ndGggPiAwICYmIGNsaWVudENvbmZsaWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25mbGljdFR5cGUgPSAnYm90aCc7XG4gICAgfSBlbHNlIGlmICh0aGVyYXBpc3RDb25mbGljdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uZmxpY3RUeXBlID0gJ3RoZXJhcGlzdCc7XG4gICAgfSBlbHNlIGlmIChjbGllbnRDb25mbGljdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uZmxpY3RUeXBlID0gJ2NsaWVudCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc0NvbmZsaWN0LFxuICAgICAgY29uZmxpY3RpbmdNZWV0aW5nczogY29uZmxpY3RzLFxuICAgICAgY29uZmxpY3RUeXBlLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgZm9yIGNvbmZsaWN0cyB3aGVuIGJ1bGsgc2NoZWR1bGluZyBtdWx0aXBsZSBtZWV0aW5nc1xuICAgKi9cbiAgYXN5bmMgY2hlY2tCdWxrQ29uZmxpY3RzKFxuICAgIG1lZXRpbmdzOiBBcnJheTx7XG4gICAgICB0aGVyYXBpc3RJZDogc3RyaW5nO1xuICAgICAgY2xpZW50SWQ6IHN0cmluZztcbiAgICAgIHN0YXJ0VGltZTogRGF0ZTtcbiAgICAgIGR1cmF0aW9uOiBudW1iZXI7XG4gICAgfT4sXG4gICk6IFByb21pc2U8eyBtZWV0aW5nSW5kZXg6IG51bWJlcjsgY29uZmxpY3RzOiBDb25mbGljdFJlc3VsdCB9W10+IHtcbiAgICBjb25zdCBjb25mbGljdHM6IHsgbWVldGluZ0luZGV4OiBudW1iZXI7IGNvbmZsaWN0czogQ29uZmxpY3RSZXN1bHQgfVtdID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lZXRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBtZWV0aW5nID0gbWVldGluZ3NbaV07XG5cbiAgICAgIC8vIENoZWNrIGFnYWluc3QgZXhpc3RpbmcgbWVldGluZ3NcbiAgICAgIGNvbnN0IGV4aXN0aW5nQ29uZmxpY3RzID0gYXdhaXQgdGhpcy5jaGVja1NjaGVkdWxpbmdDb25mbGljdHMoXG4gICAgICAgIG1lZXRpbmcudGhlcmFwaXN0SWQsXG4gICAgICAgIG1lZXRpbmcuY2xpZW50SWQsXG4gICAgICAgIG1lZXRpbmcuc3RhcnRUaW1lLFxuICAgICAgICBtZWV0aW5nLmR1cmF0aW9uLFxuICAgICAgKTtcblxuICAgICAgLy8gQ2hlY2sgYWdhaW5zdCBvdGhlciBtZWV0aW5ncyBpbiB0aGUgYnVsayBvcGVyYXRpb25cbiAgICAgIGNvbnN0IGludGVybmFsQ29uZmxpY3RzID0gdGhpcy5jaGVja0ludGVybmFsQ29uZmxpY3RzKFxuICAgICAgICBtZWV0aW5nLFxuICAgICAgICBtZWV0aW5ncyxcbiAgICAgICAgaSxcbiAgICAgICk7XG5cbiAgICAgIGlmIChleGlzdGluZ0NvbmZsaWN0cy5oYXNDb25mbGljdCB8fCBpbnRlcm5hbENvbmZsaWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbmZsaWN0cy5wdXNoKHtcbiAgICAgICAgICBtZWV0aW5nSW5kZXg6IGksXG4gICAgICAgICAgY29uZmxpY3RzOiB7XG4gICAgICAgICAgICBoYXNDb25mbGljdDogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZsaWN0aW5nTWVldGluZ3M6IFtcbiAgICAgICAgICAgICAgLi4uZXhpc3RpbmdDb25mbGljdHMuY29uZmxpY3RpbmdNZWV0aW5ncyxcbiAgICAgICAgICAgICAgLi4uaW50ZXJuYWxDb25mbGljdHMsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgY29uZmxpY3RUeXBlOiBleGlzdGluZ0NvbmZsaWN0cy5jb25mbGljdFR5cGUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZsaWN0cztcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmluZENvbmZsaWN0aW5nTWVldGluZ3Moe1xuICAgIHRoZXJhcGlzdElkLFxuICAgIGNsaWVudElkLFxuICAgIHRpbWVSYW5nZSxcbiAgICBzdGF0dXNlcyxcbiAgICBleGNsdWRlTWVldGluZ0lkLFxuICB9OiB7XG4gICAgdGhlcmFwaXN0SWQ/OiBzdHJpbmc7XG4gICAgY2xpZW50SWQ/OiBzdHJpbmc7XG4gICAgdGltZVJhbmdlOiBUaW1lUmFuZ2U7XG4gICAgc3RhdHVzZXM6IHN0cmluZ1tdO1xuICAgIGV4Y2x1ZGVNZWV0aW5nSWQ/OiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPGFueVtdPiB7XG4gICAgY29uc3Qgd2hlcmVDb25kaXRpb25zOiBhbnlbXSA9IFtdO1xuXG4gICAgLy8gQWRkIHRoZXJhcGlzdCBjb25kaXRpb25cbiAgICBpZiAodGhlcmFwaXN0SWQpIHtcbiAgICAgIHdoZXJlQ29uZGl0aW9ucy5wdXNoKHtcbiAgICAgICAgdGhlcmFwaXN0SWQsXG4gICAgICAgIHN0YXJ0VGltZTogeyBsdDogdGltZVJhbmdlLmVuZFRpbWUgfSxcbiAgICAgICAgLy8gVXNlIGEgY29tcHV0ZWQgZW5kVGltZSBmb3IgcHJvcGVyIG92ZXJsYXAgZGV0ZWN0aW9uXG4gICAgICAgIE9SOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gTWVldGluZyBzdGFydHMgYmVmb3JlIG91ciBlbmQgdGltZSBhbmQgaGFzbid0IGVuZGVkIHlldFxuICAgICAgICAgICAgc3RhcnRUaW1lOiB7IGd0ZTogdGltZVJhbmdlLnN0YXJ0VGltZSB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gTWVldGluZyBzdGFydGVkIGJlZm9yZSBvdXIgc3RhcnQgdGltZSBidXQgZXh0ZW5kcyBpbnRvIG91ciB0aW1lXG4gICAgICAgICAgICBzdGFydFRpbWU6IHsgbHQ6IHRpbWVSYW5nZS5zdGFydFRpbWUgfSxcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBiaXQgY29tcGxleCBpbiBQcmlzbWEgLSB3ZSBuZWVkIHRvIHVzZSByYXcgU1FMIG9yIGNvbXB1dGUgZW5kVGltZVxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXR1czogeyBpbjogc3RhdHVzZXMgfSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCBjbGllbnQgY29uZGl0aW9uXG4gICAgaWYgKGNsaWVudElkKSB7XG4gICAgICB3aGVyZUNvbmRpdGlvbnMucHVzaCh7XG4gICAgICAgIGNsaWVudElkLFxuICAgICAgICBzdGFydFRpbWU6IHsgbHQ6IHRpbWVSYW5nZS5lbmRUaW1lIH0sXG4gICAgICAgIE9SOiBbXG4gICAgICAgICAgeyBzdGFydFRpbWU6IHsgZ3RlOiB0aW1lUmFuZ2Uuc3RhcnRUaW1lIH0gfSxcbiAgICAgICAgICB7IHN0YXJ0VGltZTogeyBsdDogdGltZVJhbmdlLnN0YXJ0VGltZSB9IH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXR1czogeyBpbjogc3RhdHVzZXMgfSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh3aGVyZUNvbmRpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgbWVldGluZ3MgPSBhd2FpdCB0aGlzLnByaXNtYS5tZWV0aW5nLmZpbmRNYW55KHtcbiAgICAgIHdoZXJlOiB7XG4gICAgICAgIE9SOiB3aGVyZUNvbmRpdGlvbnMsXG4gICAgICAgIC4uLihleGNsdWRlTWVldGluZ0lkICYmIHsgaWQ6IHsgbm90OiBleGNsdWRlTWVldGluZ0lkIH0gfSksXG4gICAgICB9LFxuICAgICAgaW5jbHVkZToge1xuICAgICAgICBjbGllbnQ6IHtcbiAgICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICAgICAgc2VsZWN0OiB7IGZpcnN0TmFtZTogdHJ1ZSwgbGFzdE5hbWU6IHRydWUgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdGhlcmFwaXN0OiB7XG4gICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICAgIHNlbGVjdDogeyBmaXJzdE5hbWU6IHRydWUsIGxhc3ROYW1lOiB0cnVlIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gRmlsdGVyIG1lZXRpbmdzIHRoYXQgYWN0dWFsbHkgb3ZlcmxhcCAoc2luY2UgUHJpc21hIGRvZXNuJ3QgaGFuZGxlIGNvbXB1dGVkIGVuZFRpbWUgd2VsbClcbiAgICByZXR1cm4gbWVldGluZ3MuZmlsdGVyKChtZWV0aW5nKSA9PiB7XG4gICAgICBjb25zdCBtZWV0aW5nRW5kVGltZSA9IG5ldyBEYXRlKFxuICAgICAgICBtZWV0aW5nLnN0YXJ0VGltZS5nZXRUaW1lKCkgKyBtZWV0aW5nLmR1cmF0aW9uICogNjAgKiAxMDAwLFxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGlzLmhhc1RpbWVPdmVybGFwKFxuICAgICAgICB0aW1lUmFuZ2Uuc3RhcnRUaW1lLFxuICAgICAgICB0aW1lUmFuZ2UuZW5kVGltZSxcbiAgICAgICAgbWVldGluZy5zdGFydFRpbWUsXG4gICAgICAgIG1lZXRpbmdFbmRUaW1lLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tJbnRlcm5hbENvbmZsaWN0cyhcbiAgICBjdXJyZW50TWVldGluZzoge1xuICAgICAgdGhlcmFwaXN0SWQ6IHN0cmluZztcbiAgICAgIGNsaWVudElkOiBzdHJpbmc7XG4gICAgICBzdGFydFRpbWU6IERhdGU7XG4gICAgICBkdXJhdGlvbjogbnVtYmVyO1xuICAgIH0sXG4gICAgYWxsTWVldGluZ3M6IEFycmF5PHtcbiAgICAgIHRoZXJhcGlzdElkOiBzdHJpbmc7XG4gICAgICBjbGllbnRJZDogc3RyaW5nO1xuICAgICAgc3RhcnRUaW1lOiBEYXRlO1xuICAgICAgZHVyYXRpb246IG51bWJlcjtcbiAgICB9PixcbiAgICBjdXJyZW50SW5kZXg6IG51bWJlcixcbiAgKTogYW55W10ge1xuICAgIGNvbnN0IGNvbmZsaWN0czogYW55W10gPSBbXTtcbiAgICBjb25zdCBjdXJyZW50RW5kVGltZSA9IG5ldyBEYXRlKFxuICAgICAgY3VycmVudE1lZXRpbmcuc3RhcnRUaW1lLmdldFRpbWUoKSArIGN1cnJlbnRNZWV0aW5nLmR1cmF0aW9uICogNjAgKiAxMDAwLFxuICAgICk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbE1lZXRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSA9PT0gY3VycmVudEluZGV4KSBjb250aW51ZTtcblxuICAgICAgY29uc3Qgb3RoZXJNZWV0aW5nID0gYWxsTWVldGluZ3NbaV07XG4gICAgICBjb25zdCBvdGhlckVuZFRpbWUgPSBuZXcgRGF0ZShcbiAgICAgICAgb3RoZXJNZWV0aW5nLnN0YXJ0VGltZS5nZXRUaW1lKCkgKyBvdGhlck1lZXRpbmcuZHVyYXRpb24gKiA2MCAqIDEwMDAsXG4gICAgICApO1xuXG4gICAgICAvLyBDaGVjayBpZiBtZWV0aW5ncyBpbnZvbHZlIHRoZSBzYW1lIHBlb3BsZVxuICAgICAgY29uc3Qgc2FtZVRoZXJhcGlzdCA9XG4gICAgICAgIGN1cnJlbnRNZWV0aW5nLnRoZXJhcGlzdElkID09PSBvdGhlck1lZXRpbmcudGhlcmFwaXN0SWQ7XG4gICAgICBjb25zdCBzYW1lQ2xpZW50ID0gY3VycmVudE1lZXRpbmcuY2xpZW50SWQgPT09IG90aGVyTWVldGluZy5jbGllbnRJZDtcblxuICAgICAgaWYgKFxuICAgICAgICAoc2FtZVRoZXJhcGlzdCB8fCBzYW1lQ2xpZW50KSAmJlxuICAgICAgICB0aGlzLmhhc1RpbWVPdmVybGFwKFxuICAgICAgICAgIGN1cnJlbnRNZWV0aW5nLnN0YXJ0VGltZSxcbiAgICAgICAgICBjdXJyZW50RW5kVGltZSxcbiAgICAgICAgICBvdGhlck1lZXRpbmcuc3RhcnRUaW1lLFxuICAgICAgICAgIG90aGVyRW5kVGltZSxcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIGNvbmZsaWN0cy5wdXNoKHtcbiAgICAgICAgICAuLi5vdGhlck1lZXRpbmcsXG4gICAgICAgICAgY29uZmxpY3RUeXBlOlxuICAgICAgICAgICAgc2FtZVRoZXJhcGlzdCAmJiBzYW1lQ2xpZW50XG4gICAgICAgICAgICAgID8gJ2JvdGgnXG4gICAgICAgICAgICAgIDogc2FtZVRoZXJhcGlzdFxuICAgICAgICAgICAgICAgID8gJ3RoZXJhcGlzdCdcbiAgICAgICAgICAgICAgICA6ICdjbGllbnQnLFxuICAgICAgICAgIGlzSW50ZXJuYWxDb25mbGljdDogdHJ1ZSxcbiAgICAgICAgICBjb25mbGljdEluZGV4OiBpLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29uZmxpY3RzO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHR3byB0aW1lIHJhbmdlcyBvdmVybGFwXG4gICAqL1xuICBoYXNUaW1lT3ZlcmxhcChzdGFydDE6IERhdGUsIGVuZDE6IERhdGUsIHN0YXJ0MjogRGF0ZSwgZW5kMjogRGF0ZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzdGFydDEgPCBlbmQyICYmIGVuZDEgPiBzdGFydDI7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhhdCBhIHByb3Bvc2VkIG1lZXRpbmcgdGltZSBkb2Vzbid0IGNvbmZsaWN0XG4gICAqIFRocm93cyBCYWRSZXF1ZXN0RXhjZXB0aW9uIGlmIGNvbmZsaWN0cyBhcmUgZm91bmRcbiAgICovXG4gIGFzeW5jIHZhbGlkYXRlTm9Db25mbGljdHMoXG4gICAgdGhlcmFwaXN0SWQ6IHN0cmluZyxcbiAgICBjbGllbnRJZDogc3RyaW5nLFxuICAgIHN0YXJ0VGltZTogRGF0ZSxcbiAgICBkdXJhdGlvbjogbnVtYmVyLFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBjb25mbGljdHMgPSBhd2FpdCB0aGlzLmNoZWNrU2NoZWR1bGluZ0NvbmZsaWN0cyhcbiAgICAgIHRoZXJhcGlzdElkLFxuICAgICAgY2xpZW50SWQsXG4gICAgICBzdGFydFRpbWUsXG4gICAgICBkdXJhdGlvbixcbiAgICApO1xuXG4gICAgaWYgKGNvbmZsaWN0cy5oYXNDb25mbGljdCkge1xuICAgICAgY29uc3QgY29uZmxpY3RNZXNzYWdlcyA9IGNvbmZsaWN0cy5jb25mbGljdGluZ01lZXRpbmdzLm1hcCgobWVldGluZykgPT4ge1xuICAgICAgICBjb25zdCBtZWV0aW5nU3RhcnQgPSBtZWV0aW5nLnN0YXJ0VGltZS50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICBjb25zdCBtZWV0aW5nRW5kID0gbmV3IERhdGUoXG4gICAgICAgICAgbWVldGluZy5zdGFydFRpbWUuZ2V0VGltZSgpICsgbWVldGluZy5kdXJhdGlvbiAqIDYwMDAwLFxuICAgICAgICApLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBgTWVldGluZyBmcm9tICR7bWVldGluZ1N0YXJ0fSB0byAke21lZXRpbmdFbmR9YDtcbiAgICAgIH0pO1xuXG4gICAgICB0aHJvdyBuZXcgQmFkUmVxdWVzdEV4Y2VwdGlvbihcbiAgICAgICAgYFRpbWUgc2xvdCBjb25mbGljdHMgd2l0aCBleGlzdGluZyBtZWV0aW5nczogJHtjb25mbGljdE1lc3NhZ2VzLmpvaW4oJywgJyl9YCxcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iXSwidmVyc2lvbiI6M30=