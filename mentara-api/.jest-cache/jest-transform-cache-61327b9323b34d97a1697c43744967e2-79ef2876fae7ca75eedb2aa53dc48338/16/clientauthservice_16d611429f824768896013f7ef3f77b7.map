{"file":"/home/wetooa/Documents/code/projects/mentara/mentara-api/src/auth/services/client-auth.service.ts","mappings":"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","names":[],"sources":["/home/wetooa/Documents/code/projects/mentara/mentara-api/src/auth/services/client-auth.service.ts"],"sourcesContent":["import {\n  Injectable,\n  UnauthorizedException,\n  BadRequestException,\n} from '@nestjs/common';\nimport type { RegisterClientDto, EmailResponse } from '../types';\nimport { PrismaService } from '../../providers/prisma-client.provider';\nimport { TokenService } from './token.service';\nimport { EmailService } from '../../email/email.service';\nimport { EmailVerificationService } from './email-verification.service';\nimport * as bcrypt from 'bcrypt';\n\n@Injectable()\nexport class ClientAuthService {\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly tokenService: TokenService,\n    private readonly emailService: EmailService,\n    private readonly emailVerificationService: EmailVerificationService,\n  ) {}\n\n  async registerClient(registerDto: RegisterClientDto) {\n    console.log('Registering client with preassessment data:', registerDto);\n\n    // Check if user already exists\n    const existingUser = await this.prisma.user.findUnique({\n      where: { email: registerDto.email },\n    });\n\n    if (existingUser) {\n      throw new BadRequestException('User with this email already exists');\n    }\n\n    // Hash password\n    const hashedPassword = await bcrypt.hash(registerDto.password, 12);\n\n    // Create user and client profile in transaction\n    const result = await this.prisma.$transaction(async (tx) => {\n      const user = await tx.user.create({\n        data: {\n          email: registerDto.email,\n          password: hashedPassword,\n          firstName: registerDto.firstName,\n          lastName: registerDto.lastName,\n          middleName: registerDto.middleName || undefined,\n          birthDate: registerDto.birthDate\n            ? new Date(registerDto.birthDate)\n            : undefined,\n          address: registerDto.address || undefined,\n          avatarUrl: registerDto.avatarUrl || undefined,\n          role: 'client',\n          emailVerified: false,\n        },\n      });\n\n      const client = await tx.client.create({\n        data: {\n          userId: user.id,\n          hasSeenTherapistRecommendations:\n            registerDto.hasSeenTherapistRecommendations || false,\n        },\n      });\n\n      // Create preassessment record if answers are provided\n      let preAssessment: any = null;\n      if (\n        registerDto.preassessmentAnswers &&\n        registerDto.preassessmentAnswers.length > 0\n      ) {\n        preAssessment = await tx.preAssessment.create({\n          data: {\n            clientId: user.id,\n            answers: registerDto.preassessmentAnswers,\n            scores: {}, // Empty until processed\n            severityLevels: {}, // Empty until processed\n            aiEstimate: {}, // Empty until processed\n            isProcessed: false, // Will be processed later\n          },\n        });\n      }\n\n      return { user, client, preAssessment };\n    });\n\n    // Generate single token\n    const { token } = await this.tokenService.generateToken(\n      result.user.id,\n      result.user.email,\n      result.user.role,\n    );\n\n    // Send verification email using EmailVerificationService\n    await this.emailVerificationService.sendVerificationEmail(result.user.id);\n\n    return {\n      user: result.user,\n      tokens: { accessToken: token, refreshToken: token, expiresIn: 0 }, // For backward compatibility\n      message: result.preAssessment\n        ? 'Client registration and pre-assessment data saved successfully. Please check your email for the verification code.'\n        : 'Client registration successful. Please check your email for the verification code.',\n    };\n  }\n\n  async loginClient(\n    email: string,\n    password: string,\n    ipAddress?: string,\n    userAgent?: string,\n  ) {\n    // Find user with client role\n    const user = await this.prisma.user.findFirst({\n      where: {\n        email,\n        role: 'client',\n      },\n      include: {\n        client: true,\n      },\n    });\n\n    if (!user) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    // Check if account is locked\n    if (user.lockoutUntil && user.lockoutUntil > new Date()) {\n      throw new UnauthorizedException(\n        'Account is temporarily locked due to failed login attempts',\n      );\n    }\n\n    // Verify password\n    if (!user.password) {\n      throw new UnauthorizedException('Account setup incomplete');\n    }\n    const isPasswordValid = await bcrypt.compare(password, user.password);\n    if (!isPasswordValid) {\n      // Increment failed login count\n      await this.handleFailedLogin(user.id);\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    // Reset failed login count and update last login\n    await this.prisma.user.update({\n      where: { id: user.id },\n      data: {\n        failedLoginCount: 0,\n        lockoutUntil: null,\n        lastLoginAt: new Date(),\n      },\n    });\n\n    // Generate single token\n    const { token } = await this.tokenService.generateToken(\n      user.id,\n      user.email,\n      user.role,\n    );\n\n    return {\n      user,\n      tokens: { accessToken: token, refreshToken: token, expiresIn: 0 }, // For backward compatibility\n    };\n  }\n\n  async getClientProfile(userId: string) {\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n      select: {\n        id: true,\n        email: true,\n        firstName: true,\n        lastName: true,\n        birthDate: true,\n        createdAt: true,\n        role: true,\n        client: {\n          include: {\n            assignedTherapists: {\n              include: {\n                therapist: {\n                  include: {\n                    user: {\n                      select: {\n                        id: true,\n                        firstName: true,\n                        lastName: true,\n                        email: true,\n                        avatarUrl: true,\n                      },\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    });\n\n    if (!user || user.role !== 'client') {\n      throw new UnauthorizedException('Client not found');\n    }\n\n    // Return in the expected ClientProfileResponse format\n    return {\n      id: user.id,\n      email: user.email,\n      firstName: user.firstName || '',\n      lastName: user.lastName || '',\n      role: 'client' as const,\n      dateOfBirth: user.birthDate ? user.birthDate.toISOString() : undefined,\n      phoneNumber: undefined, // Phone number not stored in User model for clients\n      profileComplete: !!(user.firstName && user.lastName && user.birthDate),\n      therapistId:\n        user.client?.assignedTherapists?.[0]?.therapist?.user?.id || undefined,\n      createdAt: user.createdAt.toISOString(),\n      hasSeenTherapistRecommendations:\n        user.client?.hasSeenTherapistRecommendations || false,\n    };\n  }\n\n  async getFirstSignInStatus(userId: string) {\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n      include: {\n        client: {\n          select: {\n            hasSeenTherapistRecommendations: true,\n          },\n        },\n      },\n    });\n\n    if (!user || !user.client) {\n      throw new UnauthorizedException('Client not found');\n    }\n\n    // Return in the expected OnboardingStatusResponse format\n    const profileCompleted = !!(\n      user.firstName &&\n      user.lastName &&\n      user.birthDate\n    );\n    const assessmentCompleted = false; // TODO: implement assessment completion check\n    const completedSteps: string[] = [];\n\n    if (profileCompleted) completedSteps.push('profile');\n    if (user.client.hasSeenTherapistRecommendations)\n      completedSteps.push('recommendations');\n    if (assessmentCompleted) completedSteps.push('assessment');\n\n    return {\n      isFirstSignIn: !user.lastLoginAt,\n      hasSeenRecommendations: user.client.hasSeenTherapistRecommendations,\n      profileCompleted,\n      assessmentCompleted,\n      isOnboardingComplete:\n        profileCompleted &&\n        user.client.hasSeenTherapistRecommendations &&\n        assessmentCompleted,\n      completedSteps,\n      nextStep: !profileCompleted\n        ? 'profile'\n        : !user.client.hasSeenTherapistRecommendations\n          ? 'recommendations'\n          : !assessmentCompleted\n            ? 'assessment'\n            : undefined,\n    };\n  }\n\n  async markRecommendationsSeen(userId: string) {\n    const client = await this.prisma.client.findUnique({\n      where: { userId },\n    });\n\n    if (!client) {\n      throw new UnauthorizedException('Client not found');\n    }\n\n    await this.prisma.client.update({\n      where: { userId },\n      data: {\n        hasSeenTherapistRecommendations: true,\n      },\n    });\n\n    // Return in the expected SuccessResponse format\n    return {\n      success: true,\n      message: 'Recommendations marked as seen',\n    };\n  }\n\n  async verifyRegistrationOtp(\n    email: string,\n    otpCode: string,\n  ): Promise<EmailResponse> {\n    if (!otpCode || !email) {\n      throw new BadRequestException('Email and OTP code are required');\n    }\n\n    // First verify the user exists and has client role\n    const user = await this.prisma.user.findFirst({\n      where: {\n        email,\n        role: 'client',\n      },\n    });\n\n    if (!user) {\n      throw new BadRequestException('Invalid email');\n    }\n\n    // Use EmailVerificationService to verify the OTP\n    const result = await this.emailVerificationService.verifyEmail(otpCode);\n\n    if (result.success) {\n      // Update emailVerified flag for client\n      await this.prisma.user.update({\n        where: { id: user.id },\n        data: {\n          emailVerified: true,\n        },\n      });\n    }\n\n    return {\n      success: result.success,\n      status: result.success ? 'success' : 'error',\n      message: result.message,\n    };\n  }\n\n  async resendRegistrationOtp(email: string): Promise<EmailResponse> {\n    if (!email) {\n      throw new BadRequestException('Email is required');\n    }\n\n    // Find user with client role\n    const user = await this.prisma.user.findFirst({\n      where: {\n        email,\n        role: 'client',\n      },\n      select: {\n        id: true,\n        email: true,\n        firstName: true,\n        emailVerified: true,\n      },\n    });\n\n    if (!user) {\n      // Don't reveal if email exists for security, but return success\n      return {\n        success: true,\n        status: 'success',\n        message:\n          'If an account with this email exists, a new verification code has been sent.',\n      };\n    }\n\n    if (user.emailVerified) {\n      throw new BadRequestException('Email already verified');\n    }\n\n    // Use EmailVerificationService to resend verification email\n    await this.emailVerificationService.resendVerificationEmail(email);\n\n    return {\n      success: true,\n      status: 'success',\n      message: 'A new verification code has been sent to your email.',\n    };\n  }\n\n  private async handleFailedLogin(userId: string) {\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n      select: { failedLoginCount: true },\n    });\n\n    const newFailedCount = (user?.failedLoginCount || 0) + 1;\n    const maxAttempts = 5;\n    const lockoutDuration = 30 * 60 * 1000; // 30 minutes\n\n    const updateData: any = {\n      failedLoginCount: newFailedCount,\n    };\n\n    if (newFailedCount >= maxAttempts) {\n      updateData.lockoutUntil = new Date(Date.now() + lockoutDuration);\n    }\n\n    await this.prisma.user.update({\n      where: { id: userId },\n      data: updateData,\n    });\n  }\n}\n"],"version":3}